{"version":3,"file":"688/cccb3a7f892b924f927b.js","mappings":"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","sources":["webpack://[name]Destination/../../node_modules/@segment/fql-ts/dist/esm/constants.js","webpack://[name]Destination/../../node_modules/@segment/fql-ts/dist/esm/reader.js","webpack://[name]Destination/../../node_modules/@segment/fql-ts/dist/esm/lexer.js","webpack://[name]Destination/../../node_modules/@segment/fql-ts/dist/esm/strings.js","webpack://[name]Destination/../../node_modules/@segment/fql-ts/dist/esm/token.js","webpack://[name]Destination/../../node_modules/aggregate-error/index.js","webpack://[name]Destination/../../node_modules/aggregate-error/node_modules/clean-stack/index.js","webpack://[name]Destination/../../node_modules/indent-string/index.js","webpack://[name]Destination/../destination-subscriptions/dist/esm/get.js","webpack://[name]Destination/../destination-subscriptions/dist/esm/validate.js","webpack://[name]Destination/../destination-subscriptions/dist/esm/parse-fql.js","webpack://[name]Destination/./src/runtime/load-script.ts","webpack://[name]Destination/./src/runtime/resolve-when.ts","webpack://[name]Destination/./src/runtime/plugin.ts","webpack://[name]Destination/../core/dist/esm/get.js","webpack://[name]Destination/../core/dist/esm/mapping-kit/is-directive.js","webpack://[name]Destination/../core/dist/esm/mapping-kit/placeholders.js","webpack://[name]Destination/../core/dist/esm/remove-undefined.js","webpack://[name]Destination/../core/dist/esm/mapping-kit/validate.js","webpack://[name]Destination/../core/dist/esm/arrify.js","webpack://[name]Destination/../core/dist/esm/mapping-kit/index.js","webpack://[name]Destination/../core/dist/esm/real-type-of.js","webpack://[name]Destination/../../node_modules/ts-custom-error/dist/custom-error.mjs"],"sourcesContent":["export const EOS_FLAG = '-1';\n//# sourceMappingURL=constants.js.map","export default class Reader {\n    constructor(code) {\n        this.code = code;\n        this.position = 0;\n    }\n    forward() {\n        if (this.code.length === this.position) {\n            return { char: '', isEOS: true };\n        }\n        const char = this.code.charAt(this.position);\n        this.position += 1;\n        return {\n            char,\n            isEOS: false\n        };\n    }\n    backward() {\n        if (this.position === 0) {\n            throw new RangeError();\n        }\n        const char = this.code.charAt(this.position);\n        this.position -= 1;\n        return {\n            char,\n            isEOS: false\n        };\n    }\n    getPosition() {\n        return this.position;\n    }\n}\n//# sourceMappingURL=reader.js.map","import Reader from './reader';\nimport { t } from './token';\nimport { EOS_FLAG } from './constants';\nimport { isNewLine, isAlpha, isTerminator, isIdent, isWhitespace, isNumber } from './strings';\nconst MAXIMUM_INDENT_LENGTH = 100000; // bug catcher\nconst MAXIMUM_NUMBER_LENGTH = 100000;\nconst MAXIMUM_STRING_LENGTH = 100000;\nexport class LexerError extends Error {\n    constructor(message, cursor) {\n        super(message);\n        this.message = message;\n        this.name = 'LexerError';\n        this.stack = new Error().stack;\n        this.cursor = cursor;\n    }\n}\n/**\n * Converts FQL code into tokens.\n * @param code the FQL code to convert\n * @throws LexerError if something goes wrong\n */\nexport default function lex(code) {\n    try {\n        const lexer = new Lexer(code);\n        return { tokens: lexer.lex() };\n    }\n    catch (error) {\n        return { tokens: [], error };\n    }\n}\nexport class Lexer {\n    constructor(code) {\n        this.reader = new Reader(code);\n        this.cursor = {\n            line: 0,\n            column: 0\n        };\n    }\n    lex() {\n        const tokens = [];\n        while (true) {\n            const { char, isEOS } = this.next();\n            if (isEOS) {\n                tokens.push(t.EOS());\n                return tokens;\n            }\n            if (isWhitespace(char)) {\n                continue;\n            }\n            if (char === '!') {\n                const nextChar = this.peek();\n                if (isAlpha(nextChar) || nextChar === '(') {\n                    tokens.push(t.Operator('!'));\n                    continue;\n                }\n            }\n            if (isAlpha(char) || char === '!' || char === '=' || char === '>' || char === '<' || char === '\\\\' || char === '_') {\n                tokens.push(this.lexOperatorOrConditional(char));\n                continue;\n            }\n            if (isNumber(char) || char === '-' || char === '+') {\n                tokens.push(this.lexNumber(char));\n                continue;\n            }\n            if (char === '\"' || char === '\\'') {\n                tokens.push(this.lexString(char));\n                continue;\n            }\n            if (char === '.') {\n                tokens.push(t.Dot());\n                continue;\n            }\n            if (char === '[') {\n                tokens.push(t.BrackLeft());\n                continue;\n            }\n            if (char === ']') {\n                tokens.push(t.BrackRight());\n                continue;\n            }\n            if (char === ',') {\n                tokens.push(t.Comma());\n                continue;\n            }\n            if (char === '(') {\n                tokens.push(t.ParenLeft());\n                continue;\n            }\n            if (char === ')') {\n                tokens.push(t.ParenRight());\n                continue;\n            }\n            throw new LexerError(`invalid character \"${char}\"`, this.cursor);\n        }\n    }\n    lexString(openQuote) {\n        let str = '';\n        // Looking for closing string of same type of quote (single or double)\n        while (this.peek() !== openQuote) {\n            const { char, isEOS } = this.next();\n            str += char;\n            if (isEOS) {\n                throw new LexerError('unterminated string', this.cursor);\n            }\n            if (str.length >= MAXIMUM_STRING_LENGTH) {\n                throw new LexerError('unreasonable string length', this.cursor);\n            }\n        }\n        this.accept(openQuote); // Eat the last quote\n        return t.String(`${openQuote}${str}${openQuote}`);\n    }\n    lexNumber(previous) {\n        let str = '';\n        let comingUp = this.peek();\n        let isDecimal = false;\n        while (isNumber(comingUp) || comingUp === '.') {\n            const { char } = this.next();\n            str += char;\n            // Prevent multiple decimal points and stray decimal points\n            if (comingUp === '.') {\n                if (isTerminator(this.peek())) {\n                    throw new LexerError('unexpected terminator after decimal point', this.cursor);\n                }\n                if (isDecimal) {\n                    throw new LexerError('multiple decimal points in one number', this.cursor);\n                }\n                isDecimal = true;\n            }\n            // Prevent infinite loops\n            if (str.length >= MAXIMUM_NUMBER_LENGTH) {\n                throw new LexerError('unreasonable number length', this.cursor);\n            }\n            comingUp = this.peek();\n        }\n        return t.Number(previous + str);\n    }\n    lexOperatorOrConditional(previous) {\n        // =\n        if (previous === '=') {\n            return t.Operator('=');\n        }\n        // !=\n        if (previous === '!') {\n            if (this.accept('=')) {\n                return t.Operator('!=');\n            }\n            throw new LexerError(`expected '=' after '!', got '${this.peek()}'`, this.cursor);\n        }\n        // and\n        if (previous === 'a') {\n            if (this.accept('nd')) {\n                return t.Conditional('and');\n            }\n            return this.lexIdent(previous);\n        }\n        // or\n        if (previous === 'o') {\n            if (this.accept('r')) {\n                return t.Conditional('or');\n            }\n            return this.lexIdent(previous);\n        }\n        // null\n        if (previous === 'n') {\n            if (this.accept('ull')) {\n                return t.Null();\n            }\n            return this.lexIdent(previous);\n        }\n        // <=, >=, <, >\n        if (previous === '<' || previous === '>') {\n            if (this.accept('=')) {\n                return t.Operator(previous + '=');\n            }\n            return t.Operator(previous);\n        }\n        // all other idents\n        return this.lexIdent(previous);\n    }\n    lexIdent(previous) {\n        /* this function differs from the go implementation in that the go impl\n         hasn't yet advanced the character so will do a peek/next loop.  here we\n         have already done a next() so need to check to see if the first char is\n         an escape sequence */\n        let str = '';\n        let char = previous;\n        while (true) {\n            // Allow escaping of any character except EOS\n            if (char === '\\\\') {\n                if (this.peek() === EOS_FLAG) {\n                    throw new LexerError('expected character after escape character, got EOS', this.cursor);\n                }\n                char = this.next().char;\n            }\n            str += char;\n            if (str.length >= MAXIMUM_INDENT_LENGTH) {\n                throw new LexerError('unreasonable literal length', this.cursor);\n            }\n            if (!isIdent(this.peek())) {\n                break;\n            }\n            char = this.next().char;\n        }\n        const comingUp = this.peek();\n        if (!(comingUp === EOS_FLAG ||\n            isTerminator(comingUp) ||\n            comingUp === '.' ||\n            comingUp === '(' ||\n            comingUp === '=' ||\n            comingUp === '!')) {\n            throw new LexerError(`expected termination character after identifier, got ${comingUp}`, this.cursor);\n        }\n        return t.Ident(str);\n    }\n    /**\n     * Helpers\n     */\n    // Attempts to advance the string, rolls back and returns false if it can't.\n    accept(str) {\n        let chars = '';\n        for (const _ of str) {\n            const { char, isEOS } = this.next();\n            chars += char;\n            if (isEOS) {\n                return false;\n            }\n            if (isTerminator(char)) {\n                break;\n            }\n        }\n        if (str === chars && isTerminator(this.peek())) {\n            return true;\n        }\n        this.backup(chars.length);\n        return false;\n    }\n    next() {\n        const { char, isEOS } = this.reader.forward();\n        if (isNewLine(char)) {\n            this.cursor.line += 1;\n            this.cursor.column = 0;\n        }\n        else {\n            this.cursor.column += 1;\n        }\n        const c = isEOS ? EOS_FLAG : char;\n        return { char: c, isEOS };\n    }\n    // Looks at the next character and then goes back\n    peek() {\n        const { char, isEOS } = this.next();\n        if (!isEOS) {\n            this.backup(1);\n        }\n        return char;\n    }\n    backup(count) {\n        for (let n = count; n > 0; n--) {\n            let char;\n            try {\n                char = this.reader.backward().char;\n            }\n            catch (err) {\n                return;\n            }\n            if (isNewLine(char)) {\n                this.cursor.line -= 1;\n                this.cursor.column = 0;\n            }\n            else {\n                this.cursor.column -= 1;\n            }\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map","import { EOS_FLAG } from './constants';\nexport function isNewLine(c) {\n    return c === '\\r' || c === '\\n';\n}\nexport function isWhitespace(c) {\n    return c === ' ' || c === '\\t' || c === '\\n';\n}\nexport function isAlpha(c) {\n    return !!c.match(/[a-z]/i);\n}\nexport function isNumber(c) {\n    if (c === EOS_FLAG) {\n        return false;\n    }\n    return !isNaN(parseFloat(c)) && isFinite(parseInt(c, 10));\n}\nexport function isIdent(c) {\n    if (c === EOS_FLAG) {\n        return false;\n    }\n    return isAlpha(c) || isNumber(c) || c === '_' || c === '-' || c === '\\\\';\n}\nexport function isTerminator(c) {\n    return c === EOS_FLAG || isWhitespace(c) || c === ',' || c === ']' || c === ')';\n}\n//# sourceMappingURL=strings.js.map","// Loosely checks if something is a token type at runtime\nexport function isToken(arg) {\n    return arg.type !== undefined && typeof arg.value === 'string';\n}\n// All available tokens forms\nexport var TokenType;\n(function (TokenType) {\n    TokenType[\"Err\"] = \"err\";\n    TokenType[\"Ident\"] = \"ident\";\n    TokenType[\"Dot\"] = \"dot\";\n    TokenType[\"Operator\"] = \"operator\";\n    TokenType[\"Conditional\"] = \"conditional\";\n    TokenType[\"String\"] = \"string\";\n    TokenType[\"Number\"] = \"number\";\n    TokenType[\"Null\"] = \"null\";\n    TokenType[\"BrackLeft\"] = \"brackleft\";\n    TokenType[\"BrackRight\"] = \"brackright\";\n    TokenType[\"ParenLeft\"] = \"parenleft\";\n    TokenType[\"ParenRight\"] = \"parenright\";\n    TokenType[\"Comma\"] = \"comma\";\n    TokenType[\"EOS\"] = \"eos\";\n})(TokenType || (TokenType = {}));\n// Helper functions for creating typed Tokens\nexport const t = {\n    Err: () => {\n        return { type: TokenType.Err, value: 'err' };\n    },\n    Ident: (value) => {\n        return { type: TokenType.Ident, value };\n    },\n    Dot: () => {\n        return { type: TokenType.Dot, value: '.' };\n    },\n    Operator: (value) => {\n        return { type: TokenType.Operator, value };\n    },\n    Conditional: (value) => {\n        return { type: TokenType.Conditional, value };\n    },\n    String: (value) => {\n        return { type: TokenType.String, value };\n    },\n    Number: (value) => {\n        return { type: TokenType.Number, value };\n    },\n    Null: () => {\n        return { type: TokenType.Null, value: 'null' };\n    },\n    BrackLeft: () => {\n        return { type: TokenType.BrackLeft, value: '[' };\n    },\n    BrackRight: () => {\n        return { type: TokenType.BrackRight, value: ']' };\n    },\n    ParenLeft: () => {\n        return { type: TokenType.ParenLeft, value: '(' };\n    },\n    ParenRight: () => {\n        return { type: TokenType.ParenRight, value: ')' };\n    },\n    Comma: () => {\n        return { type: TokenType.Comma, value: ',' };\n    },\n    EOS: () => {\n        return { type: TokenType.EOS, value: 'eos' };\n    }\n};\n//# sourceMappingURL=token.js.map","'use strict';\nconst indentString = require('indent-string');\nconst cleanStack = require('clean-stack');\n\nconst cleanInternalStack = stack => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\nclass AggregateError extends Error {\n\tconstructor(errors) {\n\t\tif (!Array.isArray(errors)) {\n\t\t\tthrow new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n\t\t}\n\n\t\terrors = [...errors].map(error => {\n\t\t\tif (error instanceof Error) {\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (error !== null && typeof error === 'object') {\n\t\t\t\t// Handle plain error objects with message property and/or possibly other metadata\n\t\t\t\treturn Object.assign(new Error(error.message), error);\n\t\t\t}\n\n\t\t\treturn new Error(error);\n\t\t});\n\n\t\tlet message = errors\n\t\t\t.map(error => {\n\t\t\t\t// The `stack` property is not standardized, so we can't assume it exists\n\t\t\t\treturn typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n\t\t\t})\n\t\t\t.join('\\n');\n\t\tmessage = '\\n' + indentString(message, 4);\n\t\tsuper(message);\n\n\t\tthis.name = 'AggregateError';\n\n\t\tObject.defineProperty(this, '_errors', {value: errors});\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const error of this._errors) {\n\t\t\tyield error;\n\t\t}\n\t}\n}\n\nmodule.exports = AggregateError;\n","'use strict';\nconst os = require('os');\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/;\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\nconst homeDir = typeof os.homedir === 'undefined' ? '' : os.homedir();\n\nmodule.exports = (stack, options) => {\n\toptions = Object.assign({pretty: false}, options);\n\n\treturn stack.replace(/\\\\/g, '/')\n\t\t.split('\\n')\n\t\t.filter(line => {\n\t\t\tconst pathMatches = line.match(extractPathRegex);\n\t\t\tif (pathMatches === null || !pathMatches[1]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst match = pathMatches[1];\n\n\t\t\t// Electron\n\t\t\tif (\n\t\t\t\tmatch.includes('.app/Contents/Resources/electron.asar') ||\n\t\t\t\tmatch.includes('.app/Contents/Resources/default_app.asar')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn !pathRegex.test(match);\n\t\t})\n\t\t.filter(line => line.trim() !== '')\n\t\t.map(line => {\n\t\t\tif (options.pretty) {\n\t\t\t\treturn line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')));\n\t\t\t}\n\n\t\t\treturn line;\n\t\t})\n\t\t.join('\\n');\n};\n","'use strict';\n\nmodule.exports = (string, count = 1, options) => {\n\toptions = {\n\t\tindent: ' ',\n\t\tincludeEmptyLines: false,\n\t\t...options\n\t};\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (typeof options.indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, options.indent.repeat(count));\n};\n","export function get(object, path, defValue) {\n    if (!path)\n        return defValue;\n    const pathArray = Array.isArray(path)\n        ? path\n        : path.match(/([^[.\\]])+/g);\n    const value = pathArray.reduce((previousObject, key) => previousObject && previousObject[key], object);\n    return typeof value === 'undefined' ? defValue : value;\n}\n//# sourceMappingURL=get.js.map","import { get } from './get';\nconst validateGroupCondition = (condition, data) => {\n    if (condition.operator === 'and') {\n        return condition.children.every((childCondition) => {\n            return validateCondition(childCondition, data);\n        });\n    }\n    if (condition.operator === 'or') {\n        return condition.children.some((childCondition) => {\n            return validateCondition(childCondition, data);\n        });\n    }\n    return false;\n};\nconst validate = (condition, data) => {\n    if (condition.error || typeof data === 'undefined') {\n        return false;\n    }\n    return validateGroupCondition(condition, data);\n};\nexport default validate;\nconst validateCondition = (condition, data) => {\n    if (condition.type === 'event-type') {\n        return validateValue(data.type, condition.operator, condition.value);\n    }\n    if (condition.type === 'event') {\n        return validateValue(data.event, condition.operator, condition.value);\n    }\n    if (condition.type === 'name') {\n        return validateValue(data.name, condition.operator, condition.value);\n    }\n    if (condition.type === 'userId') {\n        return validateValue(data.userId, condition.operator, condition.value);\n    }\n    if (condition.type === 'event-property') {\n        return validateValue(get(data.properties, condition.name), condition.operator, condition.value);\n    }\n    if (condition.type === 'event-trait') {\n        return validateValue(get(data.traits, condition.name), condition.operator, condition.value);\n    }\n    if (condition.type === 'event-context') {\n        return validateValue(get(data.context, condition.name), condition.operator, condition.value);\n    }\n    if (condition.type === 'group') {\n        return validateGroupCondition(condition, data);\n    }\n    return false;\n};\nconst validateValue = (actual, operator, expected) => {\n    switch (operator) {\n        case '=':\n            return String(actual) === String(expected);\n        case '!=':\n            return String(actual) !== String(expected);\n        case '<':\n            return Number(actual) < Number(expected);\n        case '<=':\n            return Number(actual) <= Number(expected);\n        case '>':\n            return Number(actual) > Number(expected);\n        case '>=':\n            return Number(actual) >= Number(expected);\n        case 'contains':\n            return typeof actual === 'string' && actual.includes(String(expected));\n        case 'not_contains':\n            return typeof actual === 'string' && !actual.includes(String(expected));\n        case 'starts_with':\n            return typeof actual === 'string' && actual.startsWith(String(expected));\n        case 'not_starts_with':\n            return typeof actual === 'string' && !actual.startsWith(String(expected));\n        case 'ends_with':\n            return typeof actual === 'string' && actual.endsWith(String(expected));\n        case 'not_ends_with':\n            return typeof actual === 'string' && !actual.endsWith(String(expected));\n        case 'exists':\n            return actual !== undefined && actual !== null;\n        case 'not_exists':\n            return actual === undefined || actual === null;\n        default:\n            return false;\n    }\n};\n//# sourceMappingURL=validate.js.map","import { lex, types as TokenType } from '@segment/fql-ts';\nconst tokenToConditionType = {\n    type: 'event-type',\n    event: 'event',\n    name: 'name',\n    userId: 'userId',\n    context: 'event-context',\n    properties: 'event-property',\n    traits: 'event-trait'\n};\nconst getTokenValue = (token) => {\n    if (token.type === 'string') {\n        return token.value.replace(/^\"/, '').replace(/\"$/, '');\n    }\n    if (token.type === 'number') {\n        return Number(token.value);\n    }\n    if (token.type === 'ident' && ['true', 'false'].includes(token.value)) {\n        return token.value === 'true';\n    }\n    return String(token.value);\n};\nconst isFqlFunction = (token) => {\n    return token.type === 'ident' && ['contains', 'match'].includes(token.value);\n};\nconst parseFqlFunction = (name, nodes, tokens, { negate } = { negate: false }) => {\n    if (name === 'contains') {\n        tokens.shift();\n        const nameToken = tokens.shift();\n        if (!nameToken) {\n            throw new Error('contains() is missing a 1st argument');\n        }\n        tokens.shift();\n        const valueToken = tokens.shift();\n        if (!valueToken) {\n            throw new Error('contains() is missing a 2nd argument');\n        }\n        tokens.shift();\n        if (['event', 'name', 'userId'].includes(nameToken.value)) {\n            nodes.push({\n                type: nameToken.value,\n                operator: negate ? 'not_contains' : 'contains',\n                value: String(getTokenValue(valueToken))\n            });\n        }\n        if (/^(properties)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-property',\n                name: nameToken.value.replace(/^(properties)\\./, ''),\n                operator: negate ? 'not_contains' : 'contains',\n                value: String(getTokenValue(valueToken))\n            });\n        }\n        if (/^(traits)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-trait',\n                name: nameToken.value.replace(/^(traits)\\./, ''),\n                operator: negate ? 'not_contains' : 'contains',\n                value: String(getTokenValue(valueToken))\n            });\n        }\n        if (/^(context)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-context',\n                name: nameToken.value.replace(/^(context)\\./, ''),\n                operator: negate ? 'not_contains' : 'contains',\n                value: String(getTokenValue(valueToken))\n            });\n        }\n    }\n    if (name === 'match') {\n        tokens.shift();\n        const nameToken = tokens.shift();\n        if (!nameToken) {\n            throw new Error('match() is missing a 1st argument');\n        }\n        tokens.shift();\n        const valueToken = tokens.shift();\n        if (!valueToken) {\n            throw new Error('match() is missing a 2nd argument');\n        }\n        tokens.shift();\n        let operator;\n        let value;\n        if (valueToken.value.endsWith('*\"')) {\n            operator = negate ? 'not_starts_with' : 'starts_with';\n            value = String(getTokenValue(valueToken)).slice(0, -1);\n        }\n        else {\n            operator = negate ? 'not_ends_with' : 'ends_with';\n            value = String(getTokenValue(valueToken)).slice(1);\n        }\n        if (['event', 'name', 'userId'].includes(nameToken.value)) {\n            nodes.push({\n                type: nameToken.value,\n                operator,\n                value\n            });\n        }\n        if (/^(properties)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-property',\n                name: nameToken.value.replace(/^(properties)\\./, ''),\n                operator,\n                value\n            });\n        }\n        if (/^(traits)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-trait',\n                name: nameToken.value.replace(/^(traits)\\./, ''),\n                operator,\n                value\n            });\n        }\n        if (/^(context)/.test(nameToken.value)) {\n            nodes.push({\n                type: 'event-context',\n                name: nameToken.value.replace(/^(context)\\./, ''),\n                operator,\n                value\n            });\n        }\n    }\n};\nconst parse = (tokens) => {\n    var _a;\n    const nodes = [];\n    let operator = 'and';\n    let token = tokens.shift();\n    while (token && token.type !== 'eos') {\n        if (token.type === 'ident') {\n            const [tokenStart] = ((_a = token.value) !== null && _a !== void 0 ? _a : '').split('.');\n            const conditionType = tokenToConditionType[tokenStart];\n            if (conditionType) {\n                const operatorToken = tokens.shift();\n                if (!operatorToken) {\n                    throw new Error('Operator token is missing');\n                }\n                const valueToken = tokens.shift();\n                if (!valueToken) {\n                    throw new Error('Value token is missing');\n                }\n                const isExists = operatorToken.value === '!=' && valueToken.value === 'null';\n                const isNotExists = operatorToken.value === '=' && valueToken.value === 'null';\n                if (conditionType === 'event') {\n                    nodes.push({\n                        type: 'event',\n                        operator: operatorToken.value,\n                        value: String(getTokenValue(valueToken))\n                    });\n                }\n                else if (conditionType === 'event-type') {\n                    nodes.push({\n                        type: 'event-type',\n                        operator: operatorToken.value,\n                        value: String(getTokenValue(valueToken))\n                    });\n                }\n                else if (conditionType === 'name') {\n                    nodes.push({\n                        type: 'name',\n                        operator: operatorToken.value,\n                        value: String(getTokenValue(valueToken))\n                    });\n                }\n                else if (conditionType === 'userId') {\n                    if (isExists) {\n                        nodes.push({\n                            type: 'userId',\n                            operator: 'exists'\n                        });\n                    }\n                    else if (isNotExists) {\n                        nodes.push({\n                            type: 'userId',\n                            operator: 'not_exists'\n                        });\n                    }\n                    else {\n                        nodes.push({\n                            type: 'userId',\n                            operator: operatorToken.value,\n                            value: String(getTokenValue(valueToken))\n                        });\n                    }\n                }\n                else if (conditionType === 'event-property') {\n                    if (isExists) {\n                        nodes.push({\n                            type: 'event-property',\n                            name: token.value.replace(/^(properties)\\./, ''),\n                            operator: 'exists'\n                        });\n                    }\n                    else if (isNotExists) {\n                        nodes.push({\n                            type: 'event-property',\n                            name: token.value.replace(/^(properties)\\./, ''),\n                            operator: 'not_exists'\n                        });\n                    }\n                    else {\n                        nodes.push({\n                            type: 'event-property',\n                            name: token.value.replace(/^(properties)\\./, ''),\n                            operator: operatorToken.value,\n                            value: getTokenValue(valueToken)\n                        });\n                    }\n                }\n                else if (conditionType === 'event-trait') {\n                    if (isExists) {\n                        nodes.push({\n                            type: 'event-trait',\n                            name: token.value.replace(/^(traits)\\./, ''),\n                            operator: 'exists'\n                        });\n                    }\n                    else if (isNotExists) {\n                        nodes.push({\n                            type: 'event-trait',\n                            name: token.value.replace(/^(traits)\\./, ''),\n                            operator: 'not_exists'\n                        });\n                    }\n                    else {\n                        nodes.push({\n                            type: 'event-trait',\n                            name: token.value.replace(/^(traits)\\./, ''),\n                            operator: operatorToken.value,\n                            value: getTokenValue(valueToken)\n                        });\n                    }\n                }\n                else if (conditionType === 'event-context') {\n                    if (isExists) {\n                        nodes.push({\n                            type: 'event-context',\n                            name: token.value.replace(/^(context)\\./, ''),\n                            operator: 'exists'\n                        });\n                    }\n                    else if (isNotExists) {\n                        nodes.push({\n                            type: 'event-context',\n                            name: token.value.replace(/^(context)\\./, ''),\n                            operator: 'not_exists'\n                        });\n                    }\n                    else {\n                        nodes.push({\n                            type: 'event-context',\n                            name: token.value.replace(/^(context)\\./, ''),\n                            operator: operatorToken.value,\n                            value: getTokenValue(valueToken)\n                        });\n                    }\n                }\n            }\n            if (isFqlFunction(token)) {\n                parseFqlFunction(token.value, nodes, tokens);\n            }\n        }\n        if (token.type === 'operator' && token.value === '!') {\n            if (isFqlFunction(tokens[0])) {\n                const name = tokens[0].value;\n                tokens.shift();\n                parseFqlFunction(name, nodes, tokens, { negate: true });\n            }\n        }\n        if (token.type === 'parenleft') {\n            const groupTokens = [];\n            let groupToken = tokens.shift();\n            while (groupToken.type !== 'parenright') {\n                groupTokens.push(groupToken);\n                groupToken = tokens.shift();\n            }\n            groupTokens.push({ type: TokenType.EOS, value: 'eos' });\n            nodes.push(parse(groupTokens));\n        }\n        if (token.type === 'conditional') {\n            operator = token.value;\n        }\n        token = tokens.shift();\n    }\n    if (nodes.length > 1) {\n        return {\n            type: 'group',\n            operator: operator,\n            children: nodes\n        };\n    }\n    return nodes[0];\n};\nconst normalize = (tokens) => {\n    const normalizedTokens = [];\n    let index = 0;\n    while (tokens[index]) {\n        const last = normalizedTokens[normalizedTokens.length - 1];\n        const current = tokens[index];\n        const next = tokens[index + 1];\n        if ((last === null || last === void 0 ? void 0 : last.type) === 'ident' &&\n            current.type === 'dot' &&\n            (next === null || next === void 0 ? void 0 : next.type) === 'ident') {\n            const previous = normalizedTokens.pop();\n            normalizedTokens.push({\n                type: TokenType.Ident,\n                value: `${previous === null || previous === void 0 ? void 0 : previous.value}${current.value}${next.value}`\n            });\n            index += 2;\n        }\n        else {\n            normalizedTokens.push(tokens[index]);\n            index++;\n        }\n    }\n    return normalizedTokens;\n};\nconst parseFql = (fql) => {\n    try {\n        const ast = parse(normalize(lex(fql).tokens));\n        if (ast.type !== 'group') {\n            return {\n                type: 'group',\n                operator: 'and',\n                children: [ast]\n            };\n        }\n        return ast;\n    }\n    catch (error) {\n        const err = error instanceof Error ? error : new Error(`Error while parsing ${fql}`);\n        return {\n            error: err\n        };\n    }\n};\nexport default parseFql;\n//# sourceMappingURL=parse-fql.js.map","export async function loadScript(src: string, attributes?: Record<string, string>): Promise<HTMLScriptElement> {\n  const scripts = Array.from(window.document.querySelectorAll('script'))\n  const found = scripts.find((s) => s.src === src)\n\n  if (found !== undefined) {\n    const status = found?.getAttribute('status')\n\n    if (status === 'loaded') {\n      return found\n    }\n\n    if (status === 'loading') {\n      return new Promise((resolve, reject) => {\n        found.addEventListener('load', () => resolve(found))\n        found.addEventListener('error', (err) => reject(err))\n      })\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    const script = window.document.createElement('script')\n\n    script.type = 'text/javascript'\n    script.src = src\n    script.async = true\n\n    script.setAttribute('status', 'loading')\n    for (const [k, v] of Object.entries(attributes ?? {})) {\n      script.setAttribute(k, v)\n    }\n\n    script.onload = (): void => {\n      script.onerror = script.onload = null\n      script.setAttribute('status', 'loaded')\n      resolve(script)\n    }\n\n    script.onerror = (): void => {\n      script.onerror = script.onload = null\n      script.setAttribute('status', 'error')\n      reject(new Error(`Failed to load ${src}`))\n    }\n\n    const tag = window.document.getElementsByTagName('script')[0]\n    tag.parentElement?.insertBefore(script, tag)\n  })\n}\n","export async function resolveWhen(condition: () => boolean, timeout?: number): Promise<void> {\n  return new Promise((resolve, _reject) => {\n    if (condition()) {\n      resolve()\n      return\n    }\n\n    const check = () =>\n      setTimeout(() => {\n        if (condition()) {\n          resolve()\n        } else {\n          check()\n        }\n      }, timeout)\n\n    check()\n  })\n}\n","import type { Analytics, Context, Plugin } from '@segment/analytics-next'\nimport type { JSONObject } from '@segment/actions-core'\nimport { transform } from '@segment/actions-core/mapping-kit'\nimport { parseFql, validate } from '@segment/destination-subscriptions'\nimport { ActionInput, BrowserDestinationDefinition, Subscription } from '../lib/browser-destinations'\nimport { loadScript } from './load-script'\nimport { resolveWhen } from './resolve-when'\n\ntype MaybePromise<T> = T | Promise<T>\n\nexport function generatePlugins<S, C>(\n  def: BrowserDestinationDefinition<S, C>,\n  settings: S,\n  subscriptions: Subscription[]\n): Plugin[] {\n  let hasInitialized = false\n  let client: C\n  let analytics: Analytics\n\n  const load: Plugin['load'] = async (_ctx, analyticsInstance) => {\n    if (hasInitialized) {\n      return\n    }\n\n    analytics = analyticsInstance\n    client = await def.initialize?.({ settings, analytics }, { loadScript, resolveWhen })\n    hasInitialized = true\n  }\n\n  return Object.entries(def.actions).reduce((acc, [key, action]) => {\n    // Grab all the enabled subscriptions that invoke this action\n    const actionSubscriptions = subscriptions.filter((s) => s.enabled && s.partnerAction === key)\n    if (actionSubscriptions.length === 0) return acc\n\n    async function evaluate(ctx: Context): Promise<Context> {\n      const invocations: Array<MaybePromise<unknown>> = []\n\n      for (const sub of actionSubscriptions) {\n        const isSubscribed = validate(parseFql(sub.subscribe), ctx.event)\n        if (!isSubscribed) continue\n\n        const mapping = (sub.mapping ?? {}) as JSONObject\n        const payload = transform(mapping, ctx.event as unknown as JSONObject)\n\n        const input: ActionInput<S, unknown> = {\n          payload,\n          mapping,\n          settings,\n          analytics,\n          context: ctx\n        }\n\n        invocations.push(action.perform(client, input))\n      }\n\n      await Promise.all(invocations)\n      // TODO: some sort of error handling\n      return ctx\n    }\n\n    const plugin = {\n      name: `${def.name} ${key}`,\n      type: action.lifecycleHook ?? 'destination',\n      version: '0.1.0',\n      ready: () => Promise.resolve(),\n\n      isLoaded: () => hasInitialized,\n      load,\n\n      track: evaluate,\n      page: evaluate,\n      alias: evaluate,\n      identify: evaluate,\n      group: evaluate\n    }\n\n    acc.push(plugin)\n    return acc\n  }, [] as Plugin[])\n}\n","export function get(obj, path) {\n    if (path === '' || path === '.')\n        return obj;\n    if (path === null || path == undefined)\n        return undefined;\n    const pathArray = Array.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], obj);\n}\n//# sourceMappingURL=get.js.map","import { isObject } from '../real-type-of';\nexport function isDirective(obj) {\n    if (!isObject(obj)) {\n        return false;\n    }\n    const keys = Object.keys(obj);\n    const hasDirectivePrefix = keys.some((key) => key.startsWith('@'));\n    if (!hasDirectivePrefix) {\n        return false;\n    }\n    const otherKeys = keys.filter((key) => !key.startsWith('@') && key !== '_metadata');\n    if (otherKeys.length === 0) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=is-directive.js.map","import { get } from '../get';\nimport { realTypeOf } from '../real-type-of';\nconst entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n};\nfunction escapeHtml(value) {\n    if (typeof value !== 'string')\n        return value;\n    return value.replace(/[&<>\"'`=/]/g, (match) => {\n        return entityMap[match];\n    });\n}\nexport function render(template, data = {}) {\n    if (typeof template !== 'string') {\n        throw new TypeError(`Invalid template! Template should be a \"string\" but ${realTypeOf(template)} was given.`);\n    }\n    function replacer(chars, escape) {\n        return (match) => {\n            match = match.slice(chars, -chars).trim();\n            const value = get(data, match);\n            if (escape) {\n                return String(escapeHtml(value) ?? '');\n            }\n            return (value ?? '');\n        };\n    }\n    return (template\n        .replace(/\\{\\{\\{([^}]+)\\}\\}\\}/g, replacer(3, false))\n        .replace(/\\{\\{([^}]+)\\}\\}/g, replacer(2, true)));\n}\n//# sourceMappingURL=placeholders.js.map","import { isObject } from './real-type-of';\nexport function removeUndefined(value) {\n    if (Array.isArray(value)) {\n        return value.map((item) => removeUndefined(item));\n    }\n    else if (isObject(value)) {\n        const cleaned = Object.assign({}, value);\n        Object.keys(cleaned).forEach((key) => {\n            if (cleaned[key] === undefined) {\n                delete cleaned[key];\n            }\n            else {\n                cleaned[key] = removeUndefined(cleaned[key]);\n            }\n        });\n        return cleaned;\n    }\n    return value;\n}\n//# sourceMappingURL=remove-undefined.js.map","import AggregateError from 'aggregate-error';\nimport { CustomError } from 'ts-custom-error';\nimport { isDirective } from './is-directive';\nimport { isObject, realTypeOf } from '../real-type-of';\nclass ValidationError extends CustomError {\n    constructor(message, stack = []) {\n        super(`/${stack.join('/')} ${message}.`);\n    }\n}\nfunction flatAggregate(errors) {\n    const result = [];\n    errors.forEach((error) => {\n        if (error instanceof AggregateError) {\n            result.push(...error);\n        }\n        else {\n            result.push(error);\n        }\n    });\n    return result;\n}\nfunction realTypeOrDirective(value) {\n    const type = realTypeOf(value);\n    if (type === 'object' && Object.keys(value).some((k) => k.startsWith('@'))) {\n        return 'directive';\n    }\n    return type;\n}\nconst directives = {};\nfunction validateDirective(obj, stack = []) {\n    if (!isDirective(obj) && !isObject(obj)) {\n        const type = realTypeOf(obj);\n        throw new ValidationError(`should be a directive object but it is ${indefiniteArticle(type)} ${type}`, stack);\n    }\n    const keys = Object.keys(obj);\n    const directiveKeys = keys.filter((key) => key.startsWith('@'));\n    if (directiveKeys.length > 1) {\n        throw new ValidationError(`should only have one @-prefixed key but it has ${directiveKeys.length} keys`, stack);\n    }\n    const otherKeys = keys.filter((key) => !key.startsWith('@') && key !== '_metadata');\n    if (otherKeys.length > 0) {\n        throw new ValidationError(`should only have one @-prefixed key but it has ${keys.length} keys`, stack);\n    }\n    const directiveKey = directiveKeys[0];\n    const fn = directives[directiveKey];\n    if (typeof fn !== 'function') {\n        throw new ValidationError(`has an invalid directive: ${directiveKey}`, stack);\n    }\n    fn(obj[directiveKey], stack);\n}\nfunction validateDirectiveOrRaw(v, stack = []) {\n    const type = realTypeOrDirective(v);\n    switch (type) {\n        case 'directive':\n            return validateDirective(v, stack);\n        case 'object':\n        case 'array':\n        case 'boolean':\n        case 'string':\n        case 'number':\n        case 'null':\n            return;\n        default:\n            throw new ValidationError(`should be a mapping directive or a JSON value but it is ${indefiniteArticle(type)} ${type}`, stack);\n    }\n}\nfunction validateDirectiveOrString(v, stack = []) {\n    const type = realTypeOrDirective(v);\n    switch (type) {\n        case 'directive':\n            return validateDirective(v, stack);\n        case 'string':\n            return;\n        default:\n            throw new ValidationError(`should be a string or a mapping directive but it is ${indefiniteArticle(type)} ${type}`, stack);\n    }\n}\nfunction validateObject(value, stack = []) {\n    const type = realTypeOrDirective(value);\n    if (type !== 'object') {\n        throw new ValidationError(`should be an object but it is ${indefiniteArticle(type)} ${type}`, stack);\n    }\n    const obj = value;\n    const keys = Object.keys(obj);\n    const directiveKey = keys.find((k) => k.charAt(0) === '@');\n    if (directiveKey) {\n        throw new ValidationError(`shouldn't have directive (@-prefixed) keys but it has ${JSON.stringify(directiveKey)}`, stack);\n    }\n    const errors = [];\n    keys.forEach((k) => {\n        try {\n            validate(obj[k], [...stack, k]);\n        }\n        catch (e) {\n            errors.push(e);\n        }\n    });\n    if (errors.length) {\n        throw new AggregateError(flatAggregate(errors));\n    }\n}\nfunction validateObjectWithFields(input, fields, stack = []) {\n    validateObject(input, stack);\n    const errors = [];\n    const obj = input;\n    Object.entries(fields).forEach(([prop, { required, optional }]) => {\n        try {\n            if (required) {\n                if (obj[prop] === undefined) {\n                    throw new ValidationError(`should have field ${JSON.stringify(prop)} but it doesn't`, stack);\n                }\n                required(obj[prop], [...stack, prop]);\n            }\n            else if (optional) {\n                if (obj[prop] !== undefined) {\n                    optional(obj[prop], [...stack, prop]);\n                }\n            }\n        }\n        catch (error) {\n            errors.push(error);\n        }\n    });\n    if (errors.length) {\n        throw new AggregateError(flatAggregate(errors));\n    }\n}\nfunction validateArray(arr, stack = []) {\n    const type = realTypeOf(arr);\n    if (type !== 'array') {\n        throw new ValidationError(`should be an array but it is ${indefiniteArticle(type)} ${type}`, stack);\n    }\n}\nfunction directive(names, fn) {\n    if (!Array.isArray(names)) {\n        names = [names];\n    }\n    names.forEach((name) => {\n        directives[name] = (v, stack = []) => {\n            try {\n                fn(v, [...stack, name]);\n            }\n            catch (e) {\n                if (e instanceof ValidationError || e instanceof AggregateError) {\n                    throw e;\n                }\n                throw new ValidationError(e.message, stack);\n            }\n        };\n    });\n}\ndirective('@if', (v, stack) => {\n    validateObjectWithFields(v, {\n        exists: { optional: validateDirectiveOrRaw },\n        then: { optional: validateDirectiveOrRaw },\n        else: { optional: validateDirectiveOrRaw }\n    }, stack);\n});\ndirective('@arrayPath', (v, stack) => {\n    const data = v;\n    validateArray(data, stack);\n    validateDirectiveOrString(data[0], stack);\n    validate(data[1], stack);\n});\ndirective('@path', (v, stack) => {\n    validateDirectiveOrString(v, stack);\n});\ndirective('@template', (v, stack) => {\n    validateDirectiveOrString(v, stack);\n});\ndirective('@literal', (v, stack) => {\n    validateDirectiveOrRaw(v, stack);\n});\nfunction indefiniteArticle(s) {\n    switch (s.charAt(0)) {\n        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n            return 'an';\n        default:\n            return 'a';\n    }\n}\nexport default function validate(mapping, stack = []) {\n    switch (realTypeOrDirective(mapping)) {\n        case 'directive':\n            return validateDirective(mapping, stack);\n        case 'object':\n            return validateObject(mapping, stack);\n        case 'array':\n            return validateArray(mapping, stack);\n        default:\n            return null;\n    }\n}\n//# sourceMappingURL=validate.js.map","import { isArray, isObject } from './real-type-of';\nexport function arrify(value, treatNullAsEmpty = true) {\n    if (value === undefined || value === null)\n        return treatNullAsEmpty ? [] : value;\n    if (isArray(value))\n        return value;\n    return [value];\n}\nexport function arrifyFields(obj, schema = {}) {\n    if (!isObject(obj)) {\n        return obj;\n    }\n    if (!schema.properties)\n        return obj;\n    for (const key of Object.keys(obj)) {\n        const fieldSchema = schema.properties[key];\n        if (!fieldSchema)\n            continue;\n        if (fieldSchema.type === 'array') {\n            obj[key] = arrify(obj[key], false);\n        }\n    }\n    return obj;\n}\n//# sourceMappingURL=arrify.js.map","import { get } from '../get';\nimport { isDirective } from './is-directive';\nimport { render } from './placeholders';\nimport { realTypeOf, isObject, isArray } from '../real-type-of';\nimport { removeUndefined } from '../remove-undefined';\nimport validate from './validate';\nimport { arrify } from '../arrify';\nconst directives = {};\nconst directiveRegExp = /^@[a-z][a-zA-Z0-9]+$/;\nfunction registerDirective(name, fn) {\n    if (!directiveRegExp.exec(name)) {\n        throw new Error(`\"${name}\" is an invalid directive name`);\n    }\n    directives[name] = fn;\n}\nfunction registerStringDirective(name, fn) {\n    registerDirective(name, (value, payload) => {\n        const str = resolve(value, payload);\n        if (typeof str !== 'string') {\n            throw new Error(`${name}: expected string, got ${realTypeOf(str)}`);\n        }\n        return fn(str, payload);\n    });\n}\nfunction runDirective(obj, payload) {\n    const name = Object.keys(obj).find((key) => key.startsWith('@'));\n    const directiveFn = directives[name];\n    const value = obj[name];\n    if (typeof directiveFn !== 'function') {\n        throw new Error(`${name} is not a valid directive, got ${realTypeOf(directiveFn)}`);\n    }\n    return directiveFn(value, payload);\n}\nregisterDirective('@if', (opts, payload) => {\n    let condition = false;\n    if (!isObject(opts)) {\n        throw new Error('@if requires an object with an \"exists\" key');\n    }\n    if (opts.exists !== undefined) {\n        const value = resolve(opts.exists, payload);\n        condition = value !== undefined && value !== null;\n    }\n    else {\n        throw new Error('@if requires an \"exists\" key');\n    }\n    if (condition && opts.then !== undefined) {\n        return resolve(opts.then, payload);\n    }\n    else if (!condition && opts.else) {\n        return resolve(opts.else, payload);\n    }\n});\nregisterDirective('@arrayPath', (data, payload) => {\n    if (!Array.isArray(data)) {\n        throw new Error(`@arrayPath expected array, got ${realTypeOf(data)}`);\n    }\n    const [path, itemShape] = data;\n    const root = typeof path === 'string' ? get(payload, path.replace('$.', '')) : resolve(path, payload);\n    if (['object', 'array'].includes(realTypeOf(root)) &&\n        realTypeOf(itemShape) === 'object' &&\n        Object.keys(itemShape).length > 0) {\n        return arrify(root).map((item) => resolve(itemShape, item));\n    }\n    return root;\n});\nregisterStringDirective('@path', (path, payload) => {\n    return get(payload, path.replace('$.', ''));\n});\nregisterStringDirective('@template', (template, payload) => {\n    return render(template, payload);\n});\nregisterDirective('@literal', (value, payload) => {\n    return resolve(value, payload);\n});\nfunction resolve(mapping, payload) {\n    if (!isObject(mapping) && !isArray(mapping)) {\n        return mapping;\n    }\n    if (isDirective(mapping)) {\n        return runDirective(mapping, payload);\n    }\n    if (Array.isArray(mapping)) {\n        return mapping.map((value) => resolve(value, payload));\n    }\n    const resolved = {};\n    for (const key of Object.keys(mapping)) {\n        resolved[key] = resolve(mapping[key], payload);\n    }\n    return resolved;\n}\nexport function transform(mapping, data = {}) {\n    const realType = realTypeOf(data);\n    if (realType !== 'object') {\n        throw new Error(`data must be an object, got ${realType}`);\n    }\n    validate(mapping);\n    const resolved = resolve(mapping, data);\n    const cleaned = removeUndefined(resolved);\n    return cleaned;\n}\nexport function transformBatch(mapping, data = []) {\n    const realType = realTypeOf(data);\n    if (!isArray(data)) {\n        throw new Error(`data must be an array, got ${realType}`);\n    }\n    validate(mapping);\n    const resolved = data.map((d) => resolve(mapping, d));\n    return removeUndefined(resolved);\n}\n//# sourceMappingURL=index.js.map","export function realTypeOf(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n}\nexport function isObject(value) {\n    return realTypeOf(value) === 'object';\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\nexport function isString(value) {\n    return typeof value === 'string';\n}\n//# sourceMappingURL=real-type-of.js.map","function fixProto(target, prototype) {\n  var setPrototypeOf = Object.setPrototypeOf;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nfunction fixStack(target, fn) {\n  if (fn === void 0) {\n    fn = target.constructor;\n  }\n\n  var captureStackTrace = Error.captureStackTrace;\n  captureStackTrace && captureStackTrace(target, fn);\n}\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar CustomError = function (_super) {\n  __extends(CustomError, _super);\n\n  function CustomError(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.defineProperty(_this, 'name', {\n      value: _newTarget.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(_this, _newTarget.prototype);\n    fixStack(_this);\n    return _this;\n  }\n\n  return CustomError;\n}(Error);\n\nvar __spreadArrays = undefined && undefined.__spreadArrays || function () {\n  var arguments$1 = arguments;\n\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) { s += arguments$1[i].length; }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) { for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) { r[k] = a[j]; } }\n\n  return r;\n};\nfunction customErrorFactory(fn, parent) {\n  if (parent === void 0) {\n    parent = Error;\n  }\n\n  function CustomError() {\n    var arguments$1 = arguments;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n\n    if (!(this instanceof CustomError)) { return new (CustomError.bind.apply(CustomError, __spreadArrays([void 0], args)))(); }\n    parent.apply(this, args);\n    Object.defineProperty(this, 'name', {\n      value: fn.name || parent.name,\n      enumerable: false,\n      configurable: true\n    });\n    fn.apply(this, args);\n    fixStack(this, CustomError);\n  }\n\n  return Object.defineProperties(CustomError, {\n    prototype: {\n      value: Object.create(parent.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  });\n}\n\nexport { CustomError, customErrorFactory };\n//# sourceMappingURL=custom-error.mjs.map\n"],"names":["EOS_FLAG","Reader","constructor","code","this","position","forward","length","char","isEOS","charAt","backward","RangeError","getPosition","LexerError","Error","message","cursor","super","name","stack","lex","tokens","Lexer","error","reader","line","column","next","push","t","nextChar","peek","lexOperatorOrConditional","lexNumber","lexString","openQuote","str","accept","previous","comingUp","isDecimal","lexIdent","chars","_","backup","count","n","err","isNewLine","c","isWhitespace","isAlpha","match","isNumber","isNaN","parseFloat","isFinite","parseInt","isIdent","isTerminator","isToken","arg","undefined","type","value","TokenType","Err","Ident","Dot","Operator","Conditional","String","Number","Null","BrackLeft","BrackRight","ParenLeft","ParenRight","Comma","EOS","indentString","cleanStack","AggregateError","errors","Array","isArray","TypeError","map","Object","assign","replace","join","defineProperty","Symbol","iterator","_errors","module","exports","os","extractPathRegex","pathRegex","homeDir","homedir","options","pretty","split","filter","pathMatches","includes","test","trim","m","p1","string","indent","includeEmptyLines","regex","repeat","get","object","path","defValue","reduce","previousObject","key","validateGroupCondition","condition","data","operator","children","every","childCondition","validateCondition","some","validateValue","event","userId","properties","traits","context","actual","expected","startsWith","endsWith","tokenToConditionType","getTokenValue","token","isFqlFunction","parseFqlFunction","nodes","negate","shift","nameToken","valueToken","slice","parse","_a","tokenStart","conditionType","operatorToken","isExists","isNotExists","groupTokens","groupToken","fql","ast","normalizedTokens","index","last","current","pop","normalize","async","loadScript","src","attributes","found","from","window","document","querySelectorAll","find","s","status","getAttribute","Promise","resolve","reject","addEventListener","script","createElement","setAttribute","k","v","entries","onload","onerror","tag","getElementsByTagName","parentElement","insertBefore","resolveWhen","timeout","_reject","check","setTimeout","generatePlugins","def","settings","subscriptions","client","analytics","hasInitialized","load","_ctx","analyticsInstance","initialize","actions","acc","action","actionSubscriptions","enabled","partnerAction","evaluate","ctx","invocations","sub","subscribe","mapping","input","payload","perform","all","plugin","lifecycleHook","version","ready","isLoaded","track","page","alias","identify","group","obj","prevObj","isDirective","keys","entityMap","render","template","replacer","escape","escapeHtml","item","cleaned","forEach","ValidationError","CustomError","flatAggregate","result","realTypeOrDirective","directives","validateDirective","indefiniteArticle","directiveKeys","directiveKey","fn","validateDirectiveOrRaw","validateDirectiveOrString","validateObject","JSON","stringify","e","validateArray","arr","directive","names","arrify","treatNullAsEmpty","fields","prop","required","optional","validateObjectWithFields","exists","then","else","directiveRegExp","registerDirective","exec","registerStringDirective","directiveFn","runDirective","resolved","transform","realType","opts","itemShape","root","realTypeOf","prototype","toString","call","toLowerCase","isObject","fixStack","target","captureStackTrace","extendStatics","__extends","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","__","create","_super","_newTarget","_this","enumerable","configurable","__spreadArrays","arguments$1","arguments","i","il","r","a","j","jl","customErrorFactory","parent","args","_i","bind","apply","defineProperties","writable"],"sourceRoot":""}