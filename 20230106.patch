diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 27326090..f8f4c8af 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -4,7 +4,6 @@ on:
   push:
     branches:
       - main
-      - staging
   pull_request:
 
 jobs:
@@ -112,30 +111,3 @@ jobs:
           SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
         with:
           args: --severity-threshold=high --fail-on=upgradable --all-projects --policy-path=.snyk
-
-  yarn-alpha:
-    if: contains(github.base_ref, 'staging')
-
-    runs-on: ubuntu-latest
-
-    needs: test-and-build
-
-    timeout-minutes: 3
-
-    strategy:
-      matrix:
-        node-version: [14.x]
-
-    steps:
-      - uses: actions/checkout@v2
-        with:
-          persist-credentials: false
-
-      - name: Use Node.js ${{ matrix.node-version }}
-        uses: actions/setup-node@v2
-        with:
-          node-version: ${{ matrix.node-version }}
-          registry-url: 'https://registry.npmjs.org'
-
-      - name: Yarn alpha
-        run: yarn alpha --yes
diff --git a/README.md b/README.md
index c9802865..1969adce 100644
--- a/README.md
+++ b/README.md
@@ -30,6 +30,7 @@ For more detailed instruction, see the following READMEs:
 - [perform function](#the-perform-function)
 - [Batching Requests](#batching-requests)
 - [HTTP Requests](#http-requests)
+- [Support](#support)
 
 ## Get started
 
@@ -396,6 +397,7 @@ The `perform` method accepts two arguments, (1) the request client instance (ext
 - `statsContext` - An object, containing a `statsClient` and `tags`. Stats can only be used by internal Twilio/Segment employees. Stats cannot be used for Partner builds.
 - `logger` - Logger can only be used by internal Twilio/Segment employees. Logger cannot be used for Partner builds.
 - `transactionContext` - An object, containing transaction variables and a method to update transaction variables which are required for few segment developed actions. Transaction Context cannot be used for Partner builds.
+- `stateContext` - An object, containing context variables and a method to get and set context variables which are required for few segment developed actions. State Context cannot be used for Partner builds.
 
 A basic example:
 
@@ -543,6 +545,10 @@ There are a few subtle differences from the Fetch API which are meant to limit t
 - some options and behaviors are not applicable to Node.js and will be ignored by `node-fetch`. See this list of [known differences](https://github.com/node-fetch/node-fetch/blob/1780f5ae89107ded4f232f43219ab0e548b0647c/docs/v2-LIMITS.md).
 - `method` will automatically get upcased for consistency.
 
+## Support
+
+For any issues, please contact our support team at partner-support@segment.com.
+
 ## License
 
 MIT License
diff --git a/packages/actions-shared/package.json b/packages/actions-shared/package.json
index 2af0a572..ebc4d08c 100644
--- a/packages/actions-shared/package.json
+++ b/packages/actions-shared/package.json
@@ -1,7 +1,7 @@
 {
   "name": "@segment/actions-shared",
   "description": "Shared destination action methods and definitions.",
-  "version": "1.27.0",
+  "version": "1.29.0",
   "repository": {
     "type": "git",
     "url": "https://github.com/segmentio/action-destinations",
@@ -37,7 +37,7 @@
   },
   "dependencies": {
     "@amplitude/ua-parser-js": "^0.7.25",
-    "@segment/actions-core": "^3.45.0",
+    "@segment/actions-core": "^3.47.0",
     "cheerio": "^1.0.0-rc.10",
     "dayjs": "^1.10.7",
     "escape-goat": "^3",
diff --git a/packages/browser-destinations/package.json b/packages/browser-destinations/package.json
index f5fec08f..02f88a1a 100644
--- a/packages/browser-destinations/package.json
+++ b/packages/browser-destinations/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@segment/browser-destinations",
-  "version": "3.66.0",
+  "version": "3.69.0",
   "description": "Action based browser destinations",
   "author": "Netto Farah",
   "license": "MIT",
@@ -34,9 +34,9 @@
     "@braze/web-sdk": "npm:@braze/web-sdk@^4.1.0",
     "@braze/web-sdk-v3": "npm:@braze/web-sdk@^3.5.1",
     "@fullstory/browser": "^1.4.9",
-    "@segment/actions-shared": "^1.27.0",
+    "@segment/actions-shared": "^1.29.0",
     "@segment/analytics-next": "^1.29.3",
-    "@segment/destination-subscriptions": "^3.12.0",
+    "@segment/destination-subscriptions": "^3.13.0",
     "dayjs": "^1.10.7",
     "logrocket": "^3.0.1",
     "tslib": "^2.3.1",
@@ -48,7 +48,7 @@
     "@babel/plugin-transform-modules-commonjs": "^7.13.8",
     "@babel/preset-env": "^7.13.10",
     "@babel/preset-typescript": "^7.13.0",
-    "@segment/actions-core": "^3.45.0",
+    "@segment/actions-core": "^3.47.0",
     "@types/amplitude-js": "^7.0.1",
     "@types/jest": "^27.0.0",
     "babel-jest": "^27.3.1",
diff --git a/packages/browser-destinations/src/destinations/hubspot-web/__tests__/index.test.ts b/packages/browser-destinations/src/destinations/hubspot-web/__tests__/index.test.ts
index b6f89890..9a7138ea 100644
--- a/packages/browser-destinations/src/destinations/hubspot-web/__tests__/index.test.ts
+++ b/packages/browser-destinations/src/destinations/hubspot-web/__tests__/index.test.ts
@@ -1,6 +1,7 @@
 import { Subscription } from '../../../lib/browser-destinations'
 import { Analytics, Context } from '@segment/analytics-next'
 import hubspotDestination, { destination } from '../index'
+import nock from 'nock'
 
 const subscriptions: Subscription[] = [
   {
@@ -17,6 +18,11 @@ const subscriptions: Subscription[] = [
 ]
 
 describe('Hubspot Web (Actions)', () => {
+  beforeEach(() => {
+    nock('https://js.hs-scripts.com/').get('/12345.js').reply(200, "window._hsq = '🇺🇸'")
+    nock('https://js-eu1.hs-scripts.com/').get('/12345.js').reply(200, "window._hsq = '🇪🇺'")
+    nock('https://https://js.hsforms.net').get('forms/v2.js').reply(200, "window.hbspt = {forms: '1232'}")
+  })
   test('loads hubspot analytics with just a HubID', async () => {
     const [event] = await hubspotDestination({
       portalId: '12345',
@@ -27,15 +33,8 @@ describe('Hubspot Web (Actions)', () => {
 
     await event.load(Context.system(), {} as Analytics)
     expect(destination.initialize).toHaveBeenCalled()
-
-    const hsScript = window.document.querySelector('#hs-analytics') as HTMLScriptElement
-    const hsForms = window.document.querySelector(
-      'script[src~="https://js.hsforms.net/forms/v2.js"]'
-    ) as HTMLScriptElement
-
-    expect(hsScript).toBeDefined()
-    expect(hsForms).toBeNull()
-    expect(hsScript?.src).toContain('https://js.hs-analytics.net/analytics')
+    expect(window._hsq).toEqual('🇺🇸')
+    expect(window.hbspt).toBeUndefined()
   })
 
   test('loads hubspot analytics with EU script', async () => {
@@ -50,10 +49,8 @@ describe('Hubspot Web (Actions)', () => {
     await event.load(Context.system(), {} as Analytics)
     expect(destination.initialize).toHaveBeenCalled()
 
-    const hsScript = window.document.querySelector('#hs-analytics') as HTMLScriptElement
-
-    expect(hsScript).toBeDefined()
-    expect(hsScript?.src).toContain('https://js-eu1.hs-analytics.net')
+    expect(window._hsq).toEqual('🇪🇺')
+    expect(window.hbspt).toBeUndefined()
   })
 
   test('loads hubspot forms SDK', async () => {
@@ -62,18 +59,12 @@ describe('Hubspot Web (Actions)', () => {
       loadFormsSDK: true,
       subscriptions
     })
-
     jest.spyOn(destination, 'initialize')
 
     await event.load(Context.system(), {} as Analytics)
     expect(destination.initialize).toHaveBeenCalled()
 
-    const hsScript = window.document.querySelector('#hs-analytics') as HTMLScriptElement
-    const hsForms = window.document.querySelector(
-      'script[src~="https://js.hsforms.net/forms/v2.js"]'
-    ) as HTMLScriptElement
-
-    expect(hsScript).toBeDefined()
-    expect(hsForms).toBeDefined()
+    expect(window._hsq).toEqual('🇺🇸')
+    expect(window.hbspt).toBeDefined()
   })
 })
diff --git a/packages/browser-destinations/src/destinations/index.ts b/packages/browser-destinations/src/destinations/index.ts
index c90bc515..87b663af 100644
--- a/packages/browser-destinations/src/destinations/index.ts
+++ b/packages/browser-destinations/src/destinations/index.ts
@@ -47,3 +47,5 @@ register('6372e1e36d9c2181f3900834', './wisepops')
 register('637c192eba61b944e08ee158', './vwo')
 register('638f843c4520d424f63c9e51', './commandbar')
 register('63913b2bf906ea939f153851', './ripe')
+
+
diff --git a/packages/browser-destinations/src/destinations/logrocket/__tests__/index.test.ts b/packages/browser-destinations/src/destinations/logrocket/__tests__/index.test.ts
index ed49a162..c5d9975b 100644
--- a/packages/browser-destinations/src/destinations/logrocket/__tests__/index.test.ts
+++ b/packages/browser-destinations/src/destinations/logrocket/__tests__/index.test.ts
@@ -1,19 +1,105 @@
 import { Analytics, Context } from '@segment/analytics-next'
 import plugins, { destination } from '../index'
 import { mockWorkerAndXMLHttpRequest, subscriptions } from '../test_utilities'
+import Logrocket from 'logrocket'
+
+jest.mock('logrocket')
+
+const appID = 'log/rocket'
 
 describe('Logrocket', () => {
   beforeAll(mockWorkerAndXMLHttpRequest)
   afterAll(jest.restoreAllMocks)
 
   test('can load', async () => {
-    const [event] = await plugins({ appID: 'log/rocket', subscriptions })
+    const [event] = await plugins({
+      appID,
+      networkSanitization: false,
+      inputSanitization: false,
+      subscriptions
+    })
 
     jest.spyOn(destination, 'initialize')
+    jest.spyOn(Logrocket, 'init')
 
     await event.load(Context.system(), {} as Analytics)
     expect(destination.initialize).toHaveBeenCalled()
+    expect(Logrocket.init).toHaveBeenCalled()
 
     expect(window._LRLogger).toBeDefined()
   })
+
+  test('supplies the input sanitization parameter', async () => {
+    const [event] = await plugins({
+      appID,
+      networkSanitization: false,
+      inputSanitization: true,
+      subscriptions
+    })
+
+    jest.spyOn(Logrocket, 'init')
+
+    await event.load(Context.system(), {} as Analytics)
+    expect(Logrocket.init).toHaveBeenCalledWith(appID, expect.objectContaining({ dom: { inputSanitizer: true } }))
+  })
+
+  describe('network sanitizer', () => {
+    test('redacts requests when configured', async () => {
+      const [event] = await plugins({
+        appID,
+        networkSanitization: true,
+        inputSanitization: false,
+        subscriptions
+      })
+
+      const spy = jest.spyOn(Logrocket, 'init')
+
+      await event.load(Context.system(), {} as Analytics)
+      expect(Logrocket.init).toHaveBeenCalledWith(appID, expect.objectContaining({ dom: { inputSanitizer: false } }))
+      const requestSanitizer: RequestSanitizer = spy.mock.calls[0][1]?.network?.requestSanitizer
+
+      if (!requestSanitizer) fail('request sanitizer null')
+
+      const mockRequest = {
+        body: 'hello',
+        headers: { goodbye: 'moon' },
+        reqId: 'something',
+        url: 'neat',
+        method: 'get'
+      }
+
+      const sanitizedResult = requestSanitizer(mockRequest)
+
+      expect(sanitizedResult).toEqual(expect.objectContaining({ body: undefined, headers: {} }))
+    })
+
+    test('does not modify requests if disabled', async () => {
+      const [event] = await plugins({
+        appID,
+        networkSanitization: false,
+        inputSanitization: false,
+        subscriptions
+      })
+
+      const spy = jest.spyOn(Logrocket, 'init')
+
+      await event.load(Context.system(), {} as Analytics)
+      expect(Logrocket.init).toHaveBeenCalledWith(appID, expect.objectContaining({ dom: { inputSanitizer: false } }))
+      const requestSanitizer: RequestSanitizer = spy.mock.calls[0][1]?.network?.requestSanitizer
+
+      if (!requestSanitizer) fail('request sanitizer null')
+
+      const mockRequest = {
+        body: 'hello',
+        headers: { goodbye: 'moon' },
+        reqId: 'something',
+        url: 'neat',
+        method: 'get'
+      }
+
+      const sanitizedResult = requestSanitizer(mockRequest)
+
+      expect(sanitizedResult).toEqual(mockRequest)
+    })
+  })
 })
diff --git a/packages/browser-destinations/src/destinations/logrocket/generated-types.ts b/packages/browser-destinations/src/destinations/logrocket/generated-types.ts
index c3ea399f..b1f23f24 100644
--- a/packages/browser-destinations/src/destinations/logrocket/generated-types.ts
+++ b/packages/browser-destinations/src/destinations/logrocket/generated-types.ts
@@ -5,4 +5,12 @@ export interface Settings {
    * The LogRocket app ID.
    */
   appID: string
+  /**
+   * Sanitize all network request and response bodies from session recordings.
+   */
+  networkSanitization: boolean
+  /**
+   * Obfuscate all user-input elements (like <input> and <select>) from session recordings.
+   */
+  inputSanitization: boolean
 }
diff --git a/packages/browser-destinations/src/destinations/logrocket/index.ts b/packages/browser-destinations/src/destinations/logrocket/index.ts
index 10633a1f..29e193ed 100644
--- a/packages/browser-destinations/src/destinations/logrocket/index.ts
+++ b/packages/browser-destinations/src/destinations/logrocket/index.ts
@@ -10,8 +10,12 @@ import { defaultValues } from '@segment/actions-core'
 declare global {
   interface Window {
     LogRocket: LR
+    logRocketSettings?: LogRocketSettings
     _LRLogger: () => void
   }
+
+  type LogRocketSettings = NonNullable<Parameters<LR['init']>[1]>
+  type RequestSanitizer = NonNullable<LogRocketSettings['network']>['requestSanitizer']
 }
 // Switch from unknown to the partner SDK client types
 export const destination: BrowserDestinationDefinition<Settings, LR> = {
@@ -40,11 +44,42 @@ export const destination: BrowserDestinationDefinition<Settings, LR> = {
       label: 'LogRocket App',
       type: 'string',
       required: true
+    },
+    networkSanitization: {
+      description: 'Sanitize all network request and response bodies from session recordings.',
+      label: 'Network Sanitization',
+      type: 'boolean',
+      required: true,
+      default: true
+    },
+    inputSanitization: {
+      description: 'Obfuscate all user-input elements (like <input> and <select>) from session recordings.',
+      label: 'Input Sanitization',
+      type: 'boolean',
+      required: true,
+      default: true
     }
   },
 
-  initialize: async ({ settings: { appID } }, deps) => {
-    LogRocket.init(appID)
+  initialize: async ({ settings: { appID, inputSanitization: inputSanitizer, networkSanitization } }, deps) => {
+    const requestSanitizer: RequestSanitizer = (request) => {
+      if (networkSanitization) {
+        request.body = undefined
+        request.headers = {}
+      }
+
+      return request
+    }
+    const settings: LogRocketSettings = {
+      dom: {
+        inputSanitizer
+      },
+      network: {
+        requestSanitizer,
+        responseSanitizer: requestSanitizer
+      }
+    }
+    LogRocket.init(appID, window.logRocketSettings || settings)
     await deps.resolveWhen(() => Object.prototype.hasOwnProperty.call(window, '_LRLogger'), 100)
     return LogRocket
   },
diff --git a/packages/browser-destinations/src/destinations/vwo/generated-types.ts b/packages/browser-destinations/src/destinations/vwo/generated-types.ts
index c33015c8..739bd8ff 100644
--- a/packages/browser-destinations/src/destinations/vwo/generated-types.ts
+++ b/packages/browser-destinations/src/destinations/vwo/generated-types.ts
@@ -2,7 +2,19 @@
 
 export interface Settings {
   /**
-   * The VWO AccountID from VWO dashboard
+   * Your VWO account ID, used for fetching your VWO async smart code.
    */
   vwoAccountId: number
+  /**
+   * The maximum amount of time (in milliseconds) to wait for test settings before VWO will simply display your original page.
+   */
+  settingsTolerance?: number
+  /**
+   * The maximum amount of time (in milliseconds) to wait for VWO’s full library to be downloaded before simply displaying your original page.
+   */
+  libraryTolerance?: number
+  /**
+   * If your page already includes JQuery, you can set this to “true”. Otherwise, VWO will include JQuery onto the page for you. VWO needs JQuery on the page to function correctly.
+   */
+  useExistingJquery?: boolean
 }
diff --git a/packages/browser-destinations/src/destinations/vwo/identifyUser/__tests__/index.test.ts b/packages/browser-destinations/src/destinations/vwo/identifyUser/__tests__/index.test.ts
new file mode 100644
index 00000000..5871a2a9
--- /dev/null
+++ b/packages/browser-destinations/src/destinations/vwo/identifyUser/__tests__/index.test.ts
@@ -0,0 +1,64 @@
+import { Analytics, Context } from '@segment/analytics-next'
+import { Subscription } from 'src/lib/browser-destinations'
+import type { VWO } from '../../types'
+import vwoDestination, { destination } from '../../index'
+
+const subscriptions: Subscription[] = [
+  {
+    partnerAction: 'identifyUser',
+    name: 'Identify User',
+    enabled: true,
+    subscribe: 'type = "identify"',
+    mapping: {
+      attributes: {
+        '@path': '$.traits'
+      }
+    }
+  }
+]
+
+describe('VWO.identifyUser', () => {
+  const settings = {
+    vwoAccountId: 654331
+  }
+
+  let mockVWO: VWO
+  let identifyUser: any
+  beforeEach(async () => {
+    jest.restoreAllMocks()
+
+    const [identifyUserPlugin] = await vwoDestination({
+      ...settings,
+      subscriptions
+    })
+    identifyUser = identifyUserPlugin
+
+    jest.spyOn(destination, 'initialize').mockImplementation(() => {
+      mockVWO = {
+        event: jest.fn(),
+        visitor: jest.fn()
+      }
+      return Promise.resolve(mockVWO)
+    })
+    await identifyUser.load(Context.system(), {} as Analytics)
+  })
+
+  test('Visitor call with attributes', async () => {
+    const context = new Context({
+      type: 'identify',
+      traits: {
+        textAttribute: 'Hello'
+      }
+    })
+    await identifyUser.identify?.(context)
+
+    expect(mockVWO.visitor).toHaveBeenCalledWith(
+      {
+        segment_textAttribute: 'Hello'
+      },
+      {
+        source: 'segment.web'
+      }
+    )
+  })
+})
diff --git a/packages/browser-destinations/src/destinations/vwo/identifyUser/generated-types.ts b/packages/browser-destinations/src/destinations/vwo/identifyUser/generated-types.ts
new file mode 100644
index 00000000..e20b58e5
--- /dev/null
+++ b/packages/browser-destinations/src/destinations/vwo/identifyUser/generated-types.ts
@@ -0,0 +1,10 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Payload {
+  /**
+   * A JSON object containing additional attributes that will be associated with the user.
+   */
+  attributes: {
+    [k: string]: unknown
+  }
+}
diff --git a/packages/browser-destinations/src/destinations/vwo/identifyUser/index.ts b/packages/browser-destinations/src/destinations/vwo/identifyUser/index.ts
new file mode 100644
index 00000000..dd0eb247
--- /dev/null
+++ b/packages/browser-destinations/src/destinations/vwo/identifyUser/index.ts
@@ -0,0 +1,35 @@
+import type { BrowserActionDefinition } from '../../../lib/browser-destinations'
+import type { VWO } from '../types'
+import type { Settings } from '../generated-types'
+import type { Payload } from './generated-types'
+import { formatAttributes } from '../utility'
+
+// Change from unknown to the partner SDK types
+const action: BrowserActionDefinition<Settings, VWO, Payload> = {
+  title: 'Identify User',
+  description: 'Forwards user traits to VWO Data360 attributes',
+  defaultSubscription: 'type = "identify"',
+  platform: 'web',
+  fields: {
+    attributes: {
+      description: 'A JSON object containing additional attributes that will be associated with the user.',
+      label: 'Attributes',
+      required: true,
+      type: 'object',
+      default: {
+        '@path': '$.traits'
+      }
+    }
+  },
+  perform: (VWO, event) => {
+    const { attributes } = event.payload
+    const formattedAttributes = formatAttributes(attributes)
+
+    if (!VWO.visitor) {
+      return
+    }
+    VWO.visitor(formattedAttributes, { source: 'segment.web' })
+  }
+}
+
+export default action
diff --git a/packages/browser-destinations/src/destinations/vwo/index.ts b/packages/browser-destinations/src/destinations/vwo/index.ts
index 4bc3e16b..e10b8813 100644
--- a/packages/browser-destinations/src/destinations/vwo/index.ts
+++ b/packages/browser-destinations/src/destinations/vwo/index.ts
@@ -2,10 +2,12 @@ import type { Settings } from './generated-types'
 import type { BrowserDestinationDefinition } from '../../lib/browser-destinations'
 import { browserDestination } from '../../runtime/shim'
 import type { VWO } from './types'
-import trackEvent from './trackEvent'
 import { initScript } from './init-script'
 import { defaultValues } from '@segment/actions-core'
 
+import trackEvent from './trackEvent'
+import identifyUser from './identifyUser'
+
 declare global {
   interface Window {
     VWO: VWO
@@ -23,26 +25,59 @@ export const destination: BrowserDestinationDefinition<Settings, VWO> = {
       subscribe: 'type = "track"',
       partnerAction: 'trackEvent',
       mapping: defaultValues(trackEvent.fields)
+    },
+    {
+      name: 'Identify User',
+      subscribe: 'type = "identify"',
+      partnerAction: 'identifyUser',
+      mapping: defaultValues(identifyUser.fields)
     }
   ],
   settings: {
     // Add any Segment destination settings required here
     vwoAccountId: {
-      description: 'The VWO AccountID from VWO dashboard',
+      description: 'Your VWO account ID, used for fetching your VWO async smart code.',
       label: 'VWO Account ID',
       type: 'number',
       required: true
+    },
+    settingsTolerance: {
+      description:
+        'The maximum amount of time (in milliseconds) to wait for test settings before VWO will simply display your original page.',
+      label: 'Settings Tolerance',
+      type: 'number',
+      default: 2000
+    },
+    libraryTolerance: {
+      description:
+        'The maximum amount of time (in milliseconds) to wait for VWO’s full library to be downloaded before simply displaying your original page.',
+      label: 'Library Tolerance',
+      type: 'number',
+      default: 2500
+    },
+    useExistingJquery: {
+      description:
+        'If your page already includes JQuery, you can set this to “true”. Otherwise, VWO will include JQuery onto the page for you. VWO needs JQuery on the page to function correctly. ',
+      label: 'Use Existing JQuery',
+      type: 'boolean',
+      default: false
     }
   },
 
   initialize: async ({ settings }, deps) => {
-    initScript({ vwoAccountId: settings.vwoAccountId })
+    initScript({
+      vwoAccountId: settings.vwoAccountId,
+      settingsTolerance: settings.settingsTolerance,
+      libraryTolerance: settings.libraryTolerance,
+      useExistingJquery: settings.useExistingJquery
+    })
     await deps.resolveWhen(() => Object.prototype.hasOwnProperty.call(window, 'VWO'), 100)
     return window.VWO
   },
 
   actions: {
-    trackEvent
+    trackEvent,
+    identifyUser
   }
 }
 
diff --git a/packages/browser-destinations/src/destinations/vwo/init-script.ts b/packages/browser-destinations/src/destinations/vwo/init-script.ts
index 37d35ea2..a9262f44 100644
--- a/packages/browser-destinations/src/destinations/vwo/init-script.ts
+++ b/packages/browser-destinations/src/destinations/vwo/init-script.ts
@@ -1,15 +1,21 @@
 /* eslint-disable */
 // @ts-nocheck
 
-export function initScript({ vwoAccountId }) {
+export function initScript({
+  vwoAccountId,
+  settingsTolerance = 2000,
+  libraryTolerance = 2500,
+  useExistingJquery = false,
+  isSpa = 1
+}) {
   window._vwo_code =
     window._vwo_code ||
     (function () {
       var account_id = vwoAccountId,
-        settings_tolerance = 2000,
-        library_tolerance = 2500,
-        use_existing_jquery = false,
-        is_spa = 1,
+        settings_tolerance = settingsTolerance,
+        library_tolerance = libraryTolerance,
+        use_existing_jquery = useExistingJquery,
+        is_spa = isSpa,
         hide_element = 'body',
         /* DO NOT EDIT BELOW THIS LINE */
         f = false,
@@ -63,7 +69,8 @@ export function initScript({ vwoAccountId }) {
                 '&f=' +
                 +is_spa +
                 '&r=' +
-                Math.random()
+                Math.random() +
+                '&s=segment.web'
             )
             return settings_timer
           }
diff --git a/packages/browser-destinations/src/destinations/vwo/trackEvent/__tests__/index.test.ts b/packages/browser-destinations/src/destinations/vwo/trackEvent/__tests__/index.test.ts
index d4f101a9..d1427700 100644
--- a/packages/browser-destinations/src/destinations/vwo/trackEvent/__tests__/index.test.ts
+++ b/packages/browser-destinations/src/destinations/vwo/trackEvent/__tests__/index.test.ts
@@ -38,7 +38,8 @@ describe('VWO.trackEvent', () => {
 
     jest.spyOn(destination, 'initialize').mockImplementation(() => {
       mockVWO = {
-        event: jest.fn()
+        event: jest.fn(),
+        visitor: jest.fn()
       }
       return Promise.resolve(mockVWO)
     })
@@ -52,9 +53,14 @@ describe('VWO.trackEvent', () => {
     })
     await trackEvent.track?.(context)
 
-    expect(mockVWO.event).toHaveBeenCalledWith('ctaClick', {
-      source: 'segment.web'
-    })
+    expect(mockVWO.event).toHaveBeenCalledWith(
+      'segment_ctaClick',
+      {},
+      {
+        source: 'segment.web',
+        ogName: 'ctaClick'
+      }
+    )
   })
 
   test('Track call with parameters', async () => {
@@ -67,9 +73,15 @@ describe('VWO.trackEvent', () => {
     })
     await trackEvent.track?.(context)
 
-    expect(mockVWO.event).toHaveBeenCalledWith('buyButtonClick', {
-      amount: 1000,
-      source: 'segment.web'
-    })
+    expect(mockVWO.event).toHaveBeenCalledWith(
+      'segment_buyButtonClick',
+      {
+        amount: 1000
+      },
+      {
+        source: 'segment.web',
+        ogName: 'buyButtonClick'
+      }
+    )
   })
 })
diff --git a/packages/browser-destinations/src/destinations/vwo/trackEvent/index.ts b/packages/browser-destinations/src/destinations/vwo/trackEvent/index.ts
index 0f293009..1dd726e7 100644
--- a/packages/browser-destinations/src/destinations/vwo/trackEvent/index.ts
+++ b/packages/browser-destinations/src/destinations/vwo/trackEvent/index.ts
@@ -2,6 +2,7 @@ import type { BrowserActionDefinition } from '../../../lib/browser-destinations'
 import type { VWO } from '../types'
 import type { Settings } from '../generated-types'
 import type { Payload } from './generated-types'
+import { sanitiseEventName } from '../utility'
 
 // Change from unknown to the partner SDK types
 const action: BrowserActionDefinition<Settings, VWO, Payload> = {
@@ -31,12 +32,15 @@ const action: BrowserActionDefinition<Settings, VWO, Payload> = {
   },
   perform: (VWO, event) => {
     const { eventName, properties } = event.payload
+    const sanitisedEventName = sanitiseEventName(eventName)
     const formattedProperties = { ...properties }
-    formattedProperties['source'] = `segment.web`
     if (!VWO.event) {
       return
     }
-    VWO.event(eventName, formattedProperties)
+    VWO.event(sanitisedEventName, formattedProperties, {
+      source: 'segment.web',
+      ogName: eventName
+    })
   }
 }
 
diff --git a/packages/browser-destinations/src/destinations/vwo/types.ts b/packages/browser-destinations/src/destinations/vwo/types.ts
index 28dc980f..31fcb350 100644
--- a/packages/browser-destinations/src/destinations/vwo/types.ts
+++ b/packages/browser-destinations/src/destinations/vwo/types.ts
@@ -1,3 +1,8 @@
 export type VWO = {
-  event: (event: string, properties: { [k: string]: unknown } | undefined) => void
+  event: (
+    event: string,
+    properties: { [k: string]: unknown } | undefined,
+    vwoMeta: { [k: string]: unknown } | undefined
+  ) => void
+  visitor: (attributes: { [k: string]: unknown }, vwoMeta: { [k: string]: unknown } | undefined) => void
 }
diff --git a/packages/browser-destinations/src/destinations/vwo/utility.ts b/packages/browser-destinations/src/destinations/vwo/utility.ts
new file mode 100644
index 00000000..f5550940
--- /dev/null
+++ b/packages/browser-destinations/src/destinations/vwo/utility.ts
@@ -0,0 +1,11 @@
+export function formatAttributes(attributes: { [k: string]: unknown }) {
+  const formattedAttributes: { [k: string]: unknown } = {}
+  for (const key in attributes) {
+    formattedAttributes[`segment_${key}`] = attributes[key]
+  }
+  return formattedAttributes
+}
+
+export function sanitiseEventName(name: string) {
+  return 'segment_' + name
+}
diff --git a/packages/cli-internal/package.json b/packages/cli-internal/package.json
index 241d6f88..a7c6ec69 100644
--- a/packages/cli-internal/package.json
+++ b/packages/cli-internal/package.json
@@ -1,7 +1,7 @@
 {
   "name": "@segment/actions-cli-internal",
   "description": "CLI to interact with Segment integrations",
-  "version": "3.114.0",
+  "version": "3.121.0",
   "license": "MIT",
   "repository": {
     "type": "git",
@@ -53,8 +53,8 @@
     "@oclif/config": "^1",
     "@oclif/errors": "^1",
     "@oclif/plugin-help": "^3.3",
-    "@segment/action-destinations": "^3.118.0",
-    "@segment/actions-core": "^3.45.0",
+    "@segment/action-destinations": "^3.125.0",
+    "@segment/actions-core": "^3.47.0",
     "chalk": "^4.1.1",
     "chokidar": "^3.5.1",
     "dotenv": "^10.0.0",
@@ -77,7 +77,7 @@
     "tslib": "^2.3.1"
   },
   "optionalDependencies": {
-    "@segment/browser-destinations": "^3.66.0",
+    "@segment/browser-destinations": "^3.69.0",
     "@segment/control-plane-service-client": "github:segmentio/control-plane-service-js-client.git#master"
   },
   "oclif": {
diff --git a/packages/cli-internal/src/commands/push-browser-destinations.ts b/packages/cli-internal/src/commands/push-browser-destinations.ts
index 854de4e4..a7aa4176 100644
--- a/packages/cli-internal/src/commands/push-browser-destinations.ts
+++ b/packages/cli-internal/src/commands/push-browser-destinations.ts
@@ -174,10 +174,10 @@ export default class PushBrowserDestinations extends Command {
 
 async function syncToS3(env: string): Promise<string> {
   if (env === 'production') {
-    return execa.commandSync(`lerna run deploy-prod`).stdout
+    return execa.commandSync(`yarn lerna run deploy-prod`).stdout
   }
 
-  return execa.commandSync(`lerna run deploy-stage`).stdout
+  return execa.commandSync(`yarn lerna run deploy-stage`).stdout
 }
 
 function asJson(obj: unknown) {
diff --git a/packages/cli/package.json b/packages/cli/package.json
index 2643fb99..0d374e08 100644
--- a/packages/cli/package.json
+++ b/packages/cli/package.json
@@ -1,7 +1,7 @@
 {
   "name": "@segment/actions-cli",
   "description": "CLI to interact with Segment integrations",
-  "version": "3.114.0",
+  "version": "3.121.0",
   "license": "MIT",
   "repository": {
     "type": "git",
@@ -56,8 +56,8 @@
     "@oclif/config": "^1",
     "@oclif/errors": "^1",
     "@oclif/plugin-help": "^3.3",
-    "@segment/action-destinations": "^3.118.0",
-    "@segment/actions-core": "^3.45.0",
+    "@segment/action-destinations": "^3.125.0",
+    "@segment/actions-core": "^3.47.0",
     "chalk": "^4.1.1",
     "chokidar": "^3.5.1",
     "dotenv": "^10.0.0",
@@ -80,8 +80,8 @@
     "tslib": "^2.3.1"
   },
   "optionalDependencies": {
-    "@segment/actions-cli-internal": "^3.114.0",
-    "@segment/browser-destinations": "^3.66.0"
+    "@segment/actions-cli-internal": "^3.121.0",
+    "@segment/browser-destinations": "^3.69.0"
   },
   "oclif": {
     "commands": "./dist/commands",
diff --git a/packages/cli/src/lib/web-bundles.ts b/packages/cli/src/lib/web-bundles.ts
index b5b7e8f1..b3879a78 100644
--- a/packages/cli/src/lib/web-bundles.ts
+++ b/packages/cli/src/lib/web-bundles.ts
@@ -17,8 +17,8 @@ export function webBundles(): { [destination: string]: string } {
 export function build(env: string): string {
   execa.commandSync(`rm -rf ${DIST_DIR}`)
   if (env === 'production') {
-    return execa.commandSync('lerna run build-web').stdout
+    return execa.commandSync('yarn lerna run build-web').stdout
   }
 
-  return execa.commandSync('lerna run build-web-stage').stdout
+  return execa.commandSync('yarn lerna run build-web-stage').stdout
 }
diff --git a/packages/core/package.json b/packages/core/package.json
index 2d2a8db1..893cd2df 100644
--- a/packages/core/package.json
+++ b/packages/core/package.json
@@ -1,7 +1,7 @@
 {
   "name": "@segment/actions-core",
   "description": "Core runtime for Destinations Actions.",
-  "version": "3.45.0",
+  "version": "3.47.0",
   "repository": {
     "type": "git",
     "url": "https://github.com/segmentio/fab-5-engine",
@@ -55,7 +55,7 @@
   "dependencies": {
     "@lukeed/uuid": "^2.0.0",
     "@segment/ajv-human-errors": "^2.1.2",
-    "@segment/destination-subscriptions": "^3.12.0",
+    "@segment/destination-subscriptions": "^3.13.0",
     "abort-controller": "^3.0.0",
     "aggregate-error": "^3.1.0",
     "ajv": "^8.6.3",
diff --git a/packages/core/src/__tests__/destination-kit.test.ts b/packages/core/src/__tests__/destination-kit.test.ts
index b9f82318..336bdee1 100644
--- a/packages/core/src/__tests__/destination-kit.test.ts
+++ b/packages/core/src/__tests__/destination-kit.test.ts
@@ -1,4 +1,5 @@
 import {
+  StateContext,
   Destination,
   DestinationDefinition,
   Logger,
@@ -103,8 +104,8 @@ const destinationWithOptions: DestinationDefinition<JSONObject> = {
       description: 'Send events to a custom event in API',
       defaultSubscription: 'type = "track"',
       fields: {},
-      perform: (_request, { features, statsContext, logger, transactionContext }) => {
-        return { features, statsContext, logger, transactionContext }
+      perform: (_request, { features, statsContext, logger, transactionContext, stateContext }) => {
+        return { features, statsContext, logger, transactionContext, stateContext }
       }
     }
   }
@@ -291,7 +292,7 @@ describe('destination kit', () => {
       try {
         await destinationTest.refreshAccessToken(testSettings, oauthData)
         fail('test should have thrown a NotImplemented error')
-      } catch (e) {
+      } catch (e: any) {
         expect(e.status).toEqual(501)
         expect(e.message).toEqual('refreshAccessToken is only valid with oauth2 authentication scheme')
         expect(e.code).toEqual('NotImplemented')
@@ -479,4 +480,57 @@ describe('destination kit', () => {
       ])
     })
   })
+
+  describe('stateContext', () => {
+    test('should not crash when stateContext is passed to the perform handler', async () => {
+      const destinationTest = new Destination(destinationWithOptions)
+      const testEvent: SegmentEvent = {
+        properties: { field_one: 'test input' },
+        userId: '3456fff',
+        type: 'track'
+      }
+      const testSettings = {
+        apiSecret: 'test_key',
+        subscription: {
+          subscribe: 'type = "track"',
+          partnerAction: 'customEvent',
+          mapping: {
+            clientId: '23455343467',
+            name: 'fancy_event',
+            parameters: { field_one: 'rogue one' }
+          }
+        }
+      }
+      const eventOptions = {
+        features: {},
+        statsContext: {} as StatsContext,
+        logger: { name: 'test-integration', level: 'debug' } as Logger,
+        transactionContext: {
+          transaction: { contact_id: '801' },
+          setTransaction: (key: string, value: string) => ({ [key]: value })
+        } as TransactionContext,
+        stateContext: {
+          getRequestContext: (_key: string, _cb?: (res?: string) => any): any => {},
+          setResponseContext: (
+            _key: string,
+            _value: string,
+            _ttl: { hour?: number; minute?: number; second?: number }
+          ): void => {}
+        } as StateContext
+      }
+      const res = await destinationTest.onEvent(testEvent, testSettings, eventOptions)
+      expect(res).toEqual([
+        { output: 'Mappings resolved' },
+        {
+          output: {
+            features: {},
+            statsContext: {},
+            logger: eventOptions.logger,
+            transactionContext: eventOptions.transactionContext,
+            stateContext: eventOptions.stateContext
+          }
+        }
+      ])
+    })
+  })
 })
diff --git a/packages/core/src/create-test-integration.ts b/packages/core/src/create-test-integration.ts
index 93ba9d76..cb70102b 100644
--- a/packages/core/src/create-test-integration.ts
+++ b/packages/core/src/create-test-integration.ts
@@ -1,5 +1,5 @@
 import { createTestEvent } from './create-test-event'
-import { Destination, TransactionContext } from './destination-kit'
+import { StateContext, Destination, TransactionContext } from './destination-kit'
 import { mapValues } from './map-values'
 import type { DestinationDefinition, StatsContext, Logger } from './destination-kit'
 import type { JSONObject } from './json-object'
@@ -34,12 +34,13 @@ interface InputData<Settings> {
   auth?: AuthTokens
   /**
    * The features available in the request based on the customer's sourceID;
-   * `features`, `stats`, `logger` and `transactionContext` are for internal Twilio/Segment use only.
+   * `features`, `stats`, `logger` , `transactionContext` and `stateContext` are for internal Twilio/Segment use only.
    */
   features?: Features
   statsContext?: StatsContext
   logger?: Logger
   transactionContext?: TransactionContext
+  stateContext?: StateContext
 }
 
 class TestDestination<T> extends Destination<T> {
@@ -65,7 +66,8 @@ class TestDestination<T> extends Destination<T> {
       features,
       statsContext,
       logger,
-      transactionContext
+      transactionContext,
+      stateContext
     }: InputData<T>
   ): Promise<Destination['responses']> {
     mapping = mapping ?? {}
@@ -84,7 +86,8 @@ class TestDestination<T> extends Destination<T> {
       features: features ?? {},
       statsContext: statsContext ?? ({} as StatsContext),
       logger: logger ?? ({} as Logger),
-      transactionContext: transactionContext ?? ({} as TransactionContext)
+      transactionContext: transactionContext ?? ({} as TransactionContext),
+      stateContext: stateContext ?? ({} as StateContext)
     })
 
     const responses = this.responses
@@ -104,7 +107,8 @@ class TestDestination<T> extends Destination<T> {
       features,
       statsContext,
       logger,
-      transactionContext
+      transactionContext,
+      stateContext
     }: Omit<InputData<T>, 'event'> & { events?: SegmentEvent[] }
   ): Promise<Destination['responses']> {
     mapping = mapping ?? {}
@@ -127,7 +131,8 @@ class TestDestination<T> extends Destination<T> {
       features: features ?? {},
       statsContext: statsContext ?? ({} as StatsContext),
       logger: logger ?? ({} as Logger),
-      transactionContext: transactionContext ?? ({} as TransactionContext)
+      transactionContext: transactionContext ?? ({} as TransactionContext),
+      stateContext: stateContext ?? ({} as StateContext)
     })
 
     const responses = this.responses
diff --git a/packages/core/src/destination-kit/action.ts b/packages/core/src/destination-kit/action.ts
index c73f6c30..a96b30fe 100644
--- a/packages/core/src/destination-kit/action.ts
+++ b/packages/core/src/destination-kit/action.ts
@@ -12,7 +12,7 @@ import { validateSchema } from '../schema-validation'
 import { AuthTokens } from './parse-settings'
 import { IntegrationError } from '../errors'
 import { removeEmptyValues } from '../remove-empty-values'
-import { Logger, StatsContext, TransactionContext } from './index'
+import { Logger, StatsContext, TransactionContext, StateContext } from './index'
 
 type MaybePromise<T> = T | Promise<T>
 type RequestClient = ReturnType<typeof createRequestClient>
@@ -83,6 +83,7 @@ interface ExecuteBundle<T = unknown, Data = unknown> {
   statsContext?: StatsContext | undefined
   logger?: Logger | undefined
   transactionContext?: TransactionContext
+  stateContext?: StateContext
 }
 
 /**
@@ -145,7 +146,8 @@ export class Action<Settings, Payload extends JSONLikeObject> extends EventEmitt
       features: bundle.features,
       statsContext: bundle.statsContext,
       logger: bundle.logger,
-      transactionContext: bundle.transactionContext
+      transactionContext: bundle.transactionContext,
+      stateContext: bundle.stateContext
     }
 
     // Construct the request client and perform the action
@@ -192,7 +194,8 @@ export class Action<Settings, Payload extends JSONLikeObject> extends EventEmitt
         features: bundle.features,
         statsContext: bundle.statsContext,
         logger: bundle.logger,
-        transactionContext: bundle.transactionContext
+        transactionContext: bundle.transactionContext,
+        stateContext: bundle.stateContext
       }
       await this.performRequest(this.definition.performBatch, data)
     }
diff --git a/packages/core/src/destination-kit/index.ts b/packages/core/src/destination-kit/index.ts
index ab485267..424d1357 100644
--- a/packages/core/src/destination-kit/index.ts
+++ b/packages/core/src/destination-kit/index.ts
@@ -183,6 +183,7 @@ interface EventInput<Settings> {
   readonly statsContext?: StatsContext
   readonly logger?: Logger
   readonly transactionContext?: TransactionContext
+  readonly stateContext?: StateContext
 }
 
 interface BatchEventInput<Settings> {
@@ -196,6 +197,7 @@ interface BatchEventInput<Settings> {
   readonly statsContext?: StatsContext
   readonly logger?: Logger
   readonly transactionContext?: TransactionContext
+  readonly stateContext?: StateContext
 }
 
 export interface DecoratedResponse extends ModifiedResponse {
@@ -210,6 +212,7 @@ interface OnEventOptions {
   statsContext?: StatsContext
   logger?: Logger
   transactionContext?: TransactionContext
+  stateContext?: StateContext
 }
 
 /** Transaction variables and setTransaction method are passed from mono service for few Segment built integrations.
@@ -220,6 +223,14 @@ export interface TransactionContext {
   setTransaction: (key: string, value: string) => void
 }
 
+export interface StateContext {
+  // getRequestContext reads the `context` field from the request
+  getRequestContext(key: string, cb?: (res?: string) => any): any
+  // setResponseContext sets values in the `setContext` field in the response
+  // values set on the response will be available on subsequent requests
+  setResponseContext(key: string, value: string, ttl: { hour?: number; minute?: number; second?: number }): void
+}
+
 export interface StatsClient {
   observe: (metric: any) => any
   _name(name: string): string
@@ -369,7 +380,17 @@ export class Destination<Settings = JSONObject> {
 
   protected async executeAction(
     actionSlug: string,
-    { event, mapping, settings, auth, features, statsContext, logger, transactionContext }: EventInput<Settings>
+    {
+      event,
+      mapping,
+      settings,
+      auth,
+      features,
+      statsContext,
+      logger,
+      transactionContext,
+      stateContext
+    }: EventInput<Settings>
   ): Promise<Result[]> {
     const action = this.actions[actionSlug]
     if (!action) {
@@ -384,13 +405,24 @@ export class Destination<Settings = JSONObject> {
       features,
       statsContext,
       logger,
-      transactionContext
+      transactionContext,
+      stateContext
     })
   }
 
   public async executeBatch(
     actionSlug: string,
-    { events, mapping, settings, auth, features, statsContext, logger, transactionContext }: BatchEventInput<Settings>
+    {
+      events,
+      mapping,
+      settings,
+      auth,
+      features,
+      statsContext,
+      logger,
+      transactionContext,
+      stateContext
+    }: BatchEventInput<Settings>
   ) {
     const action = this.actions[actionSlug]
     if (!action) {
@@ -405,7 +437,8 @@ export class Destination<Settings = JSONObject> {
       features,
       statsContext,
       logger,
-      transactionContext
+      transactionContext,
+      stateContext
     })
 
     return [{ output: 'successfully processed batch of events' }]
@@ -440,7 +473,8 @@ export class Destination<Settings = JSONObject> {
       features: options?.features || {},
       statsContext: options?.statsContext || ({} as StatsContext),
       logger: options?.logger,
-      transactionContext: options?.transactionContext
+      transactionContext: options?.transactionContext,
+      stateContext: options?.stateContext
     }
 
     let results: Result[] | null = null
diff --git a/packages/core/src/destination-kit/types.ts b/packages/core/src/destination-kit/types.ts
index 3edeac07..f669cf0d 100644
--- a/packages/core/src/destination-kit/types.ts
+++ b/packages/core/src/destination-kit/types.ts
@@ -1,4 +1,4 @@
-import { Logger, StatsContext, TransactionContext } from './index'
+import { StateContext, Logger, StatsContext, TransactionContext } from './index'
 import type { RequestOptions } from '../request-client'
 import type { JSONObject } from '../json-object'
 import { AuthTokens } from './parse-settings'
@@ -27,12 +27,13 @@ export interface ExecuteInput<Settings, Payload> {
   readonly auth?: AuthTokens
   /**
    * The features available in the request based on the customer's sourceID;
-   * `features`,`stats`, `logger` and `transactionContext` are for internal Twilio/Segment use only.
+   * `features`,`stats`, `logger` , `transactionContext` and `stateContext` are for internal Twilio/Segment use only.
    */
   readonly features?: Features
   readonly statsContext?: StatsContext
   readonly logger?: Logger
   readonly transactionContext?: TransactionContext
+  readonly stateContext?: StateContext
 }
 
 export interface DynamicFieldResponse {
diff --git a/packages/destination-actions/package.json b/packages/destination-actions/package.json
index 519768b3..575b959f 100644
--- a/packages/destination-actions/package.json
+++ b/packages/destination-actions/package.json
@@ -1,7 +1,7 @@
 {
   "name": "@segment/action-destinations",
   "description": "Destination Actions engine and definitions.",
-  "version": "3.118.0",
+  "version": "3.125.0",
   "repository": {
     "type": "git",
     "url": "https://github.com/segmentio/action-destinations",
@@ -38,8 +38,8 @@
   "dependencies": {
     "@amplitude/ua-parser-js": "^0.7.25",
     "@segment/a1-notation": "^2.1.4",
-    "@segment/actions-core": "^3.45.0",
-    "@segment/actions-shared": "^1.27.0",
+    "@segment/actions-core": "^3.47.0",
+    "@segment/actions-shared": "^1.29.0",
     "cheerio": "^1.0.0-rc.10",
     "dayjs": "^1.10.7",
     "escape-goat": "^3",
diff --git a/packages/destination-actions/src/destinations/actable-predictive/__tests__/index.test.ts b/packages/destination-actions/src/destinations/actable-predictive/__tests__/index.test.ts
index 1d82955b..ddd43930 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/__tests__/index.test.ts
@@ -10,7 +10,7 @@ describe('Actable Predictive', () => {
       nock(API_URL).post('').reply(200, {})
 
       // This should match your authentication.fields
-      const authData = { client_id: 'foo', client_secret: 'bar' }
+      const authData = { client_id: "foo", client_secret: "bar" }
 
       await expect(testDestination.testAuthentication(authData)).resolves.not.toThrowError()
     })
diff --git a/packages/destination-actions/src/destinations/actable-predictive/index.ts b/packages/destination-actions/src/destinations/actable-predictive/index.ts
index 405b91d0..4fb021eb 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/index.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/index.ts
@@ -8,7 +8,8 @@ import sendCustomEvent from './sendCustomEvent'
 
 import dayjs from '../../lib/dayjs'
 
-export const API_URL = 'https://api.converscience.com/events'
+
+export const API_URL = "https://api.converscience.com/events"
 
 export function formatTimestampAsUnixSeconds(ISOTimestamp: string | number) {
   return dayjs.utc(ISOTimestamp).unix()
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/__tests__/index.test.ts b/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/__tests__/index.test.ts
index 149b9ea0..73eb5fbe 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/__tests__/index.test.ts
@@ -22,36 +22,40 @@ describe('ActablePredictive.sendCustomEvent', () => {
       properties: {
         custom_attr_1: '50314b8e9bcf000000000000',
         custom_attr_2: '999999',
-        custom_attr_3: 27.5,
-        custom_attr_4: '22.50ab$'
+        custom_attr_3: 27.50,
+        custom_attr_4: '22.50ab$',
       }
     }
 
     const event = createTestEvent({
-      userId: 'abc123def456',
-      type: 'track',
+      userId: "abc123def456",
+      type: "track",
       timestamp: '2021-10-05T15:30:35Z',
       properties: {
         custom_attr_1: '50314b8e9bcf000000000000',
         custom_attr_2: '999999',
-        custom_attr_3: 27.5,
-        custom_attr_4: '22.50ab$'
+        custom_attr_3: 27.50,
+        custom_attr_4: '22.50ab$',
       }
-    })
+    }
+    )
 
     const r = await testDestination.testAction('sendCustomEvent', {
       event,
-      settings: { client_id: 'foo', client_secret: 'bar' },
-      useDefaultMappings: true
+      settings: { client_id: "foo", client_secret: "bar" },
+      useDefaultMappings: true,
     })
 
-    const recievedEvent = r[0].options.json as any
+    const recievedEvent = (r[0].options.json as any)
     expect(r.length).toBe(1)
     expect(recievedEvent.data[0]).toMatchObject({
       customer_id: 'abc123def456',
       timestamp: 1633447835,
-      stream_key: 'custom',
-      ...customProperties
+      stream_key: "custom",
+      ...customProperties,
     })
   })
 })
+
+
+
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/index.ts b/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/index.ts
index 95f9a3a9..9940d606 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/index.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendCustomEvent/index.ts
@@ -17,9 +17,9 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     timestamp: {
-      type: 'datetime',
-      label: 'Timestamp of Event',
-      description: 'Timestamp of when the custom event occured.',
+      type: "datetime",
+      label: "Timestamp of Event",
+      description: "Timestamp of when the custom event occured.",
       format: 'date-time',
       required: true,
       default: {
@@ -27,20 +27,21 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     properties: {
-      type: 'object',
-      label: 'Custom Properties',
-      description: 'Send an object of custom properties to Actable Predictive for custom data modeling.',
-      format: 'text',
+      type: "object",
+      label: "Custom Properties",
+      description: "Send an object of custom properties to Actable Predictive for custom data modeling.",
+      format: "text",
       required: true,
       default: { '@path': '$.properties' }
+
     },
     stream_key: {
-      type: 'string',
-      format: 'text',
-      label: 'Stream Key',
-      description: 'Dataset label, should be left as default unless specified otherwise.',
+      type: "string",
+      format: "text",
+      label: "Stream Key",
+      description: "Dataset label, should be left as default unless specified otherwise.",
       required: true,
-      default: 'custom'
+      default: "custom"
     }
   },
   perform: (request, data) => {
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/__tests__/index.test.ts b/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/__tests__/index.test.ts
index a44f00ba..abdaeddb 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/__tests__/index.test.ts
@@ -18,25 +18,26 @@ describe('ActablePredictive.sendEmailEvent', () => {
   test('testClickEvent', async () => {
     setUpTest()
 
+
     const event = createTestEvent({
       type: 'track',
       userId: 'test-user-id',
       timestamp: '2021-10-05T15:30:35Z',
-      event: 'click',
+      event: "click",
       context: {
         campaign: {
-          name: 'springsale',
-          source: 'source_springsale',
-          medium: 'medium_springsale',
-          term: 'term_springsale',
-          content: 'content_springsale'
+          name: "springsale",
+          source: "source_springsale",
+          medium: "medium_springsale",
+          term: "term_springsale",
+          content: "content_springsale",
         }
       }
     })
 
     const r = await testDestination.testAction('sendEmailEvent', {
       event,
-      settings: { client_id: 'foo', client_secret: 'bar' },
+      settings: { client_id: "foo", client_secret: "bar" },
       useDefaultMappings: false,
       mapping: {
         customer_id: {
@@ -49,18 +50,21 @@ describe('ActablePredictive.sendEmailEvent', () => {
           '@path': '$.context.campaign.name'
         },
         clicked_flag: 1,
-        stream_key: 'email'
-      }
+        stream_key: "email"
+      },
     })
 
-    const recievedEvent = r[0].options.json as any
+    const recievedEvent = (r[0].options.json as any)
     expect(r.length).toBe(1) // (no auth request)
     expect(recievedEvent.data[0]).toMatchObject({
       customer_id: 'test-user-id',
       date_email_sent: 1633447835,
-      stream_key: 'email',
+      stream_key: "email",
       clicked_flag: 1,
-      campaign_name: 'springsale'
+      campaign_name: "springsale"
     })
   })
 })
+
+
+
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/index.ts b/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/index.ts
index 3eae5587..d07d85b4 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/index.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendEmailEvent/index.ts
@@ -17,9 +17,9 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     date_email_sent: {
-      type: 'datetime',
-      label: 'timestamp of event',
-      description: 'Timestamp of event',
+      type: "datetime",
+      label: "timestamp of event",
+      description: "Timestamp of event",
       format: 'date-time',
       required: true,
       default: {
@@ -27,43 +27,44 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     campaign_name: {
-      type: 'string',
-      label: 'Campaign Name of Email',
-      description: 'name of the campaign associated with the email',
+      type: "string",
+      label: "Campaign Name of Email",
+      description: "name of the campaign associated with the email",
       format: 'text',
       required: false,
       default: {
         '@path': '$.context.campaign.name'
       }
+
     },
     clicked_flag: {
-      type: 'integer',
-      label: 'Click Event Indicator',
-      description: '1=email was clicked, 0 email was not clicked',
+      type: "integer",
+      label: "Click Event Indicator",
+      description: "1=email was clicked, 0 email was not clicked",
       format: 'text',
       required: false
     },
     opened_flag: {
-      type: 'integer',
-      label: 'Open Event Indicator',
-      description: '1=email was opened, 0 email was not opened',
+      type: "integer",
+      label: "Open Event Indicator",
+      description: "1=email was opened, 0 email was not opened",
       format: 'text',
       required: false
     },
     unsub_flag: {
-      type: 'integer',
-      label: 'Unsubscribe Event Indicator',
-      description: '1=customer unsubscribed from the email list, 0 user remained subscribed',
+      type: "integer",
+      label: "Unsubscribe Event Indicator",
+      description: "1=customer unsubscribed from the email list, 0 user remained subscribed",
       format: 'text',
       required: false
     },
     stream_key: {
-      type: 'string',
-      format: 'text',
-      label: 'Stream Key',
-      description: 'Dataset label, should be left as default unless directed otherwise',
+      type: "string",
+      format: "text",
+      label: "Stream Key",
+      description: "Dataset label, should be left as default unless directed otherwise",
       required: true,
-      default: 'email'
+      default: "email"
     }
   },
   perform: (request, data) => {
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/__tests__/index.test.ts b/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/__tests__/index.test.ts
index eb367408..55f85604 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/__tests__/index.test.ts
@@ -18,17 +18,18 @@ describe('ActablePredictive.sendTransactionEvent', () => {
   test('testTransactionEvent', async () => {
     setUpTest()
 
+
     const event = createTestEvent({
-      userId: 'peterpan',
-      type: 'track',
+      userId: "peterpan",
+      type: "track",
       timestamp: '2021-10-05T15:30:35Z',
       properties: {
         checkout_id: 'fksdjfsdjfisjf9sdfjsd9f',
         order_id: '50314b8e9bcf000000000000',
         affiliation: 'Google Store',
-        total: 27.5,
-        subtotal: 22.5,
-        revenue: 25.0,
+        total: 27.50,
+        subtotal: 22.50,
+        revenue: 25.00,
         shipping: 3,
         tax: 2,
         discount: 2.5,
@@ -44,7 +45,7 @@ describe('ActablePredictive.sendTransactionEvent', () => {
             category: 'Games',
             url: 'https://www.example.com/product/path',
             image_url: 'https:///www.example.com/product/path.jpg',
-            coupon: 'FALLSALE20'
+            coupon: "FALLSALE20"
           },
           {
             product_id: '505bd76785ebb509fc183733',
@@ -56,22 +57,26 @@ describe('ActablePredictive.sendTransactionEvent', () => {
           }
         ]
       }
-    })
+    }
+    )
 
     const r = await testDestination.testAction('sendTransactionEvent', {
       event,
-      settings: { client_id: 'foo', client_secret: 'bar' },
-      useDefaultMappings: true
+      settings: { client_id: "foo", client_secret: "bar" },
+      useDefaultMappings: true,
     })
 
-    const recievedEvent = r[0].options.json as any
+    const recievedEvent = (r[0].options.json as any)
     expect(r.length).toBe(1)
     expect(recievedEvent.data[0]).toMatchObject({
       customer_id: 'peterpan',
       purchase_datetime: 1633447835,
-      stream_key: 'transaction',
-      product_column: '507f1f77bcf86cd799439011|505bd76785ebb509fc183733',
-      discount_code: 'FALLSALE20'
+      stream_key: "transaction",
+      product_column: "507f1f77bcf86cd799439011|505bd76785ebb509fc183733",
+      discount_code: "FALLSALE20"
     })
   })
 })
+
+
+
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/index.ts b/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/index.ts
index 518ca11c..d6c5b4f6 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/index.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendTransactionEvent/index.ts
@@ -31,12 +31,14 @@ function formatPurchasePayload(purchaseEvent: Payload) {
   }
 
   return {
-    ...omit(purchaseEvent, ['products', 'discount_code']),
-    product_column: productList.join('|'),
-    discount_code: codeList.join('|')
+    ...omit(purchaseEvent, ["products", "discount_code"]),
+    "product_column": productList.join("|"),
+    "discount_code": codeList.join("|")
   }
+
 }
 
+
 const action: ActionDefinition<Settings, Payload> = {
   title: 'Send Transaction Event',
   description: '',
@@ -51,54 +53,54 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     discount_code: {
-      type: 'string',
-      label: 'Discount Code',
-      description:
-        'Discount code, if any, used on purchase. Will be used in addition to per-product coupons in Segment v2commerce events spec.',
-      format: 'text',
+      type: "string",
+      label: "Discount Code",
+      description: "Discount code, if any, used on purchase. Will be used in addition to per-product coupons in Segment v2commerce events spec.",
+      format: "text",
       required: false
     },
     transaction_id: {
-      type: 'string',
-      label: 'Transaction ID',
-      description: 'Optional Identifier for transaction.',
-      format: 'text',
+      type: "string",
+      label: "Transaction ID",
+      description: "Optional Identifier for transaction.",
+      format: "text",
       required: false,
       default: { '@path': '$.properties.order_id' }
+
     },
     spend: {
-      type: 'number',
-      label: 'Amount',
-      description: 'Total order amount.',
-      format: 'text',
+      type: "number",
+      label: "Amount",
+      description: "Total order amount.",
+      format: "text",
       required: false,
       default: { '@path': '$.properties.total' }
     },
     products: {
-      type: 'object',
+      type: "object",
       multiple: true,
-      label: 'Products Purchased',
-      description:
-        'product(s) purchased in transaction. This value should be an array of objects which at the minimum contains a Product ID or SKU per-product.',
-      format: 'text',
+      label: "Products Purchased",
+      description: "product(s) purchased in transaction. This value should be an array of objects which at the minimum contains a Product ID or SKU per-product.",
+      format: "text",
       required: true,
       default: { '@path': '$.properties.products' }
+
     },
     purchase_datetime: {
-      type: 'datetime',
-      label: 'Timestamp',
-      description: 'timestamp of when transaction event occurred.',
-      format: 'date-time',
+      type: "datetime",
+      label: "Timestamp",
+      description: "timestamp of when transaction event occurred.",
+      format: "date-time",
       required: true,
       default: { '@path': '$.timestamp' }
     },
     stream_key: {
-      type: 'string',
-      format: 'text',
-      label: 'Stream Key',
-      description: 'Dataset label, should be left as default unless directed otherwise.',
+      type: "string",
+      format: "text",
+      label: "Stream Key",
+      description: "Dataset label, should be left as default unless directed otherwise.",
       required: true,
-      default: 'transaction'
+      default: "transaction"
     }
   },
   perform: (request, data) => {
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/__tests__/index.test.ts b/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/__tests__/index.test.ts
index 85a34250..bb4d7fa4 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/__tests__/index.test.ts
@@ -18,38 +18,42 @@ describe('ActablePredictive.sendWebEvent', () => {
   test('testWebEvent', async () => {
     setUpTest()
 
+
     const event = createTestEvent({
       type: 'track',
       userId: 'test-user-id',
       timestamp: '2021-10-05T15:30:35Z',
-      event: 'Cart Add',
+      event: "Cart Add",
       context: {
         campaign: {
-          name: 'springsale',
-          source: 'source_springsale',
-          medium: 'medium_springsale',
-          term: 'term_springsale',
-          content: 'content_springsale'
+          name: "springsale",
+          source: "source_springsale",
+          medium: "medium_springsale",
+          term: "term_springsale",
+          content: "content_springsale",
         }
       }
     })
 
     const r = await testDestination.testAction('sendWebEvent', {
       event,
-      settings: { client_id: 'foo', client_secret: 'bar' },
-      useDefaultMappings: true
+      settings: { client_id: "foo", client_secret: "bar" },
+      useDefaultMappings: true,
     })
 
-    const recievedEvent = r[0].options.json as any
+    const recievedEvent = (r[0].options.json as any)
     expect(r.length).toBe(1) // (no auth request)
     expect(recievedEvent.data[0]).toMatchObject({
       customer_id: 'test-user-id',
       datetime: 1633447835,
-      stream_key: 'web',
-      interaction_type: 'Cart Add',
-      utm_campaign: 'springsale',
-      utm_medium: 'medium_springsale',
-      utm_source: 'source_springsale'
+      stream_key: "web",
+      interaction_type: "Cart Add",
+      utm_campaign: "springsale",
+      utm_medium: "medium_springsale",
+      utm_source: "source_springsale",
     })
   })
 })
+
+
+
diff --git a/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/index.ts b/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/index.ts
index d5a159ec..cb763598 100644
--- a/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/index.ts
+++ b/packages/destination-actions/src/destinations/actable-predictive/sendWebEvent/index.ts
@@ -17,52 +17,53 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     },
     datetime: {
-      type: 'datetime',
-      format: 'date-time',
-      label: 'Event Timestamp',
-      description: 'Timestamp of event',
+      type: "datetime",
+      format: "date-time",
+      label: "Event Timestamp",
+      description: "Timestamp of event",
       required: true,
       default: { '@path': '$.timestamp' }
     },
     interaction_type: {
-      type: 'string',
-      format: 'text',
-      label: 'Event Type',
-      description: 'type of interaction (page view, add to cart, etc).',
+      type: "string",
+      format: "text",
+      label: "Event Type",
+      description: "type of interaction (page view, add to cart, etc).",
       required: true,
       default: { '@path': '$.event' }
+
     },
     utm_campaign: {
-      type: 'string',
-      format: 'text',
-      label: 'UTM Campaign',
-      description: 'UTM campaign parameter associated with event.',
+      type: "string",
+      format: "text",
+      label: "UTM Campaign",
+      description: "UTM campaign parameter associated with event.",
       required: false,
       default: { '@path': '$.context.campaign.name' }
     },
     utm_medium: {
-      type: 'string',
-      format: 'text',
-      label: 'UTM Medium',
-      description: 'UTM medium parameter associated with event.',
+      type: "string",
+      format: "text",
+      label: "UTM Medium",
+      description: "UTM medium parameter associated with event.",
       required: false,
       default: { '@path': '$.context.campaign.medium' }
     },
     utm_source: {
-      type: 'string',
-      format: 'text',
-      label: 'UTM Source',
-      description: 'UTM source parameter associated with event.',
+      type: "string",
+      format: "text",
+      label: "UTM Source",
+      description: "UTM source parameter associated with event.",
       required: false,
       default: { '@path': '$.context.campaign.source' }
     },
     stream_key: {
-      type: 'string',
-      format: 'text',
-      label: 'Stream Key',
-      description: 'Dataset label, should be left as default unless directed otherwise',
+      type: "string",
+      format: "text",
+      label: "Stream Key",
+      description: "Dataset label, should be left as default unless directed otherwise",
       required: true,
-      default: 'web'
+      default: "web"
     }
   },
   perform: (request, data) => {
diff --git a/packages/destination-actions/src/destinations/actions-bingads/functions.ts b/packages/destination-actions/src/destinations/actions-bingads/functions.ts
deleted file mode 100644
index e69de29b..00000000
diff --git a/packages/destination-actions/src/destinations/actions-bingads/generated-types.ts b/packages/destination-actions/src/destinations/actions-bingads/generated-types.ts
deleted file mode 100644
index 6608cb4b..00000000
--- a/packages/destination-actions/src/destinations/actions-bingads/generated-types.ts
+++ /dev/null
@@ -1,36 +0,0 @@
-// Generated file. DO NOT MODIFY IT BY HAND.
-
-export interface Settings {
-  /**
-   * ID of your Microsoft Bing Ads Account. This should be a 36-characters alpha-numeric string. **Required**
-   */
-  client_id?: string
-  /**
-   * Client Secret from your Azure Portal account registered app. **Required**
-   */
-  client_secret?: string
-  /**
-   * Redirect URI for user consent (https://login.microsoftonline.com/common/oauth2/nativeclient). **Required**
-   */
-  redirect_uri?: string
-  /**
-   * Scope. **Required**
-   */
-  scope?: string
-  /**
-   * Refresh Token. **Required**
-   */
-  refreshToken?: string
-  /**
-   * Customer Account ID. **Required**
-   */
-  customer_account_id?: string
-  /**
-   * Customer ID. **Required**
-   */
-  customer_id?: string
-  /**
-   * Developer Token. **Required**
-   */
-  developer_token?: string
-}
diff --git a/packages/destination-actions/src/destinations/actions-bingads/index.ts b/packages/destination-actions/src/destinations/actions-bingads/index.ts
deleted file mode 100644
index 15d3db22..00000000
--- a/packages/destination-actions/src/destinations/actions-bingads/index.ts
+++ /dev/null
@@ -1,108 +0,0 @@
-import type { DestinationDefinition } from '@segment/actions-core'
-import type { Settings } from './generated-types'
-
-import offlineConversions from './offlineConversions'
-
-interface RefreshTokenResponse {
-  access_token: string
-}
-
-const destination: DestinationDefinition<Settings> = {
-  name: 'Bingads',
-  slug: 'actions-bingads',
-  mode: 'cloud',
-
-  authentication: {
-    scheme: 'oauth2',
-    fields: {
-      client_id: {
-        label: 'Client ID',
-        description:
-          'ID of your Microsoft Bing Ads Account. This should be a 36-characters alpha-numeric string. **Required**',
-        type: 'string'
-      },
-      client_secret: {
-        label: 'Client Secret',
-        description: 'Client Secret from your Azure Portal account registered app. **Required**',
-        type: 'string'
-      },
-      redirect_uri: {
-        label: 'Redirect URI',
-        description:
-          'Redirect URI for user consent (https://login.microsoftonline.com/common/oauth2/nativeclient). **Required**',
-        type: 'string'
-      },
-      scope: {
-        label: 'Scope',
-        description: 'Scope. **Required**',
-        type: 'string'
-      },
-      refreshToken: {
-        label: 'Refresh Token',
-        description: 'Refresh Token. **Required**',
-        type: 'string'
-      },
-      customer_account_id: {
-        label: 'Customer Account ID',
-        description: 'Customer Account ID. **Required**',
-        type: 'string'
-      },
-      customer_id: {
-        label: 'Customer ID',
-        description: 'Customer ID. **Required**',
-        type: 'string'
-      },
-      developer_token: {
-        label: 'Developer Token',
-        description: 'Developer Token. **Required**',
-        type: 'string'
-      }
-    },
-    // testAuthentication: (request) => {
-    //   // Return a request that tests/validates the user's credentials.
-    //   // If you do not have a way to validate the authentication fields safely,
-    //   // you can remove the `testAuthentication` function, though discouraged.
-    //   return true
-    // },
-
-    refreshAccessToken: async (request, { auth }) => {
-      // refreshAccessToken: async (request, { auth, settings }) => {
-      // Return a request that refreshes the access_token if the API supports it
-      const baseUrl = 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
-      console.log(baseUrl)
-      const res = await request<RefreshTokenResponse>(`${baseUrl}`, {
-        method: 'POST',
-        body: new URLSearchParams({
-          refresh_token: auth.refreshToken,
-          client_id: auth.clientId,
-          client_secret: auth.clientSecret,
-          grant_type: 'refresh_token',
-          scope: 'openid offline_access https://ads.microsoft.com/msads.manage',
-          redirect_uri: 'https://login.microsoftonline.com/common/oauth2/nativeclient'
-        })
-      })
-      //console.log({ accessToken: res.data.access_token })
-      return { accessToken: res.data.access_token }
-    }
-
-    // extendRequest({ auth }) {
-    //   return {
-    //     headers: {
-    //       authorization: `Bearer ${auth?.accessToken}`
-    //     }
-    //   }
-    // }
-  },
-
-  // onDelete: async (request, { settings, payload }) => {
-  //   // Return a request that performs a GDPR delete for the provided Segment userId or anonymousId
-  //   // provided in the payload. If your destination does not support GDPR deletion you should not
-  //   // implement this function and should remove it completely.
-  // },
-
-  actions: {
-    offlineConversions
-  }
-}
-
-export default destination
diff --git a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/formatter.ts b/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/formatter.ts
deleted file mode 100644
index fc27ed91..00000000
--- a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/formatter.ts
+++ /dev/null
@@ -1,76 +0,0 @@
-import { fetch } from '@segment/actions-core'
-// @ts-ignore This is to bypass for testing purpose
-export function getAccessToken(mapping: {
-  refresh_token: string | undefined
-  grant_type: string | undefined
-  scope: string | undefined
-  redirect_uri: string | undefined
-  client_secret: string | undefined
-  client_id: string | undefined
-}) {
-  const endpoint = 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
-
-  // @ts-ignore This is to bypass for testing purpose
-  const uspCoded = new URLSearchParams({
-    client_id: mapping.client_id,
-    refresh_token: mapping.refresh_token,
-    scope: mapping.scope,
-    redirect_uri: mapping.redirect_uri,
-    grant_type: 'refresh_token',
-    client_secret: mapping.client_secret
-  })
-
-  try {
-    return fetch(endpoint, {
-      method: 'post',
-      headers: {
-        'Content-Type': 'application/x-www-form-urlencoded'
-      },
-      body: uspCoded
-    })
-      .then((response) => response.json())
-      .then((data) => {
-        return data
-      })
-
-    // return 'token';
-  } catch (error) {
-    // Retry on connection error
-    console.log(error.message)
-  }
-}
-
-// const getAccessToken = async (mapping: { refresh_token: string; grant_type: string; scope: string; redirect_uri: string; client_secret: string; client_id: string }) => {
-//   const endpoint = 'https://login.microsoftonline.com/common/oauth2/v2.0/token';
-//   const uspCoded = new URLSearchParams({
-//     // client_id: mapping.clientId,
-//     // // refresh_token: mapping.refreshToken,
-//     // scope: mapping.scope,
-//     // redirect_uri: mapping.redirectUri,
-//     // grant_type: 'refresh_token',
-//     // client_secret: mapping.clientSecret,
-//     // code: mapping.code
-//     'client_id': '93a71c20-5cd5-4791-a43c-a9ffb6c0b0d7',
-//     'scope': 'openid offline_access https://ads.microsoft.com/msads.manage',
-//     'redirect_uri': 'https://login.microsoftonline.com/common/oauth2/nativeclient',
-//     'grant_type': 'refresh_token',
-//     'client_secret': 'OnJ8Q~q6vhOeOz5EGUZ5wU0NGvFRKMT~aTD6Ua_w',
-//     'refresh_token': 'M.R3_BAY.-CRCfB46YwPp3guoVlhYGO1YrpyGM*a5KDDpnpC9wbGOd0JbvhrhQJ24*t3BAbXbdzk8y0bpglImddFaar3uy45C5SmD54YE1bvA3BtMi60bLS4jlyvTWe1OQHZYXDLmnrMab4WgD3AgSnEhmHYoVuCPfz!Jm*2mjkhDc!0J4i53u8bHI69OFQetqVq8jUzPd9n!io3CS6!HwuS5mKq*Sg6ZX0HSyTQGpQvGo4IrPjPxn3LnUR2vr5mvtzxdJZkH0TGM5HJd15KF*exE6gReE42Cjld32AJ!PgTlVtwsF48T8OVp*bG9suwAunXDG!sCSqq7a9biVkugwR4mwsuVtA8XVQXuCnfeN0AlCK1bq15mEkRw7lWlnmA0oaNyK4hp9jy!t5vgDSAaAmRsf2NMELmohPWt1IwOvNXYlXW8um5J2'
-//   });
-//
-//   let resp = fetch(endpoint, {
-//     method: 'post',
-//     headers: {
-//       'Content-Type': 'application/x-www-form-urlencoded'
-//     },
-//     body: uspCoded
-//   })
-//
-//   console.log('--------------', resp)
-//     //use string literals
-//     // let hostEmailJson = await hostEmailData.json();
-//     // return hostEmailJson;
-// }
-//
-// export default getAccessToken;
-//
diff --git a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/generated-types.ts b/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/generated-types.ts
deleted file mode 100644
index d4e86a20..00000000
--- a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/generated-types.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-// Generated file. DO NOT MODIFY IT BY HAND.
-
-export interface Payload {
-  /**
-   * Conversion Currency Code
-   */
-  ConversionCurrencyCode: string
-  /**
-   * Conversion Name
-   */
-  ConversionName: string
-  /**
-   * Conversion Time
-   */
-  ConversionTime: string
-  /**
-   * Conversion Value
-   */
-  ConversionValue: string
-  /**
-   * Microsoft Click Id
-   */
-  MicrosoftClickId: string
-}
diff --git a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/index.ts b/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/index.ts
deleted file mode 100644
index 07128944..00000000
--- a/packages/destination-actions/src/destinations/actions-bingads/offlineConversions/index.ts
+++ /dev/null
@@ -1,206 +0,0 @@
-import type { ActionDefinition } from '@segment/actions-core'
-import type { Settings } from '../generated-types'
-import type { Payload } from './generated-types'
-import { ModifiedResponse } from '@segment/actions-core'
-import { getAccessToken } from './formatter'
-
-let authenticationToken = 'XXXXXXXX' //accessToken here;
-
-const action: ActionDefinition<Settings, Payload> = {
-  title: 'Offline Conversions',
-  description: 'TODO',
-  fields: {
-    ConversionCurrencyCode: {
-      label: 'Conversion Currency Code',
-      description: 'Conversion Currency Code',
-      type: 'string',
-      required: true,
-      default: {
-        '@path': '$.properties.conversionCurrency'
-      }
-    },
-    ConversionName: {
-      label: 'Conversion Name',
-      description: 'Conversion Name',
-      type: 'string',
-      required: true,
-      default: {
-        '@path': '$.properties.conversionName'
-      }
-    },
-    ConversionTime: {
-      label: 'Conversion Time',
-      description: 'Conversion Time',
-      type: 'string',
-      required: true,
-      default: {
-        '@path': '$.properties.conversionTime'
-      }
-    },
-    ConversionValue: {
-      label: 'Conversion Value',
-      description: 'Conversion Value',
-      type: 'string',
-      required: true,
-      default: {
-        '@path': '$.properties.conversionValue'
-      }
-    },
-    MicrosoftClickId: {
-      label: 'Microsoft Click Id',
-      description: 'Microsoft Click Id',
-      type: 'string',
-      required: true,
-      default: {
-        '@path': '$.properties.msCId'
-      }
-    }
-    // client_id: {
-    //   label: 'Client ID',
-    //   description: 'Client ID',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // },
-    // scope: {
-    //   label: 'scope',
-    //   description: 'scope',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // },
-    // redirect_uri: {
-    //   label: 'redirect_uri',
-    //   description: 'redirect_uri',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // },
-    // grant_type: {
-    //   label: 'grant_type',
-    //   description: 'grant_type',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // },
-    // client_secret: {
-    //   label: 'client_secret',
-    //   description: 'client_secret',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // },
-    // refresh_token: {
-    //   label: 'refresh_token',
-    //   description: 'refresh_token',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // }
-    // code: {
-    //   label: 'code',
-    //   description: 'code',
-    //   type: 'string',
-    //   format: 'text',
-    //   required: true
-    // }
-  },
-  perform: async (request, data) => {
-    // console.log('Raw Data: ', data.rawData.properties)
-    // console.log('Payload: ', data.payload)
-
-    const response_data = await getAccessToken({
-      client_id: data.settings.client_id, //data.payload.client_id,
-      scope: data.settings.scope,
-      redirect_uri: data.settings.redirect_uri,
-      grant_type: 'refresh_token',
-      client_secret: data.settings.client_secret,
-      refresh_token: data.settings.refreshToken
-    })
-
-    authenticationToken = response_data.access_token
-    console.log('Access Token retrieved using Refresh Token ')
-    let conversionTime = data.payload.ConversionTime //|| data.rawData.properties.Conversion_Time
-    //this (if statement below) is custom code to convert payload timestamp to correct XML Soap format
-    //not needed if client is sending in correct format
-    if (conversionTime.includes('UTC')) {
-      const val2 = conversionTime.replace(' UTC', '')
-      conversionTime = val2.replace(' ', 'T')
-    }
-    const conversionCurrency = data.payload.ConversionCurrencyCode //|| data.rawData.properties.Conversion_Currency || 'USD'
-    const msCId = data.payload.MicrosoftClickId //|| data.rawData.properties.msCID
-    const conversionValue = data.payload.ConversionValue //|| data.rawData.properties.Conversion_Value
-    const conversionName = data.payload.ConversionName //|| data.rawData.properties.Conversion_Name
-    console.log('Conversion Goal: ', conversionName)
-    // this code is to switch to a second MS account based on need of client (all of this will move to settings for mapping)
-    // if (conversionName == 'CCRevenue') {
-    //   // account 2
-    //   authenticationToken = //accessToken here;
-    //   refreshToken = //refreshToken here;
-    //   msCode = //msCode here;
-    //   aId = //aid here;
-    // }
-    // let tokenResponse = {};
-    // tokenResponse = await fetchAccessTokenUsingRefreshToken(settings);
-    // authenticationToken = tokenResponse.access_token;
-    // Learn more at https://segment.com/docs/connections/spec/track/
-    const endpoint =
-      'https://campaign.api.bingads.microsoft.com/Api/Advertiser/CampaignManagement/V13/CampaignManagementService.svc?singleWsdl' // replace with your endpoint
-    // console.log(endpoint)
-    const sr =
-      '<s:Envelope xmlns:i="http://www.w3.org/2001/XMLSchema-instance" ' +
-      'xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">' +
-      '<s:Header xmlns="https://bingads.microsoft.com/CampaignManagement/v13">' +
-      '<Action mustUnderstand="1">ApplyOfflineConversions</Action>' +
-      '<AuthenticationToken i:nil="false">' +
-      authenticationToken +
-      '</AuthenticationToken>' +
-      '<CustomerAccountId i:nil="false">' +
-      data.settings.customer_account_id +
-      '</CustomerAccountId>' +
-      '<CustomerId i:nil="false">' +
-      data.settings.customer_id +
-      '</CustomerId>' +
-      '<DeveloperToken i:nil="false">' +
-      data.settings.developer_token +
-      '</DeveloperToken>' +
-      '</s:Header>' +
-      '<s:Body>' +
-      '<ApplyOfflineConversionsRequest xmlns="https://bingads.microsoft.com/CampaignManagement/v13">' +
-      '<OfflineConversions i:nil="false"><OfflineConversion><ConversionCurrencyCode i:nil="false">' +
-      conversionCurrency +
-      '</ConversionCurrencyCode>' +
-      '<ConversionName i:nil="false">' +
-      conversionName +
-      '</ConversionName>' +
-      '<ConversionTime>' +
-      conversionTime +
-      '</ConversionTime>' +
-      '<ConversionValue i:nil="false">' +
-      conversionValue +
-      '</ConversionValue>' +
-      '<MicrosoftClickId i:nil="false">' +
-      msCId +
-      '</MicrosoftClickId></OfflineConversion></OfflineConversions>' +
-      '</ApplyOfflineConversionsRequest></s:Body></s:Envelope>'
-
-    try {
-      const response: ModifiedResponse<unknown> = await request(endpoint, {
-        method: 'post',
-        headers: {
-          SOAPAction: 'ApplyOfflineConversions',
-          'Content-Type': 'text/xml;charset=utf-8'
-        },
-        body: sr,
-        redirect: 'follow'
-      })
-      console.log('***** Conversion Attributed successfully! *****')
-      console.log(response)
-    } catch (error) {
-      // Retry on connection error
-      console.log(error.message)
-    }
-  }
-}
-
-export default action
diff --git a/packages/destination-actions/src/destinations/adobe-target/adobeTarget_operations.ts b/packages/destination-actions/src/destinations/adobe-target/adobeTarget_operations.ts
index 00a4dcd8..0b8e0b57 100644
--- a/packages/destination-actions/src/destinations/adobe-target/adobeTarget_operations.ts
+++ b/packages/destination-actions/src/destinations/adobe-target/adobeTarget_operations.ts
@@ -41,8 +41,9 @@ export default class AdobeTarget {
     } else {
       const traits = getNestedObjects(this.traits)
       if (traits) {
-        const requestUrl = `https://${this.clientCode}.tt.omtrdc.net/m2/${this.clientCode
-          }/profile/update?mbox3rdPartyId=${this.userId}&${objectToQueryString(traits)}`
+        const requestUrl = `https://${this.clientCode}.tt.omtrdc.net/m2/${
+          this.clientCode
+        }/profile/update?mbox3rdPartyId=${this.userId}&${objectToQueryString(traits)}`
 
         return this.request(requestUrl, {
           method: 'POST'
@@ -67,14 +68,14 @@ export default class AdobeTarget {
         // If we throw a 404, Centrifuge will discard the job and it will never be retried. Thereforce, we are throwing a 500.
         // Unless the API is failing, errors from this endpoint will reference that the user profile does not exist.
         // The 500 error code also works in Centrifuge in the scenario where the API is down. Hence, its choice as a trigger for a retry.
-        const errorCode = error.message == 'Forbidden' ? 403 : 500
+        const errorCode = error.message == 'Forbidden' ? '403' : '500'
 
-        if (errorCode == 500) {
+        if (errorCode == '500') {
           // For now, we will keep track of the number of times we run this flow.
           statsContext?.statsClient.incr('actions-adobe-target.profile-not-found', 1, statsContext.tags)
         }
 
-        throw new IntegrationError(error.message, error.stack, errorCode)
+        throw new IntegrationError(error.message, errorCode)
       }
     }
 
diff --git a/packages/destination-actions/src/destinations/amplitude/__tests__/amplitude.test.ts b/packages/destination-actions/src/destinations/amplitude/__tests__/amplitude.test.ts
index d05b694d..d336ede3 100644
--- a/packages/destination-actions/src/destinations/amplitude/__tests__/amplitude.test.ts
+++ b/packages/destination-actions/src/destinations/amplitude/__tests__/amplitude.test.ts
@@ -615,7 +615,7 @@ describe('Amplitude', () => {
             },
             {
               revenue: 1_999,
-              productId: 'Bowflex Treadmill 8'
+              productId: 'Bowflex Treadmill 8',
             },
             {
               productId: 'Bowflex Treadmill 4',
@@ -623,7 +623,7 @@ describe('Amplitude', () => {
             },
             {
               quantity: 2,
-              productId: 'Bowflex Treadmill 2'
+              productId: 'Bowflex Treadmill 2',
             }
           ]
         }
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/__snapshots__/snapshot.test.ts.snap
new file mode 100644
index 00000000..db634285
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -0,0 +1,19 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Testing snapshot for actions-braze-cohorts destination: syncAudiences action - all fields 1`] = `
+Object {
+  "client_secret": "f[XBoj@QfnIWlYY",
+  "cohort_id": "f[XBoj@QfnIWlYY",
+  "created_at": "f[XBoj@QfnIWlYY",
+  "name": "f[XBoj@QfnIWlYY",
+}
+`;
+
+exports[`Testing snapshot for actions-braze-cohorts destination: syncAudiences action - required fields 1`] = `
+Object {
+  "client_secret": "f[XBoj@QfnIWlYY",
+  "cohort_id": "f[XBoj@QfnIWlYY",
+  "created_at": "f[XBoj@QfnIWlYY",
+  "name": "f[XBoj@QfnIWlYY",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/__tests__/index.test.ts b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/index.test.ts
new file mode 100644
index 00000000..38ef0007
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/index.test.ts
@@ -0,0 +1,35 @@
+import nock from 'nock'
+import { createTestIntegration } from '@segment/actions-core'
+import Definition from '../index'
+
+const testDestination = createTestIntegration(Definition)
+
+describe('Braze Cohorts', () => {
+  describe('testAuthentication', () => {
+    it('should throw an error in case of invalid client secret key', async () => {
+      nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(401, {})
+
+      const authData = {
+        settings: {
+          endpoint: 'https://rest.iad-01.braze.com',
+          client_secret: 'Invalid_client_secret_key'
+        }
+      }
+
+      await expect(testDestination.testAuthentication(authData.settings)).rejects.toThrowError()
+    })
+
+    it('should not throw an error when settings is appropriate and api gives sucess', async () => {
+      nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+      const authData = {
+        settings: {
+          endpoint: 'https://rest.iad-01.braze.com',
+          client_secret: 'valid_client_secret_key'
+        }
+      }
+
+      await expect(testDestination.testAuthentication(authData.settings)).resolves.not.toThrowError()
+    })
+  })
+})
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/__tests__/snapshot.test.ts b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/snapshot.test.ts
new file mode 100644
index 00000000..2713878b
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/__tests__/snapshot.test.ts
@@ -0,0 +1,95 @@
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { generateTestData } from '../../../lib/test-data'
+import destination from '../index'
+import nock from 'nock'
+
+const testDestination = createTestIntegration(destination)
+const destinationSlug = 'actions-braze-cohorts'
+
+describe(`Testing snapshot for ${destinationSlug} destination:`, () => {
+  for (const actionSlug in destination.actions) {
+    it(`${actionSlug} action - required fields`, async () => {
+      const seedName = `${destinationSlug}#${actionSlug}`
+      const action = destination.actions[actionSlug]
+      const [eventData, settingsData] = generateTestData(seedName, destination, action, true)
+
+      nock(/.*/).persist().get(/.*/).reply(200)
+      nock(/.*/).persist().post(/.*/).reply(200)
+      nock(/.*/).persist().put(/.*/).reply(200)
+
+      const event = createTestEvent({
+        properties: eventData
+      })
+      const stateContext = {
+        getRequestContext: (_key: string): any => {},
+        setResponseContext: (
+          _key: string,
+          _value: string,
+          _ttl: { hour?: number; minute?: number; second?: number }
+        ): void => {}
+      }
+
+      const responses = await testDestination.testAction(actionSlug, {
+        event: event,
+        mapping: event.properties,
+        settings: settingsData,
+        auth: undefined,
+        stateContext
+      })
+
+      const request = responses[0].request
+      const rawBody = await request.text()
+
+      try {
+        const json = JSON.parse(rawBody)
+        expect(json).toMatchSnapshot()
+        return
+      } catch (err) {
+        expect(rawBody).toMatchSnapshot()
+      }
+
+      expect(request.headers).toMatchSnapshot()
+    })
+
+    it(`${actionSlug} action - all fields`, async () => {
+      const seedName = `${destinationSlug}#${actionSlug}`
+      const action = destination.actions[actionSlug]
+      const [eventData, settingsData] = generateTestData(seedName, destination, action, false)
+
+      nock(/.*/).persist().get(/.*/).reply(200)
+      nock(/.*/).persist().post(/.*/).reply(200)
+      nock(/.*/).persist().put(/.*/).reply(200)
+
+      const event = createTestEvent({
+        properties: eventData
+      })
+      const stateContext = {
+        getRequestContext: (_key: string): any => {},
+        setResponseContext: (
+          _key: string,
+          _value: string,
+          _ttl: { hour?: number; minute?: number; second?: number }
+        ): void => {}
+      }
+
+      const responses = await testDestination.testAction(actionSlug, {
+        event: event,
+        mapping: event.properties,
+        settings: settingsData,
+        auth: undefined,
+        stateContext
+      })
+
+      const request = responses[0].request
+      const rawBody = await request.text()
+
+      try {
+        const json = JSON.parse(rawBody)
+        expect(json).toMatchSnapshot()
+        return
+      } catch (err) {
+        expect(rawBody).toMatchSnapshot()
+      }
+    })
+  }
+})
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/api/index.ts b/packages/destination-actions/src/destinations/braze-cohorts/api/index.ts
new file mode 100644
index 00000000..012229a0
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/api/index.ts
@@ -0,0 +1,51 @@
+import type { RequestClient, ModifiedResponse } from '@segment/actions-core'
+import type { Settings } from '../generated-types'
+import type { Payload } from '../syncAudiences/generated-types'
+import { CohortChanges } from '../braze-cohorts-types'
+
+interface APIResponse {
+  message: string
+}
+
+export class SyncAudiences {
+  request: RequestClient
+  partnerApiKey: String
+
+  constructor(request: RequestClient, settings: Settings) {
+    this.request = request
+    this.partnerApiKey = (
+      settings.endpoint.includes('eu')
+        ? process.env.BRAZE_COHORTS_PARTNER_API_KEY_EU
+        : process.env.BRAZE_COHORTS_PARTNER_API_KEY_US
+    ) as String
+  }
+
+  async createCohort(settings: Settings, payload: Payload): Promise<ModifiedResponse<APIResponse>> {
+    return this.request(`${settings.endpoint}/partners/segment/cohorts`, {
+      method: 'POST',
+      json: {
+        partner_api_key: this.partnerApiKey,
+        client_secret: settings.client_secret,
+        name: payload?.cohort_name,
+        cohort_id: payload?.cohort_id,
+        created_at: payload?.time
+      }
+    })
+  }
+
+  async batchUpdate(
+    settings: Settings,
+    cohort_id: string,
+    cohortChanges: Array<CohortChanges>
+  ): Promise<ModifiedResponse> {
+    return this.request(`${settings.endpoint}/partners/segment/cohorts/users`, {
+      method: 'POST',
+      json: {
+        partner_api_key: this.partnerApiKey,
+        client_secret: settings.client_secret,
+        cohort_id: cohort_id,
+        cohort_changes: cohortChanges
+      }
+    })
+  }
+}
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/braze-cohorts-types.ts b/packages/destination-actions/src/destinations/braze-cohorts/braze-cohorts-types.ts
new file mode 100644
index 00000000..2d881478
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/braze-cohorts-types.ts
@@ -0,0 +1,11 @@
+export interface UserAlias {
+  alias_name: string
+  alias_label: string
+}
+
+export interface CohortChanges {
+  user_ids?: Array<string>
+  device_ids?: Array<string>
+  aliases?: Array<UserAlias>
+  should_remove?: boolean
+}
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/generated-types.ts b/packages/destination-actions/src/destinations/braze-cohorts/generated-types.ts
new file mode 100644
index 00000000..2ee61116
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/generated-types.ts
@@ -0,0 +1,12 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Settings {
+  /**
+   * Data Import Key for the client whose cohort this belongs to. Also known as customer key.
+   */
+  client_secret: string
+  /**
+   * Your Braze REST endpoint. [See more details](https://www.braze.com/docs/api/basics/#endpoints)
+   */
+  endpoint: string
+}
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/index.ts b/packages/destination-actions/src/destinations/braze-cohorts/index.ts
new file mode 100644
index 00000000..4e20e7c4
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/index.ts
@@ -0,0 +1,52 @@
+import type { DestinationDefinition } from '@segment/actions-core'
+import type { Settings } from './generated-types'
+import { CohortChanges } from './braze-cohorts-types'
+import { SyncAudiences } from './api/index'
+import syncAudiences from './syncAudiences'
+
+const destination: DestinationDefinition<Settings> = {
+  name: 'Braze Cohorts',
+  slug: 'actions-braze-cohorts',
+  mode: 'cloud',
+  authentication: {
+    scheme: 'custom',
+    fields: {
+      client_secret: {
+        label: 'Client Secret key',
+        description: 'Data Import Key for the client whose cohort this belongs to. Also known as customer key.',
+        type: 'password',
+        required: true
+      },
+      endpoint: {
+        label: 'REST Endpoint',
+        description: 'Your Braze REST endpoint. [See more details](https://www.braze.com/docs/api/basics/#endpoints)',
+        type: 'string',
+        format: 'uri',
+        choices: [
+          { label: 'US-01	(https://dashboard-01.braze.com)', value: 'https://rest.iad-01.braze.com' },
+          { label: 'US-02	(https://dashboard-02.braze.com)', value: 'https://rest.iad-02.braze.com' },
+          { label: 'US-03	(https://dashboard-03.braze.com)', value: 'https://rest.iad-03.braze.com' },
+          { label: 'US-04	(https://dashboard-04.braze.com)', value: 'https://rest.iad-04.braze.com' },
+          { label: 'US-05	(https://dashboard-05.braze.com)', value: 'https://rest.iad-05.braze.com' },
+          { label: 'US-06	(https://dashboard-06.braze.com)', value: 'https://rest.iad-06.braze.com' },
+          { label: 'US-08	(https://dashboard-08.braze.com)', value: 'https://rest.iad-08.braze.com' },
+          { label: 'EU-01	(https://dashboard-01.braze.eu)', value: 'https://rest.fra-01.braze.eu' },
+          { label: 'EU-02	(https://dashboard-02.braze.eu)', value: 'https://rest.fra-02.braze.eu' }
+        ],
+        default: 'https://rest.iad-01.braze.com',
+        required: true
+      }
+    },
+    testAuthentication: async (request, { settings }) => {
+      const syncAudiencesApiClient: SyncAudiences = new SyncAudiences(request, settings)
+      const cohort_id = 'will_add_in_constant'
+      const cohortChanges: Array<CohortChanges> = []
+      return await syncAudiencesApiClient.batchUpdate(settings, cohort_id, cohortChanges)
+    }
+  },
+  actions: {
+    syncAudiences
+  }
+}
+
+export default destination
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/index.test.ts.snap b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/index.test.ts.snap
new file mode 100644
index 00000000..2197cb30
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/index.test.ts.snap
@@ -0,0 +1,234 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`BrazeCohorts.syncAudiences should add user to braze when event_properties is set to true 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should add user to braze when event_properties is set to true 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give priority in a order like userId,deviceId and then UserAlias,if it is provided 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give priority in a order like userId,deviceId and then UserAlias,if it is provided 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give priority to userAlias,if userId and deviceId both are not provided 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give priority to userAlias,if userId and deviceId both are not provided 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [
+        Object {
+          "alias_label": "test@twilio.com",
+          "alias_name": "email",
+        },
+      ],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give second priority to deviceId ,if userId is not provided 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should give second priority to deviceId ,if userId is not provided 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [
+        "1234567",
+      ],
+      "should_remove": true,
+      "user_ids": Array [],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should hit create cohort api when cohort_name available in stateContext is not matching with computation key 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should hit create cohort api when cohort_name available in stateContext is not matching with computation key 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should not hit create cohort api when cohort_name is available in state context is matching with computation key 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should not throw an error even if payload doesn't have userId,device_id,user_alias 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should remove user to braze when event_properties set to false 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should remove user to braze when event_properties set to false 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should work with batch events 1`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "created_at": "2022-12-01T17:40:04.055Z",
+  "name": "j_o_jons__step_1_ns3i7",
+  "partner_api_key": undefined,
+}
+`;
+
+exports[`BrazeCohorts.syncAudiences should work with batch events 2`] = `
+Object {
+  "client_secret": "valid_client_secret_key",
+  "cohort_changes": Array [
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "user_ids": Array [
+        "w8KWCsdTxe1Ydaf3s62UMc",
+      ],
+    },
+    Object {
+      "aliases": Array [],
+      "device_ids": Array [],
+      "should_remove": true,
+      "user_ids": Array [
+        "user1234",
+      ],
+    },
+  ],
+  "cohort_id": "aud_23WNzkzsTS3ydnKz5H71SEhMxls",
+  "partner_api_key": undefined,
+}
+`;
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/snapshot.test.ts.snap
new file mode 100644
index 00000000..5083c435
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -0,0 +1,19 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Testing snapshot for BrazeCohorts's syncAudiences destination action: all fields 1`] = `
+Object {
+  "client_secret": "qVsBJ0Y4w",
+  "cohort_id": "qVsBJ0Y4w",
+  "created_at": "qVsBJ0Y4w",
+  "name": "qVsBJ0Y4w",
+}
+`;
+
+exports[`Testing snapshot for BrazeCohorts's syncAudiences destination action: required fields 1`] = `
+Object {
+  "client_secret": "qVsBJ0Y4w",
+  "cohort_id": "qVsBJ0Y4w",
+  "created_at": "qVsBJ0Y4w",
+  "name": "qVsBJ0Y4w",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/index.test.ts b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/index.test.ts
new file mode 100644
index 00000000..eb330b34
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/index.test.ts
@@ -0,0 +1,480 @@
+import nock from 'nock'
+import { createTestIntegration, SegmentEvent, createTestEvent } from '@segment/actions-core'
+import Destination from '../../index'
+const timestamp = '2022-12-01T17:40:04.055Z'
+const testDestination = createTestIntegration(Destination)
+const event = {
+  context: {
+    personas: {
+      computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+      computation_key: 'j_o_jons__step_1_ns3i7'
+    },
+    traits: {
+      email: 'test@twilio.com'
+    },
+    device: {
+      id: '1234567'
+    }
+  },
+  userId: 'w8KWCsdTxe1Ydaf3s62UMc',
+  timestamp: timestamp
+}
+
+const mapping = {
+  personas_audience_key: 'j_o_jons__step_1_ns3i7',
+  user_alias: {
+    alias_name: 'email',
+    alias_label: {
+      '@path': '$.context.traits.email'
+    }
+  },
+  device_id: {
+    '@path': '$.context.device.id'
+  }
+}
+
+describe('BrazeCohorts.syncAudiences', () => {
+  it('should throw an error if `personas_audience_key` field does not match the `personas.computation_key` field', async () => {
+    await expect(
+      testDestination.testAction('syncAudiences', {
+        event: {
+          ...event,
+          properties: {
+            audience_key: 'j_o_jons__step_1_ns3i7',
+            j_o_jons__step_1_ns3i7: true
+          }
+        },
+        settings: {
+          endpoint: 'https://rest.iad-01.braze.com',
+          client_secret: 'valid_client_secret_key'
+        },
+        useDefaultMappings: true,
+        mapping: {
+          personas_audience_key: 'some_hardcoded_value'
+        }
+      })
+    ).rejects.toThrowError('The value of `personas computation key` and `personas_audience_key` must match.')
+  })
+
+  it("should not throw an error even if payload doesn't have userId,device_id,user_alias", async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        properties: {
+          audience_key: 'j_o_jons__step_1_ns3i7',
+          j_o_jons__step_1_ns3i7: true
+        },
+        context: {
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          }
+        },
+        timestamp: timestamp
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: false,
+      mapping: {
+        enable_batching: true,
+        cohort_id: {
+          '@path': '$.context.personas.computation_id'
+        },
+        cohort_name: {
+          '@path': '$.context.personas.computation_key'
+        },
+        time: {
+          '@path': '$.timestamp'
+        },
+        event_properties: {
+          '@if': {
+            exists: { '@path': '$.properties' },
+            then: { '@path': '$.properties' },
+            else: { '@path': '$.traits' }
+          }
+        },
+        personas_audience_key: 'j_o_jons__step_1_ns3i7'
+      }
+    })
+    expect(responses.length).toBe(1)
+    expect(responses[0].status).toBe(201)
+    expect(responses[0].options.json).toMatchSnapshot()
+  })
+
+  it('should give priority in a order like userId,deviceId and then UserAlias,if it is provided', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        ...event,
+        traits: {
+          j_o_jons__step_1_ns3i7: true
+        }
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: ['w8KWCsdTxe1Ydaf3s62UMc'],
+          aliases: [],
+          device_ids: []
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should give second priority to deviceId ,if userId is not provided', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        context: {
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          },
+          traits: {
+            email: 'test@twilio.com'
+          },
+          device: {
+            id: '1234567'
+          }
+        },
+        traits: {
+          j_o_jons__step_1_ns3i7: true
+        },
+        timestamp: timestamp
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: false,
+      mapping: {
+        enable_batching: true,
+        cohort_id: {
+          '@path': '$.context.personas.computation_id'
+        },
+        cohort_name: {
+          '@path': '$.context.personas.computation_key'
+        },
+        time: {
+          '@path': '$.timestamp'
+        },
+        event_properties: {
+          '@if': {
+            exists: { '@path': '$.properties' },
+            then: { '@path': '$.properties' },
+            else: { '@path': '$.traits' }
+          }
+        },
+        ...mapping
+      }
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: [],
+          aliases: [],
+          device_ids: ['1234567']
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should give priority to userAlias,if userId and deviceId both are not provided', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        context: {
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          },
+          traits: {
+            email: 'test@twilio.com'
+          }
+        },
+        traits: {
+          j_o_jons__step_1_ns3i7: true
+        },
+        timestamp: timestamp
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: false,
+      mapping: {
+        enable_batching: true,
+        cohort_id: {
+          '@path': '$.context.personas.computation_id'
+        },
+        cohort_name: {
+          '@path': '$.context.personas.computation_key'
+        },
+        time: {
+          '@path': '$.timestamp'
+        },
+        event_properties: {
+          '@if': {
+            exists: { '@path': '$.properties' },
+            then: { '@path': '$.properties' },
+            else: { '@path': '$.traits' }
+          }
+        },
+        ...mapping
+      }
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: [],
+          aliases: [
+            {
+              alias_label: 'test@twilio.com',
+              alias_name: 'email'
+            }
+          ],
+          device_ids: []
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should add user to braze when event_properties is set to true', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        ...event,
+        properties: {
+          audience_key: 'j_o_jons__step_1_ns3i7',
+          j_o_jons__step_1_ns3i7: true
+        }
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: ['w8KWCsdTxe1Ydaf3s62UMc'],
+          device_ids: [],
+          aliases: []
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should remove user to braze when event_properties set to false', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        ...event,
+        traits: {
+          j_o_jons__step_1_ns3i7: false
+        }
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: ['w8KWCsdTxe1Ydaf3s62UMc'],
+          device_ids: [],
+          aliases: [],
+          should_remove: true
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should not hit create cohort api when cohort_name is available in state context is matching with computation key', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        ...event,
+        context: {
+          cohort_name: 'j_o_jons__step_1_ns3i7',
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          },
+          traits: {
+            email: 'test@twilio.com'
+          }
+        }
+      },
+      stateContext: {
+        getRequestContext: (_key: string): any => 'j_o_jons__step_1_ns3i7',
+        setResponseContext: (
+          _key: string,
+          _value: string,
+          _ttl: { hour?: number; minute?: number; second?: number }
+        ): void => {}
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping
+    })
+
+    expect(responses.length).toBe(1)
+    expect(responses[0].status).toBe(201)
+    expect(responses[0].options.json).toMatchSnapshot()
+  })
+
+  it('should hit create cohort api when cohort_name available in stateContext is not matching with computation key', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+
+    const responses = await testDestination.testAction('syncAudiences', {
+      event: {
+        ...event,
+        context: {
+          cohort_name: 'j_o_jons__step_1_ns3i7',
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          },
+          traits: {
+            email: 'test@twilio.com'
+          }
+        }
+      },
+      stateContext: {
+        getRequestContext: (_key: string): any => 'different_cohort_name',
+        setResponseContext: (
+          _key: string,
+          _value: string,
+          _ttl: { hour?: number; minute?: number; second?: number }
+        ): void => {}
+      },
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping
+    })
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+
+  it('should work with batch events', async () => {
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts').reply(201, {})
+    nock('https://rest.iad-01.braze.com').post('/partners/segment/cohorts/users').reply(201, {})
+    const events: SegmentEvent[] = [
+      createTestEvent({
+        ...event,
+        properties: {
+          audience_key: 'j_o_jons__step_1_ns3i7',
+          j_o_jons__step_1_ns3i7: true
+        }
+      }),
+      createTestEvent({
+        context: {
+          personas: {
+            computation_id: 'aud_23WNzkzsTS3ydnKz5H71SEhMxls',
+            computation_key: 'j_o_jons__step_1_ns3i7'
+          }
+        },
+        properties: {
+          audience_key: 'j_o_jons__step_1_ns3i7',
+          j_o_jons__step_1_ns3i7: false
+        },
+        timestamp: timestamp
+      })
+    ]
+
+    const responses = await testDestination.testBatchAction('syncAudiences', {
+      events,
+      settings: {
+        endpoint: 'https://rest.iad-01.braze.com',
+        client_secret: 'valid_client_secret_key'
+      },
+      useDefaultMappings: true,
+      mapping: {
+        personas_audience_key: 'j_o_jons__step_1_ns3i7'
+      }
+    })
+
+    expect(responses.length).toBe(2)
+    expect(responses[0].status).toBe(201)
+    expect(responses[1].status).toBe(201)
+    expect(responses[1].options.json).toMatchObject({
+      cohort_changes: expect.arrayContaining([
+        expect.objectContaining({
+          user_ids: ['w8KWCsdTxe1Ydaf3s62UMc'],
+          aliases: [],
+          device_ids: []
+        }),
+        expect.objectContaining({
+          user_ids: ['user1234'],
+          aliases: [],
+          device_ids: [],
+          should_remove: true
+        })
+      ])
+    })
+    expect(responses[0].options.json).toMatchSnapshot()
+    expect(responses[1].options.json).toMatchSnapshot()
+  })
+})
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/snapshot.test.ts b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/snapshot.test.ts
new file mode 100644
index 00000000..9786319c
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/__tests__/snapshot.test.ts
@@ -0,0 +1,93 @@
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { generateTestData } from '../../../../lib/test-data'
+import destination from '../../index'
+import nock from 'nock'
+
+const testDestination = createTestIntegration(destination)
+const actionSlug = 'syncAudiences'
+const destinationSlug = 'BrazeCohorts'
+const seedName = `${destinationSlug}#${actionSlug}`
+
+describe(`Testing snapshot for ${destinationSlug}'s ${actionSlug} destination action:`, () => {
+  it('required fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, true)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+
+    const stateContext = {
+      getRequestContext: (_key: string): any => {},
+      setResponseContext: (
+        _key: string,
+        _value: string,
+        _ttl: { hour?: number; minute?: number; second?: number }
+      ): void => {}
+    }
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: settingsData,
+      auth: undefined,
+      stateContext
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+
+    expect(request.headers).toMatchSnapshot()
+  })
+
+  it('all fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, false)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+    const stateContext = {
+      getRequestContext: (_key: string): any => {},
+      setResponseContext: (
+        _key: string,
+        _value: string,
+        _ttl: { hour?: number; minute?: number; second?: number }
+      ): void => {}
+    }
+
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: settingsData,
+      auth: undefined,
+      stateContext
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+  })
+})
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/generated-types.ts b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/generated-types.ts
new file mode 100644
index 00000000..d48c2e9f
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/generated-types.ts
@@ -0,0 +1,45 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Payload {
+  /**
+   * The external_id serves as a unique user identifier for whom you are submitting data. This identifier should be the same as the one you set in the Braze SDK in order to avoid creating multiple profiles for the same user.
+   */
+  external_id?: string
+  /**
+   * A user alias object. See [the docs](https://www.braze.com/docs/api/objects_filters/user_alias_object/).
+   */
+  user_alias?: {
+    alias_name: string
+    alias_label: string
+  }
+  /**
+   * The unique device Identifier
+   */
+  device_id?: string
+  /**
+   * The Cohort Identifier
+   */
+  cohort_id: string
+  /**
+   * The name of Cohort
+   */
+  cohort_name: string
+  /**
+   * Enable batching of requests to the Braze cohorts.
+   */
+  enable_batching?: boolean
+  /**
+   * The `audience_key` of the Engage audience you want to sync to Braze Cohorts. This value must be a hard-coded string variable, e.g. `personas_test_audience`, in order for batching to work properly.
+   */
+  personas_audience_key: string
+  /**
+   * Properties of the event
+   */
+  event_properties: {
+    [k: string]: unknown
+  }
+  /**
+   * When the event occurred.
+   */
+  time: string
+}
diff --git a/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/index.ts b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/index.ts
new file mode 100644
index 00000000..29b3404d
--- /dev/null
+++ b/packages/destination-actions/src/destinations/braze-cohorts/syncAudiences/index.ts
@@ -0,0 +1,183 @@
+import { ActionDefinition, RequestClient, IntegrationError } from '@segment/actions-core'
+import type { Settings } from '../generated-types'
+import type { Payload } from './generated-types'
+import { SyncAudiences } from '../api'
+import { CohortChanges } from '../braze-cohorts-types'
+import { StateContext } from '@segment/actions-core/src/destination-kit'
+import isEmpty from 'lodash/isEmpty'
+
+const action: ActionDefinition<Settings, Payload> = {
+  title: 'Sync Audience',
+  description: 'Record custom events in Braze',
+  defaultSubscription: 'event = "Audience Entered" or event = "Audience Exited"',
+  fields: {
+    external_id: {
+      label: 'External User ID',
+      description:
+        'The external_id serves as a unique user identifier for whom you are submitting data. This identifier should be the same as the one you set in the Braze SDK in order to avoid creating multiple profiles for the same user.',
+      type: 'string',
+      default: {
+        '@path': '$.userId'
+      }
+    },
+    user_alias: {
+      label: 'User Alias Object',
+      description:
+        'A user alias object. See [the docs](https://www.braze.com/docs/api/objects_filters/user_alias_object/).',
+      type: 'object',
+      properties: {
+        alias_name: {
+          label: 'Alias Name',
+          type: 'string',
+          required: true
+        },
+        alias_label: {
+          label: 'Alias Label',
+          type: 'string',
+          required: true
+        }
+      }
+    },
+    device_id: {
+      label: 'Device ID',
+      description: 'The unique device Identifier',
+      type: 'string'
+    },
+    cohort_id: {
+      label: 'Cohort ID',
+      description: 'The Cohort Identifier',
+      type: 'hidden',
+      required: true,
+      default: {
+        '@path': '$.context.personas.computation_id'
+      }
+    },
+    cohort_name: {
+      label: 'Cohort Name',
+      description: 'The name of Cohort',
+      type: 'hidden',
+      required: true,
+      default: {
+        '@path': '$.context.personas.computation_key'
+      }
+    },
+    enable_batching: {
+      label: 'Enable Batching',
+      description: 'Enable batching of requests to the Braze cohorts.',
+      type: 'boolean',
+      default: true
+    },
+    personas_audience_key: {
+      label: 'Segment Engage Audience Key',
+      description:
+        'The `audience_key` of the Engage audience you want to sync to Braze Cohorts. This value must be a hard-coded string variable, e.g. `personas_test_audience`, in order for batching to work properly.',
+      type: 'string',
+      required: true
+    },
+    event_properties: {
+      label: 'Event Properties',
+      description: 'Properties of the event',
+      type: 'object',
+      required: true,
+      default: {
+        '@if': {
+          exists: { '@path': '$.properties' },
+          then: { '@path': '$.properties' },
+          else: { '@path': '$.traits' }
+        }
+      }
+    },
+    time: {
+      label: 'Time',
+      description: 'When the event occurred.',
+      type: 'hidden',
+      required: true,
+      default: {
+        '@path': '$.timestamp'
+      }
+    }
+  },
+  perform: async (request, { settings, payload, stateContext }) => {
+    return processPayload(request, settings, [payload], stateContext)
+  },
+  performBatch: async (request, { settings, payload, stateContext }) => {
+    return processPayload(request, settings, payload, stateContext)
+  }
+}
+async function processPayload(
+  request: RequestClient,
+  settings: Settings,
+  payloads: Payload[],
+  stateContext?: StateContext
+) {
+  validate(payloads)
+  const syncAudiencesApiClient: SyncAudiences = new SyncAudiences(request, settings)
+  const { cohort_name, cohort_id } = payloads[0]
+  const cohortChanges: Array<CohortChanges> = []
+
+  if (stateContext?.getRequestContext?.('cohort_name') != cohort_name) {
+    await syncAudiencesApiClient.createCohort(settings, payloads[0])
+    //setting cohort_name in cache context with ttl 0 so that it can keep the value as long as possible.
+    stateContext?.setResponseContext?.(`cohort_name`, cohort_name, {})
+  }
+  const { addUsers, removeUsers } = extractUsers(payloads)
+  const hasAddUsers = hasUsersToAddOrRemove(addUsers)
+  const hasRemoveUsers = hasUsersToAddOrRemove(removeUsers)
+
+  // We should never hit this condition because at least an user_id or device_id
+  // or user_alias is required in each payload, but if we do, returning early
+  // rather than hitting Cohort's API (with no data) is more efficient.
+  // The monoservice will interpret this early return as a 200.
+
+  if (!hasAddUsers && !hasRemoveUsers) {
+    return
+  }
+  if (hasAddUsers) {
+    cohortChanges.push(addUsers)
+  }
+  if (hasRemoveUsers) {
+    cohortChanges.push(removeUsers)
+  }
+
+  return await syncAudiencesApiClient.batchUpdate(settings, cohort_id, cohortChanges)
+}
+
+function validate(payloads: Payload[]): void {
+  if (payloads[0].cohort_name !== payloads[0].personas_audience_key) {
+    throw new IntegrationError(
+      'The value of `personas computation key` and `personas_audience_key` must match.',
+      'INVALID_SETTINGS',
+      400
+    )
+  }
+}
+
+function extractUsers(payloads: Payload[]) {
+  const addUsers: CohortChanges = { user_ids: [], device_ids: [], aliases: [] }
+  const removeUsers: CohortChanges = { user_ids: [], device_ids: [], aliases: [], should_remove: true }
+
+  payloads.forEach((payload: Payload) => {
+    const { event_properties, external_id, device_id, user_alias, personas_audience_key } = payload
+    const userEnteredOrRemoved: boolean = event_properties[`${personas_audience_key}`] as boolean
+    const user = userEnteredOrRemoved ? addUsers : removeUsers
+
+    if (external_id) {
+      user?.user_ids?.push(external_id)
+    } else if (device_id) {
+      user?.device_ids?.push(device_id)
+    } else if (user_alias) {
+      user?.aliases?.push(user_alias)
+    }
+  })
+
+  return {
+    addUsers,
+    removeUsers
+  }
+}
+
+function hasUsersToAddOrRemove(user: CohortChanges): boolean {
+  return !(isEmpty(user?.user_ids) && isEmpty(user?.device_ids) && isEmpty(user?.aliases))
+}
+
+export default action
diff --git a/packages/destination-actions/src/destinations/braze/__tests__/braze.test.ts b/packages/destination-actions/src/destinations/braze/__tests__/braze.test.ts
index 9f9c8260..616b9e31 100644
--- a/packages/destination-actions/src/destinations/braze/__tests__/braze.test.ts
+++ b/packages/destination-actions/src/destinations/braze/__tests__/braze.test.ts
@@ -100,6 +100,36 @@ describe('Braze Cloud Mode (Actions)', () => {
         `"One of \\"external_id\\" or \\"user_alias\\" or \\"braze_id\\" is required."`
       )
     })
+
+    it('should allow email address with unicode local part to be sent to Braze', async () => {
+      nock('https://rest.iad-01.braze.com').post('/users/track').reply(200, {})
+
+      const event = createTestEvent({
+        type: 'identify',
+        traits: {
+          email: 'ünîcòde_émail_locał_part@segment.com'
+        },
+        event: undefined,
+        receivedAt
+      })
+
+      const responses = await testDestination.testAction('updateUserProfile', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: expect.arrayContaining([
+          expect.objectContaining({
+            email: 'ünîcòde_émail_locał_part@segment.com'
+          })
+        ])
+      })
+    })
   })
 
   describe('trackEvent', () => {
diff --git a/packages/destination-actions/src/destinations/braze/updateUserProfile/index.ts b/packages/destination-actions/src/destinations/braze/updateUserProfile/index.ts
index d61b5e62..f120c840 100644
--- a/packages/destination-actions/src/destinations/braze/updateUserProfile/index.ts
+++ b/packages/destination-actions/src/destinations/braze/updateUserProfile/index.ts
@@ -146,7 +146,6 @@ const action: ActionDefinition<Settings, Payload> = {
       label: 'Email',
       description: "The user's email",
       type: 'string',
-      format: 'email',
       allowNull: true,
       default: {
         '@path': '$.traits.email'
diff --git a/packages/destination-actions/src/destinations/clevertap/userDelete/index.ts b/packages/destination-actions/src/destinations/clevertap/userDelete/index.ts
index 5b16265e..8603e13a 100644
--- a/packages/destination-actions/src/destinations/clevertap/userDelete/index.ts
+++ b/packages/destination-actions/src/destinations/clevertap/userDelete/index.ts
@@ -1,7 +1,7 @@
-import type { ActionDefinition } from '@segment/actions-core'
-import type { Settings } from '../generated-types'
-import type { Payload } from './generated-types'
-import { DeleteEvent } from './types'
+import type {ActionDefinition} from '@segment/actions-core'
+import type {Settings} from '../generated-types'
+import type {Payload} from './generated-types'
+import {DeleteEvent} from "./types";
 
 const action: ActionDefinition<Settings, Payload> = {
   title: 'User Delete',
@@ -11,20 +11,20 @@ const action: ActionDefinition<Settings, Payload> = {
       label: 'Identity',
       type: 'string',
       description: 'The ID of the profile which you want to delete',
-      default: { '@path': '$.userId' },
+      default: {'@path': '$.userId'},
       required: true
-    }
+    },
   },
-  perform: (request, { settings, payload }) => {
+  perform: (request, {settings, payload}) => {
     const event: DeleteEvent = {
-      identity: payload.identity
+      identity: payload.identity,
     }
     return request(`${settings.clevertapEndpoint}/1/delete/profiles.json`, {
       method: 'post',
       json: event,
       headers: {
-        'X-CleverTap-Account-Id': `${settings.clevertapAccountId}`,
-        'X-CleverTap-Passcode': `${settings.clevertapPasscode}`
+        "X-CleverTap-Account-Id": `${settings.clevertapAccountId}`,
+        "X-CleverTap-Passcode": `${settings.clevertapPasscode}`
       }
     })
   }
diff --git a/packages/destination-actions/src/destinations/customerio/__tests__/createUpdateObject.test.ts b/packages/destination-actions/src/destinations/customerio/__tests__/createUpdateObject.test.ts
new file mode 100644
index 00000000..07637936
--- /dev/null
+++ b/packages/destination-actions/src/destinations/customerio/__tests__/createUpdateObject.test.ts
@@ -0,0 +1,337 @@
+import nock from 'nock'
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import CustomerIO from '../index'
+import { Settings } from '../generated-types'
+import dayjs from '../../../lib/dayjs'
+import { AccountRegion } from '../utils'
+
+const testDestination = createTestIntegration(CustomerIO)
+const trackObjectService = nock('https://track.customer.io')
+
+describe('CustomerIO', () => {
+  describe('createUpdateObject', () => {
+    it('should work with default mappings when userId is supplied', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const traits = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: timestamp,
+        object_type_id: '1'
+      }
+
+      const attributes = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: dayjs.utc(timestamp).unix(),
+        object_type_id: '1'
+      }
+      trackObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: attributes,
+        created_at: dayjs.utc(timestamp).unix(),
+        type: 'object',
+        action: 'identify',
+        identifiers: {
+          type_id: traits.object_type_id,
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { id: userId } }]
+      })
+    })
+
+    it('should work with the EU account region', async () => {
+      const trackEUObjectService = nock('https://track-eu.customer.io')
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.EU
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const traits = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: timestamp,
+        object_type_id: '1'
+      }
+      const attributes = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: dayjs.utc(timestamp).unix(),
+        object_type_id: '1'
+      }
+      trackEUObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'EU' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'EU',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: attributes,
+        created_at: dayjs.utc(timestamp).unix(),
+        type: 'object',
+        action: 'identify',
+        identifiers: {
+          type_id: traits.object_type_id,
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { id: userId } }]
+      })
+    })
+
+    it('should fall back to the US account region', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde'
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const traits = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: timestamp,
+        object_type_id: '1'
+      }
+      const attributes = {
+        name: 'Sales',
+        industry: 'Technology',
+        created_at: dayjs.utc(timestamp).unix(),
+        object_type_id: '1'
+      }
+      trackObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'US-fallback' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US-fallback',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: attributes,
+        created_at: dayjs.utc(timestamp).unix(),
+        type: 'object',
+        action: 'identify',
+        identifiers: {
+          type_id: traits.object_type_id,
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { id: userId } }]
+      })
+    })
+
+    it('should work with anonymous id when userId is not supplied', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const traits = {
+        name: 'Sales',
+        created_at: timestamp,
+        object_type_id: '1'
+      }
+
+      const attributes = {
+        name: 'Sales',
+        created_at: dayjs.utc(timestamp).unix(),
+        object_type_id: '1'
+      }
+      trackObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId: undefined,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: attributes,
+        created_at: dayjs.utc(timestamp).unix(),
+        type: 'object',
+        action: 'identify_anonymous',
+        identifiers: {
+          type_id: traits.object_type_id,
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { anonymous_id: anonymousId } }]
+      })
+    })
+
+    it('should work with default object_type_id when object_type_id is not supplied', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const traits = {
+        name: 'Sales',
+        created_at: timestamp
+      }
+
+      const attributes = {
+        name: 'Sales',
+        created_at: dayjs.utc(timestamp).unix()
+      }
+      trackObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: attributes,
+        created_at: dayjs.utc(timestamp).unix(),
+        type: 'object',
+        action: 'identify',
+        identifiers: {
+          type_id: '1',
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { id: userId } }]
+      })
+    })
+
+    it('should work when no created_at is given', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const groupId = 'grp123'
+      const typeId = '1'
+      const traits = {
+        name: 'Sales',
+        object_type_id: '1'
+      }
+      trackObjectService.post(`/api/v2/entity`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        groupId
+      })
+      const responses = await testDestination.testAction('createUpdateObject', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        attributes: traits,
+        type: 'object',
+        action: 'identify',
+        identifiers: {
+          type_id: typeId,
+          id: groupId
+        },
+        cio_relationships: [{ identifiers: { id: userId } }]
+      })
+    })
+  })
+})
diff --git a/packages/destination-actions/src/destinations/customerio/__tests__/createUpdatePerson.test.ts b/packages/destination-actions/src/destinations/customerio/__tests__/createUpdatePerson.test.ts
index 68672ca5..a89b4207 100644
--- a/packages/destination-actions/src/destinations/customerio/__tests__/createUpdatePerson.test.ts
+++ b/packages/destination-actions/src/destinations/customerio/__tests__/createUpdatePerson.test.ts
@@ -406,5 +406,66 @@ describe('CustomerIO', () => {
         anonymous_id: anonymousId
       })
     })
+
+    it('should work with default mappings when userId and groupId are supplied', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const userId = 'abc123'
+      const anonymousId = 'unknown_123'
+      const timestamp = dayjs.utc().toISOString()
+      const birthdate = dayjs.utc('1990-01-01T00:00:00Z').toISOString()
+      const groupId = 'g12345'
+      const traits = {
+        full_name: 'Test User',
+        email: 'test@example.com',
+        created_at: timestamp,
+        person: {
+          over18: true,
+          identification: 'valid',
+          birthdate
+        }
+      }
+      const context = {
+        groupId: groupId
+      }
+      trackDeviceService.put(`/customers/${userId}`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId,
+        anonymousId,
+        timestamp,
+        traits,
+        context
+      })
+      const responses = await testDestination.testAction('createUpdatePerson', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toMatchObject({
+        ...traits,
+        email: traits.email,
+        created_at: dayjs.utc(timestamp).unix(),
+        anonymous_id: anonymousId,
+        person: {
+          ...traits.person,
+          birthdate: dayjs.utc(birthdate).unix()
+        },
+        cio_relationships: {
+          action: 'add_relationships',
+          relationships: [{ identifiers: { type_id: '1', id: groupId } }]
+        }
+      })
+    })
   })
 })
diff --git a/packages/destination-actions/src/destinations/customerio/__tests__/delete.test.ts b/packages/destination-actions/src/destinations/customerio/__tests__/delete.test.ts
index c1806277..1e41cac7 100644
--- a/packages/destination-actions/src/destinations/customerio/__tests__/delete.test.ts
+++ b/packages/destination-actions/src/destinations/customerio/__tests__/delete.test.ts
@@ -1,41 +1,113 @@
 import nock from 'nock'
-import { createTestIntegration } from '@segment/actions-core'
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
 import CustomerIO from '../index'
-import { DecoratedResponse } from '@segment/actions-core'
+import { Settings } from '../generated-types'
 import { AccountRegion } from '../utils'
 
 const testDestination = createTestIntegration(CustomerIO)
+const trackService = nock('https://track.customer.io/api/v1')
 
-describe('Customer.io', () => {
-    describe('onDelete', () => {
-        it('should support user deletions, defaulting to the US', async () => {
-            nock('https://track.customer.io').delete('/api/v1/customers/sloth@segment.com').reply(200, {})
-            expect(testDestination.onDelete).toBeDefined()
+describe('CustomerIO', () => {
+  describe('deleteDevice', () => {
+    it('should work with default mappings when userId is supplied', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.US
+      }
+      const userId = 'abc123'
+      const deviceId = 'device_123'
+      trackService.delete(`/customers/${userId}/devices/${deviceId}`).reply(200, {}, { 'x-customerio-region': 'US' })
+      const event = createTestEvent({
+        userId,
+        context: {
+          device: {
+            token: deviceId
+          }
+        }
+      })
+      const responses = await testDestination.testAction('deleteDevice', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
 
-            if (testDestination.onDelete) {
-                const response = await testDestination?.onDelete(
-                    { type: 'track', userId: 'sloth@segment.com' },
-                    { siteId: 'foo', apiKey: 'bar' }
-                )
-                const resp = response as DecoratedResponse
-                expect(resp.status).toBe(200)
-                expect(resp.data).toMatchObject({})
-            }
-        })
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toBeUndefined()
+    })
+
+    it('should work with the EU account region', async () => {
+      const trackEUService = nock('https://track-eu.customer.io/api/v1')
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde',
+        accountRegion: AccountRegion.EU
+      }
+      const userId = 'abc123'
+      const deviceId = 'device_123'
+      trackEUService.delete(`/customers/${userId}/devices/${deviceId}`).reply(200, {}, { 'x-customerio-region': 'EU' })
+      const event = createTestEvent({
+        userId,
+        context: {
+          device: {
+            token: deviceId
+          }
+        }
+      })
+      const responses = await testDestination.testAction('deleteDevice', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
+
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'EU',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toBeUndefined()
+    })
 
-        it('should support regional user deletions', async () => {
-            nock('https://track-eu.customer.io').delete('/api/v1/customers/sloth@segment.com').reply(200, {})
-            expect(testDestination.onDelete).toBeDefined()
+    it('should fall back to the US account region', async () => {
+      const settings: Settings = {
+        siteId: '12345',
+        apiKey: 'abcde'
+      }
+      const userId = 'abc123'
+      const deviceId = 'device_123'
+      trackService
+        .delete(`/customers/${userId}/devices/${deviceId}`)
+        .reply(200, {}, { 'x-customerio-region': 'US-fallback' })
+      const event = createTestEvent({
+        userId,
+        context: {
+          device: {
+            token: deviceId
+          }
+        }
+      })
+      const responses = await testDestination.testAction('deleteDevice', {
+        event,
+        settings,
+        useDefaultMappings: true
+      })
 
-            if (testDestination.onDelete) {
-                const response = await testDestination?.onDelete(
-                    { type: 'track', userId: 'sloth@segment.com' },
-                    { siteId: 'foo', apiKey: 'bar', accountRegion: AccountRegion.EU }
-                )
-                const resp = response as DecoratedResponse
-                expect(resp.status).toBe(200)
-                expect(resp.data).toMatchObject({})
-            }
-        })
+      expect(responses.length).toBe(1)
+      expect(responses[0].status).toBe(200)
+      expect(responses[0].headers.toJSON()).toMatchObject({
+        'x-customerio-region': 'US-fallback',
+        'content-type': 'application/json'
+      })
+      expect(responses[0].data).toMatchObject({})
+      expect(responses[0].options.json).toBeUndefined()
     })
+  })
 })
diff --git a/packages/destination-actions/src/destinations/customerio/createUpdateObject/generated-types.ts b/packages/destination-actions/src/destinations/customerio/createUpdateObject/generated-types.ts
new file mode 100644
index 00000000..d18aeb3f
--- /dev/null
+++ b/packages/destination-actions/src/destinations/customerio/createUpdateObject/generated-types.ts
@@ -0,0 +1,34 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Payload {
+  /**
+   * The ID used to uniquely identify an object in Customer.io. [Learn more](https://customer.io/docs/object-relationships).
+   */
+  id: string
+  /**
+   * A timestamp of when the object was created.
+   */
+  created_at?: string
+  /**
+   * Optional attributes for the object. When updating an object, attributes are added or updated, not removed.
+   */
+  custom_attributes?: {
+    [k: string]: unknown
+  }
+  /**
+   * The ID used to relate a user to an object in Customer.io. [Learn more](https://customer.io/docs/identifying-people/#identifiers).
+   */
+  user_id?: string
+  /**
+   * An anonymous ID to relate to an object when no Person ID exists. [Learn more](https://customer.io/docs/anonymous-events/).
+   */
+  anonymous_id?: string
+  /**
+   * The ID used to uniquely identify a custom object type in Customer.io. [Learn more](https://customer.io/docs/object-relationships).
+   */
+  type_id?: string
+  /**
+   * Convert dates to Unix timestamps (seconds since Epoch).
+   */
+  convert_timestamp?: boolean
+}
diff --git a/packages/destination-actions/src/destinations/customerio/createUpdateObject/index.ts b/packages/destination-actions/src/destinations/customerio/createUpdateObject/index.ts
new file mode 100644
index 00000000..2bde18c7
--- /dev/null
+++ b/packages/destination-actions/src/destinations/customerio/createUpdateObject/index.ts
@@ -0,0 +1,112 @@
+import type { ActionDefinition } from '@segment/actions-core'
+import type { Settings } from '../generated-types'
+import type { Payload } from './generated-types'
+import { convertAttributeTimestamps, convertValidTimestamp, trackApiEndpoint } from '../utils'
+
+const action: ActionDefinition<Settings, Payload> = {
+  title: 'Create or Update Object',
+  description: 'Create an object in Customer.io or update them if they exist.',
+  defaultSubscription: 'type = "object"',
+  fields: {
+    id: {
+      label: 'Object ID',
+      description:
+        'The ID used to uniquely identify an object in Customer.io. [Learn more](https://customer.io/docs/object-relationships).',
+      type: 'string',
+      required: true,
+      default: {
+        '@path': '$.groupId'
+      }
+    },
+    created_at: {
+      label: 'Created At',
+      description: 'A timestamp of when the object was created.',
+      type: 'string',
+      default: {
+        '@template': '{{traits.created_at}}'
+      }
+    },
+    custom_attributes: {
+      label: 'Object Attributes',
+      description:
+        'Optional attributes for the object. When updating an object, attributes are added or updated, not removed.',
+      type: 'object',
+      default: {
+        '@path': '$.traits'
+      }
+    },
+    user_id: {
+      label: 'User ID',
+      description:
+        'The ID used to relate a user to an object in Customer.io. [Learn more](https://customer.io/docs/identifying-people/#identifiers).',
+      type: 'string',
+      default: {
+        '@path': '$.userId'
+      }
+    },
+    anonymous_id: {
+      label: 'Anonymous ID',
+      description:
+        'An anonymous ID to relate to an object when no Person ID exists. [Learn more](https://customer.io/docs/anonymous-events/).',
+      type: 'string',
+      default: {
+        '@path': '$.anonymousId'
+      }
+    },
+    type_id: {
+      label: 'Object Type Id',
+      description:
+        'The ID used to uniquely identify a custom object type in Customer.io. [Learn more](https://customer.io/docs/object-relationships).',
+      type: 'string',
+      default: {
+        '@path': '$.typeId'
+      }
+    },
+    convert_timestamp: {
+      label: 'Convert Timestamps',
+      description: 'Convert dates to Unix timestamps (seconds since Epoch).',
+      type: 'boolean',
+      default: true
+    }
+  },
+  perform: (request, { settings, payload }) => {
+    let createdAt: string | number | undefined = payload.created_at
+    let customAttributes = payload.custom_attributes
+    const typeID = payload.type_id
+    const userID = payload.user_id
+    const objectID = payload.id
+    const anonymousId = payload.anonymous_id
+    if (payload.convert_timestamp !== false) {
+      if (createdAt) {
+        createdAt = convertValidTimestamp(createdAt)
+      }
+
+      if (customAttributes) {
+        customAttributes = convertAttributeTimestamps(customAttributes)
+      }
+    }
+
+    const body: Record<string, unknown> = {}
+    body.attributes = customAttributes
+    if (createdAt) {
+      body.created_at = createdAt
+    }
+    body.type = 'object'
+    body.identifiers = { type_id: typeID ?? '1', id: objectID }
+
+    if (userID) {
+      body.action = 'identify'
+      body.cio_relationships = [{ identifiers: { id: userID } }]
+    } else {
+      body.action = 'identify_anonymous'
+      body.cio_relationships = [{ identifiers: { anonymous_id: anonymousId } }]
+    }
+
+    return request(`${trackApiEndpoint(settings.accountRegion)}/api/v2/entity`, {
+      method: 'post',
+      json: body
+    })
+  }
+}
+
+export default action
diff --git a/packages/destination-actions/src/destinations/customerio/createUpdatePerson/generated-types.ts b/packages/destination-actions/src/destinations/customerio/createUpdatePerson/generated-types.ts
index 8a7eced3..878b24dc 100644
--- a/packages/destination-actions/src/destinations/customerio/createUpdatePerson/generated-types.ts
+++ b/packages/destination-actions/src/destinations/customerio/createUpdatePerson/generated-types.ts
@@ -17,6 +17,10 @@ export interface Payload {
    * A timestamp of when the person was created.
    */
   created_at?: string
+  /**
+   * The ID used to uniquely identify an object in Customer.io. [Learn more](https://customer.io/docs/object-relationships).
+   */
+  group_id?: string
   /**
    * Optional attributes for the person. When updating a person, attributes are added or updated, not removed.
    */
@@ -27,4 +31,8 @@ export interface Payload {
    * Convert dates to Unix timestamps (seconds since Epoch).
    */
   convert_timestamp?: boolean
+  /**
+   * The ID used to uniquely identify a custom object type in Customer.io. [Learn more](https://customer.io/docs/object-relationships).
+   */
+  object_type_id?: string
 }
diff --git a/packages/destination-actions/src/destinations/customerio/createUpdatePerson/index.ts b/packages/destination-actions/src/destinations/customerio/createUpdatePerson/index.ts
index 5e92def1..67b6585c 100644
--- a/packages/destination-actions/src/destinations/customerio/createUpdatePerson/index.ts
+++ b/packages/destination-actions/src/destinations/customerio/createUpdatePerson/index.ts
@@ -47,6 +47,15 @@ const action: ActionDefinition<Settings, Payload> = {
         '@template': '{{traits.created_at}}'
       }
     },
+    group_id: {
+      label: 'Object ID',
+      description:
+        'The ID used to uniquely identify an object in Customer.io. [Learn more](https://customer.io/docs/object-relationships).',
+      type: 'string',
+      default: {
+        '@template': '{{context.groupId}}'
+      }
+    },
     custom_attributes: {
       label: 'Person Attributes',
       description:
@@ -61,12 +70,23 @@ const action: ActionDefinition<Settings, Payload> = {
       description: 'Convert dates to Unix timestamps (seconds since Epoch).',
       type: 'boolean',
       default: true
+    },
+    object_type_id: {
+      label: 'Object Type Id',
+      description:
+        'The ID used to uniquely identify a custom object type in Customer.io. [Learn more](https://customer.io/docs/object-relationships).',
+      type: 'string',
+      default: {
+        '@path': '$.objectTypeId'
+      }
     }
   },
 
   perform: (request, { settings, payload }) => {
     let createdAt: string | number | undefined = payload.created_at
     let customAttributes = payload.custom_attributes
+    const objectId = payload.group_id
+    const objectTypeId = payload.object_type_id
 
     if (payload.convert_timestamp !== false) {
       if (createdAt) {
@@ -88,6 +108,14 @@ const action: ActionDefinition<Settings, Payload> = {
       body.created_at = createdAt
     }
 
+    // Adding Object Person relationship if group_id exists in the call. If the object_type_id is not given, default it to "1"
+    if (objectId) {
+      body.cio_relationships = {
+        action: 'add_relationships',
+        relationships: [{ identifiers: { type_id: objectTypeId ?? '1', id: objectId } }]
+      }
+    }
+
     return request(`${trackApiEndpoint(settings.accountRegion)}/api/v1/customers/${payload.id}`, {
       method: 'put',
       json: body
diff --git a/packages/destination-actions/src/destinations/customerio/index.ts b/packages/destination-actions/src/destinations/customerio/index.ts
index aca214fb..dd63c71e 100644
--- a/packages/destination-actions/src/destinations/customerio/index.ts
+++ b/packages/destination-actions/src/destinations/customerio/index.ts
@@ -5,6 +5,7 @@ import createUpdatePerson from './createUpdatePerson'
 import trackEvent from './trackEvent'
 import trackPageView from './trackPageView'
 import trackScreenView from './trackScreenView'
+import createUpdateObject from './createUpdateObject'
 import type { DestinationDefinition } from '@segment/actions-core'
 import type { Settings } from './generated-types'
 import { AccountRegion, trackApiEndpoint } from './utils'
@@ -56,7 +57,8 @@ const destination: DestinationDefinition<Settings> = {
     createUpdatePerson,
     trackEvent,
     trackPageView,
-    trackScreenView
+    trackScreenView,
+    createUpdateObject
   },
 
   presets: [
@@ -95,6 +97,12 @@ const destination: DestinationDefinition<Settings> = {
       subscribe: 'type = "screen"',
       partnerAction: 'trackScreenView',
       mapping: defaultValues(trackScreenView.fields)
+    },
+    {
+      name: 'Create or Update Object',
+      subscribe: 'type = "group"',
+      partnerAction: 'createUpdateObject',
+      mapping: defaultValues(createUpdateObject.fields)
     }
   ],
 
diff --git a/packages/destination-actions/src/destinations/engage-messaging-sendgrid/__tests__/send-email.test.ts b/packages/destination-actions/src/destinations/engage-messaging-sendgrid/__tests__/send-email.test.ts
index 4bf39600..acd4b826 100644
--- a/packages/destination-actions/src/destinations/engage-messaging-sendgrid/__tests__/send-email.test.ts
+++ b/packages/destination-actions/src/destinations/engage-messaging-sendgrid/__tests__/send-email.test.ts
@@ -114,6 +114,7 @@ describe.each(['stage', 'production'])('%s environment', (environment) => {
         ]
       },
       traits: { '@path': '$.properties' },
+      eventOccurredTS: { '@path': '$.timestamp' },
       ...overrides
     }
   }
@@ -284,7 +285,8 @@ describe.each(['stage', 'production'])('%s environment', (environment) => {
             { id: userData.email, type: 'email', subscriptionStatus: 'subscribed' },
             { id: userData.phone, type: 'phone', subscriptionStatus: 'subscribed' }
           ],
-          traits: { '@path': '$.properties' }
+          traits: { '@path': '$.properties' },
+          eventOccurredTS: { '@path': '$.timestamp' }
         }
       })
 
diff --git a/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/generated-types.ts b/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/generated-types.ts
index f06eb07f..7764c16a 100644
--- a/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/generated-types.ts
+++ b/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/generated-types.ts
@@ -58,4 +58,8 @@ export interface Payload {
   traits?: {
     [k: string]: unknown
   }
+  /**
+   * Time of when the actual event happened.
+   */
+  eventOccurredTS?: string
 }
diff --git a/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/index.ts b/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/index.ts
index d5a6b0dd..6cfbbe8c 100644
--- a/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/index.ts
+++ b/packages/destination-actions/src/destinations/engage-messaging-twilio/sendSms/index.ts
@@ -146,6 +146,15 @@ const action: ActionDefinition<Settings, Payload> = {
       type: 'object',
       required: false,
       default: { '@path': '$.properties' }
+    },
+    eventOccurredTS: {
+      label: 'Event Timestamp',
+      description: 'Time of when the actual event happened.',
+      type: 'string',
+      required: false,
+      default: {
+        '@path': '$.timestamp'
+      }
     }
   },
   perform: async (request, { settings, payload, statsContext }) => {
@@ -236,6 +245,13 @@ const action: ActionDefinition<Settings, Payload> = {
       )
       tags?.push(`twilio_status_code:${response.status}`)
       statsClient?.incr('actions-personas-messaging-twilio.response', 1, tags)
+      if (payload?.eventOccurredTS != undefined) {
+        statsClient?.histogram(
+          'actions-personas-messaging-twilio.eventDeliveryTS',
+          Date.now() - new Date(payload?.eventOccurredTS).getTime(),
+          tags
+        )
+      }
       return response
     } else {
       statsClient?.incr('actions-personas-messaging-twilio.twilio-error', 1, tags)
diff --git a/packages/destination-actions/src/destinations/google-analytics-4/__tests__/selectPromotion.test.ts b/packages/destination-actions/src/destinations/google-analytics-4/__tests__/selectPromotion.test.ts
index 08029231..e3154fe3 100644
--- a/packages/destination-actions/src/destinations/google-analytics-4/__tests__/selectPromotion.test.ts
+++ b/packages/destination-actions/src/destinations/google-analytics-4/__tests__/selectPromotion.test.ts
@@ -368,65 +368,6 @@ describe('GA4', () => {
       }
     })
 
-    it('should throw error when promotion name and id is missing', async () => {
-      nock('https://www.google-analytics.com/mp/collect')
-        .post(`?measurement_id=${measurementId}&api_secret=${apiSecret}`)
-        .reply(201, {})
-      const event = createTestEvent({
-        event: 'Promotion Clicked',
-        userId: '3456fff',
-        anonymousId: 'anon-567890',
-        type: 'track',
-        properties: {
-          promotion_id: 'promo_1',
-          creative: 'top_banner_2',
-          name: '75% store-wide shoe sale',
-          position: 'home_banner_top',
-          items: [
-            {
-              item_id: 'SKU_12345',
-              item_name: 'jeggings',
-              coupon: 'SUMMER_FUN',
-              discount: 2.22,
-              creative_slot: 'featured_app_1',
-              location_id: 'L_12345',
-              affiliation: 'Google Store',
-              item_brand: 'Gucci',
-              item_category: 'pants',
-              item_variant: 'Black',
-              price: 9.99,
-              currency: 'USD'
-            }
-          ]
-        }
-      })
-
-      try {
-        await testDestination.testAction('selectPromotion', {
-          event,
-          settings: {
-            apiSecret,
-            measurementId
-          },
-          mapping: {
-            clientId: {
-              '@path': '$.anonymousId'
-            },
-            location_id: {
-              '@path': '$.properties.promotion_id'
-            },
-            items: {
-              '@path': '$.properties.items'
-            }
-          },
-          useDefaultMappings: true
-        })
-        fail('the test should have thrown an error')
-      } catch (e) {
-        expect(e.message).toBe('One of promotion name or promotion id is required.')
-      }
-    })
-
     it('should throw error when item currency is invalid', async () => {
       nock('https://www.google-analytics.com/mp/collect')
         .post(`?measurement_id=${measurementId}&api_secret=${apiSecret}`)
diff --git a/packages/destination-actions/src/destinations/google-analytics-4/__tests__/viewItem.test.ts b/packages/destination-actions/src/destinations/google-analytics-4/__tests__/viewItem.test.ts
index cc5dd7b2..8e7666ff 100644
--- a/packages/destination-actions/src/destinations/google-analytics-4/__tests__/viewItem.test.ts
+++ b/packages/destination-actions/src/destinations/google-analytics-4/__tests__/viewItem.test.ts
@@ -49,7 +49,7 @@ describe('GA4', () => {
       })
 
       expect(responses[0].options.body).toMatchInlineSnapshot(
-        `"{\\"client_id\\":\\"anon-2134\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"USD\\",\\"items\\":[{\\"item_id\\":\\"12345abcde\\",\\"item_name\\":\\"Quadruple Stack Oreos, 52 ct\\",\\"quantity\\":1,\\"price\\":12.99}],\\"engagement_time_msec\\":1}}],\\"user_properties\\":{\\"hello\\":{\\"value\\":\\"world\\"},\\"a\\":{\\"value\\":\\"1\\"},\\"b\\":{\\"value\\":\\"2\\"},\\"c\\":{\\"value\\":\\"3\\"}},\\"timestamp_micros\\":1655936458905000}"`
+        `"{\\"client_id\\":\\"anon-2134\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"USD\\",\\"items\\":[{\\"item_id\\":\\"12345abcde\\",\\"item_name\\":\\"Quadruple Stack Oreos, 52 ct\\",\\"price\\":12.99,\\"quantity\\":1}],\\"engagement_time_msec\\":1}}],\\"user_properties\\":{\\"hello\\":{\\"value\\":\\"world\\"},\\"a\\":{\\"value\\":\\"1\\"},\\"b\\":{\\"value\\":\\"2\\"},\\"c\\":{\\"value\\":\\"3\\"}},\\"timestamp_micros\\":1655936458905000}"`
       )
     })
 
@@ -184,7 +184,7 @@ describe('GA4', () => {
       `)
 
       expect(responses[0].options.body).toMatchInlineSnapshot(
-        `"{\\"client_id\\":\\"3456fff\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"USD\\",\\"items\\":[{\\"item_id\\":\\"507f1f77bcf86cd799439011\\",\\"item_name\\":\\"Monopoly: 3rd Edition\\",\\"quantity\\":1,\\"coupon\\":\\"MAYDEALS\\",\\"item_brand\\":\\"Hasbro\\",\\"item_category\\":\\"Games\\",\\"item_variant\\":\\"200 pieces\\",\\"price\\":18.99}],\\"value\\":18.99,\\"engagement_time_msec\\":1}}],\\"timestamp_micros\\":1655936458905000}"`
+        `"{\\"client_id\\":\\"3456fff\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"USD\\",\\"items\\":[{\\"item_id\\":\\"507f1f77bcf86cd799439011\\",\\"item_name\\":\\"Monopoly: 3rd Edition\\",\\"coupon\\":\\"MAYDEALS\\",\\"item_brand\\":\\"Hasbro\\",\\"item_category\\":\\"Games\\",\\"item_variant\\":\\"200 pieces\\",\\"price\\":18.99,\\"quantity\\":1}],\\"value\\":18.99,\\"engagement_time_msec\\":1}}],\\"timestamp_micros\\":1655936458905000}"`
       )
     })
 
@@ -242,7 +242,7 @@ describe('GA4', () => {
       `)
 
       expect(responses[0].options.body).toMatchInlineSnapshot(
-        `"{\\"client_id\\":\\"3456fff\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"usd\\",\\"items\\":[{\\"item_id\\":\\"507f1f77bcf86cd799439011\\",\\"item_name\\":\\"Monopoly: 3rd Edition\\",\\"quantity\\":1,\\"coupon\\":\\"MAYDEALS\\",\\"item_brand\\":\\"Hasbro\\",\\"item_category\\":\\"Games\\",\\"item_variant\\":\\"200 pieces\\",\\"price\\":18.99}],\\"value\\":18.99,\\"engagement_time_msec\\":1}}],\\"timestamp_micros\\":1655936458905000}"`
+        `"{\\"client_id\\":\\"3456fff\\",\\"events\\":[{\\"name\\":\\"view_item\\",\\"params\\":{\\"currency\\":\\"usd\\",\\"items\\":[{\\"item_id\\":\\"507f1f77bcf86cd799439011\\",\\"item_name\\":\\"Monopoly: 3rd Edition\\",\\"coupon\\":\\"MAYDEALS\\",\\"item_brand\\":\\"Hasbro\\",\\"item_category\\":\\"Games\\",\\"item_variant\\":\\"200 pieces\\",\\"price\\":18.99,\\"quantity\\":1}],\\"value\\":18.99,\\"engagement_time_msec\\":1}}],\\"timestamp_micros\\":1655936458905000}"`
       )
     })
 
diff --git a/packages/destination-actions/src/destinations/google-analytics-4/selectPromotion/index.ts b/packages/destination-actions/src/destinations/google-analytics-4/selectPromotion/index.ts
index 5a1bfe80..1452cc22 100644
--- a/packages/destination-actions/src/destinations/google-analytics-4/selectPromotion/index.ts
+++ b/packages/destination-actions/src/destinations/google-analytics-4/selectPromotion/index.ts
@@ -75,14 +75,6 @@ const action: ActionDefinition<Settings, Payload> = {
           verifyCurrency(product.currency)
         }
 
-        if (product.promotion_id === undefined && product.promotion_name === undefined) {
-          throw new IntegrationError(
-            'One of promotion name or promotion id is required.',
-            'Misconfigured required field',
-            400
-          )
-        }
-
         return product as PromotionProductItem
       })
     }
diff --git a/packages/destination-actions/src/destinations/google-analytics-4/viewItem/index.ts b/packages/destination-actions/src/destinations/google-analytics-4/viewItem/index.ts
index 4092f48c..423e1f33 100644
--- a/packages/destination-actions/src/destinations/google-analytics-4/viewItem/index.ts
+++ b/packages/destination-actions/src/destinations/google-analytics-4/viewItem/index.ts
@@ -55,19 +55,7 @@ const action: ActionDefinition<Settings, Payload> = {
           verifyCurrency(product.currency)
         }
 
-        return {
-          item_id: product.item_id,
-          item_name: product.item_name,
-          quantity: product.quantity,
-          affiliation: product.affiliation,
-          coupon: product.coupon,
-          discount: product.discount,
-          item_brand: product.item_brand,
-          item_category: product.item_category,
-          item_variant: product.item_variant,
-          price: product.price,
-          currency: product.currency
-        } as ProductItem
+        return product as ProductItem
       })
     }
 
diff --git a/packages/destination-actions/src/destinations/google-enhanced-conversions/uploadClickConversion/index.ts b/packages/destination-actions/src/destinations/google-enhanced-conversions/uploadClickConversion/index.ts
index 79b2a806..e7376dc1 100644
--- a/packages/destination-actions/src/destinations/google-enhanced-conversions/uploadClickConversion/index.ts
+++ b/packages/destination-actions/src/destinations/google-enhanced-conversions/uploadClickConversion/index.ts
@@ -106,7 +106,8 @@ const action: ActionDefinition<Settings, Payload> = {
       type: 'string',
       choices: [
         { label: 'APP', value: 'APP' },
-        { label: 'WEB', value: 'WEB' }
+        { label: 'WEB', value: 'WEB' },
+        { label: 'UNSPECIFIED', value: 'UNSPECIFIED' }
       ]
     },
     merchant_id: {
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/__snapshots__/googleapis.snapshot.test.ts.snap b/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/__snapshots__/googleapis.snapshot.test.ts.snap
deleted file mode 100644
index 96496035..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/__snapshots__/googleapis.snapshot.test.ts.snap
+++ /dev/null
@@ -1,59 +0,0 @@
-// Jest Snapshot v1, https://goo.gl/fbAQLP
-
-exports[`Google Sheets Testing snapshots for googleapis library: append 1`] = `
-Array [
-  "https://sheets.googleapis.com/v4/spreadsheets/myId/values/myName!B:B:append?valueInputOption=myFormat&insertDataOption=INSERT_ROWS",
-  Object {
-    "json": Object {
-      "values": Array [
-        Array [
-          "col1b",
-          "col2b",
-        ],
-      ],
-    },
-    "method": "post",
-  },
-]
-`;
-
-exports[`Google Sheets Testing snapshots for googleapis library: batchUpdate 1`] = `
-Array [
-  "https://sheets.googleapis.com/v4/spreadsheets/myId/values:batchUpdate",
-  Object {
-    "json": Object {
-      "data": Array [
-        Object {
-          "range": "C:C",
-          "values": Array [
-            Array [
-              "col1c",
-              "col2c",
-            ],
-          ],
-        },
-        Object {
-          "range": "D:D",
-          "values": Array [
-            Array [
-              "col1d, col2d",
-            ],
-          ],
-        },
-      ],
-      "valueInputOption": "myFormat",
-    },
-    "method": "post",
-  },
-]
-`;
-
-exports[`Google Sheets Testing snapshots for googleapis library: get 1`] = `
-Array [
-  "https://sheets.googleapis.com/v4/spreadsheets/myId/values/myName!A:A",
-  Object {
-    "method": "get",
-    "skipResponseCloning": true,
-  },
-]
-`;
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/googleapis.snapshot.test.ts b/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/googleapis.snapshot.test.ts
deleted file mode 100644
index 9391ac43..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/googleapis.snapshot.test.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import nock from 'nock'
-import { GoogleSheets } from '../googleapis/index'
-
-describe(`Google Sheets`, () => {
-  describe(`Testing snapshots for googleapis library:`, () => {
-    nock(/.*/).persist().get(/.*/).reply(200)
-    nock(/.*/).persist().post(/.*/).reply(200)
-    nock(/.*/).persist().put(/.*/).reply(200)
-
-    const mappingSettings = {
-      spreadsheetId: 'myId',
-      spreadsheetName: 'myName',
-      dataFormat: 'myFormat',
-      columns: ['myColumn1', 'myColumn2']
-    }
-
-    const req = jest.fn()
-    const gs = new GoogleSheets(req)
-    afterEach(() => {
-      req.mockClear()
-    })
-
-    it('get', async () => {
-      await gs.get(mappingSettings, 'A:A')
-
-      expect(req.mock.calls[0]).toMatchSnapshot()
-    })
-
-    it('append', async () => {
-      await gs.append(mappingSettings, 'B:B', [['col1b', 'col2b']])
-
-      expect(req.mock.calls[0]).toMatchSnapshot()
-    })
-
-    it('batchUpdate', async () => {
-      await gs.batchUpdate(mappingSettings, [
-        { range: 'C:C', values: [['col1c', 'col2c']] },
-        { range: 'D:D', values: [['col1d, col2d']] }
-      ])
-
-      expect(req.mock.calls[0]).toMatchSnapshot()
-    })
-  })
-})
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/index.test.ts b/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/index.test.ts
deleted file mode 100644
index e5c9b773..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/index.test.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { createTestIntegration } from '@segment/actions-core'
-import { ExecuteInput } from '@segment/actions-core'
-import { Settings } from '../generated-types'
-import Definition from '../index'
-
-const testDestination = createTestIntegration(Definition)
-
-describe('Google Sheets', () => {
-  describe('extendRequest', () => {
-    it('should populate headers with authentication', async () => {
-      const accessToken = '12345abcde'
-      const authData: Partial<ExecuteInput<Settings, undefined>> = {
-        auth: {
-          accessToken,
-          refreshToken: ''
-        }
-      }
-
-      const extendedRequest = testDestination.extendRequest?.(authData as ExecuteInput<Settings, undefined>)
-      expect(extendedRequest?.headers?.['authorization']).toContain(`Bearer ${accessToken}`)
-    })
-  })
-})
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/postSheet.operations.test.ts b/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/postSheet.operations.test.ts
deleted file mode 100644
index 7a16bd63..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/__tests__/postSheet.operations.test.ts
+++ /dev/null
@@ -1,102 +0,0 @@
-import { ExecuteInput } from '@segment/actions-core'
-import { Settings } from '../generated-types'
-import { Payload } from '../postSheet/generated-types'
-import PostSheet from '../postSheet/index'
-import { GoogleSheets, GetResponse } from '../googleapis/index'
-import { CONSTANTS } from '../constants'
-
-jest.mock('../constants', () => ({
-  CONSTANTS: {
-    MAX_CELLS: 300000
-  }
-}))
-
-const mockGoogleSheets = {
-  get: jest.fn(),
-  batchUpdate: jest.fn(),
-  append: jest.fn()
-}
-
-jest.mock('../googleapis/index', () => {
-  const original = jest.requireActual('../googleapis/index')
-  return {
-    ...original,
-    GoogleSheets: jest.fn().mockImplementation(() => {
-      return mockGoogleSheets
-    })
-  }
-})
-
-describe('Google Sheets', () => {
-  describe('postSheet', () => {
-    beforeEach(() => {
-      mockGoogleSheets.get.mockClear()
-      mockGoogleSheets.batchUpdate.mockClear()
-      mockGoogleSheets.append.mockClear()
-    })
-
-    const data: Partial<ExecuteInput<Settings, Payload[]>> = {
-      payload: [
-        {
-          record_identifier: 'record_id',
-          operation_type: 'created',
-          spreadsheet_id: 'spreadsheet_id',
-          spreadsheet_name: 'spreadsheet_name',
-          data_format: 'data_format',
-          fields: { column1: 'value1', column2: 'value2' }
-        }
-      ]
-    }
-
-    it('should call append if the new data is not found in get response', async () => {
-      const getResponse: Partial<GetResponse> = {
-        values: [['unknown_id']]
-      }
-
-      mockGoogleSheets.get.mockResolvedValue({
-        data: getResponse
-      })
-
-      await PostSheet.performBatch?.(jest.fn(), data as ExecuteInput<Settings, Payload[]>)
-
-      expect(GoogleSheets).toHaveBeenCalled()
-      expect(mockGoogleSheets.get).toHaveBeenCalled()
-      expect(mockGoogleSheets.append).toHaveBeenCalled()
-      expect(mockGoogleSheets.batchUpdate).toHaveBeenCalled() // batchUpdate always gets called to write columns
-    })
-
-    it('should call update (and not append) if the new data is found in get response', async () => {
-      // Make sure the spreadsheet contains the event from the payload
-      const getResponse: Partial<GetResponse> = {
-        values: [[data.payload?.[0].record_identifier as string]]
-      }
-
-      mockGoogleSheets.get.mockResolvedValue({
-        data: getResponse
-      })
-
-      await PostSheet.performBatch?.(jest.fn(), data as ExecuteInput<Settings, Payload[]>)
-
-      expect(GoogleSheets).toHaveBeenCalled()
-      expect(mockGoogleSheets.get).toHaveBeenCalled()
-      expect(mockGoogleSheets.append).not.toHaveBeenCalled()
-      expect(mockGoogleSheets.batchUpdate).toHaveBeenCalled()
-    })
-
-    it('should fail because number of cells limit is reached', async () => {
-      // Make sure the spreadsheet contains the event from the payload
-      CONSTANTS.MAX_CELLS = 1
-      const getResponse: Partial<GetResponse> = {
-        values: [['id'], ['1234'], ['12345']]
-      }
-
-      mockGoogleSheets.get.mockResolvedValue({
-        data: getResponse
-      })
-
-      await expect(PostSheet.performBatch?.(jest.fn(), data as ExecuteInput<Settings, Payload[]>)).rejects.toThrowError(
-        'Sheet has reached maximum limit'
-      )
-    })
-  })
-})
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/constants.ts b/packages/destination-actions/src/destinations/google-sheets-partner/constants.ts
deleted file mode 100644
index 4da62301..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/constants.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-export const CONSTANTS = {
-  /**
-   * Based on benchmarks found while testing so we dont reach the timeout limit.
-   */
-  MAX_CELLS: 300000
-}
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/generated-types.ts b/packages/destination-actions/src/destinations/google-sheets-partner/generated-types.ts
deleted file mode 100644
index 4ab2786e..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/generated-types.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-// Generated file. DO NOT MODIFY IT BY HAND.
-
-export interface Settings {}
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/googleapis/index.ts b/packages/destination-actions/src/destinations/google-sheets-partner/googleapis/index.ts
deleted file mode 100644
index 75f6b351..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/googleapis/index.ts
+++ /dev/null
@@ -1,65 +0,0 @@
-import { ModifiedResponse, RequestClient } from '@segment/actions-core'
-import type { MappingSettings } from '../postSheet/operations'
-
-const API_VERSION = 'v4'
-
-export type GetResponse = {
-  range: string
-  majorDimension: string
-  values: string[][]
-}
-export class GoogleSheets {
-  request: RequestClient
-
-  constructor(request: RequestClient) {
-    this.request = request
-  }
-
-  get = async (mappingSettings: MappingSettings, range: string): Promise<ModifiedResponse<GetResponse>> => {
-    return this.request(
-      `https://sheets.googleapis.com/${API_VERSION}/spreadsheets/${mappingSettings.spreadsheetId}/values/${mappingSettings.spreadsheetName}!${range}`,
-      {
-        method: 'get',
-        skipResponseCloning: true
-      }
-    )
-  }
-
-  batchUpdate = async (mappingSettings: MappingSettings, batchPayload: { range: string; values: string[][] }[]) => {
-    return this.request(
-      `https://sheets.googleapis.com/${API_VERSION}/spreadsheets/${mappingSettings.spreadsheetId}/values:batchUpdate`,
-      {
-        method: 'post',
-        json: {
-          valueInputOption: mappingSettings.dataFormat,
-          data: batchPayload
-        }
-      }
-    )
-  }
-
-  // TODO: Re-enable delete once locking is supported.
-  // batchClear = async (mappingSettings: MappingSettings, deletePayload: { range: string }[]) => {
-  //   return this.request(
-  //     `https://sheets.googleapis.com/${API_VERSION}/spreadsheets/${mappingSettings.spreadsheetId}/values:batchClear`,
-  //     {
-  //       method: 'post',
-  //       json: {
-  //         ranges: deletePayload.map((p) => p.range)
-  //       }
-  //     }
-  //   )
-  // }
-
-  append = async (mappingSettings: MappingSettings, range: string, values: string[][]) => {
-    return this.request(
-      `https://sheets.googleapis.com/${API_VERSION}/spreadsheets/${mappingSettings.spreadsheetId}/values/${mappingSettings.spreadsheetName}!${range}:append?valueInputOption=${mappingSettings.dataFormat}&insertDataOption=INSERT_ROWS`,
-      {
-        method: 'post',
-        json: {
-          values: values
-        }
-      }
-    )
-  }
-}
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/index.ts b/packages/destination-actions/src/destinations/google-sheets-partner/index.ts
deleted file mode 100644
index b565d7f6..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/index.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-import type { DestinationDefinition } from '@segment/actions-core'
-import type { Settings } from './generated-types'
-
-import postSheet from './postSheet'
-interface RefreshTokenResponse {
-  access_token: string
-  scope: string
-  expires_in: number
-  token_type: string
-}
-
-const destination: DestinationDefinition<Settings> = {
-  name: 'Google Sheets (Partner Test)',
-  slug: 'actions-google-sheets-partner',
-  mode: 'cloud',
-
-  authentication: {
-    scheme: 'oauth-managed',
-    fields: {},
-    // testAuthentication: (request) => {
-    //   // Return a request that tests/validates the user's credentials.
-    //   // If you do not have a way to validate the authentication fields safely,
-    //   // you can remove the `testAuthentication` function, though discouraged.
-    // },
-    refreshAccessToken: async (request, { auth }) => {
-      if (!auth.refreshTokenUrl) {
-        console.log('Could not find refresh token Url')
-        auth.refreshTokenUrl = 'https://www.googleapis.com/oauth2/v4/token'
-      }
-      const res = await request<RefreshTokenResponse>(auth.refreshTokenUrl, {
-        method: 'POST',
-        body: new URLSearchParams({
-          refresh_token: auth.refreshToken,
-          client_id: auth.clientId,
-          client_secret: auth.clientSecret,
-          grant_type: 'refresh_token'
-        })
-      })
-
-      return { accessToken: res.data.access_token }
-    }
-  },
-  extendRequest({ auth }) {
-    return {
-      headers: {
-        authorization: `Bearer ${auth?.accessToken}`
-      }
-    }
-  },
-
-  // onDelete: async (request, { settings, payload }) => {
-  //   // Return a request that performs a GDPR delete for the provided Segment userId or anonymousId
-  //   // provided in the payload. If your destination does not support GDPR deletion you should not
-  //   // implement this function and should remove it completely.
-  // },
-
-  actions: {
-    postSheet
-  }
-}
-
-export default destination
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/generated-types.ts b/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/generated-types.ts
deleted file mode 100644
index 9174bd55..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/generated-types.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-// Generated file. DO NOT MODIFY IT BY HAND.
-
-export interface Payload {
-  /**
-   * Property which uniquely identifies each row in the spreadsheet.
-   */
-  record_identifier: string
-  /**
-   * Describes the nature of the operation being performed. Only supported values are 'new' and 'updated'.
-   */
-  operation_type: string
-  /**
-   * The identifier of the spreadsheet. You can find this value in the URL of the spreadsheet. e.g. https://docs.google.com/spreadsheets/d/{SPREADSHEET_ID}/edit
-   */
-  spreadsheet_id: string
-  /**
-   * The name of the spreadsheet. You can find this value on the tab at the bottom of the spreadsheet. Please provide a valid name of a sheet that already exists.
-   */
-  spreadsheet_name: string
-  /**
-   * The way Google will interpret values. If you select raw, values will not be parsed and will be stored as-is. If you select user entered, values will be parsed as if you typed them into the UI. Numbers will stay as numbers, but strings may be converted to numbers, dates, etc. following the same rules that are applied when entering text into a cell via the Google Sheets UI.
-   */
-  data_format: string
-  /**
-   *
-   *   The fields to write to the spreadsheet.
-   *
-   *   On the left-hand side, input the name of the field as it will appear in the Google Sheet.
-   *
-   *   On the right-hand side, select the field from your data model that maps to the given field in your sheet.
-   *
-   *   ---
-   *
-   *
-   */
-  fields: {
-    [k: string]: unknown
-  }
-  /**
-   * Set as true to ensure Segment sends data to Google Sheets in batches. Please do not set to false.
-   */
-  enable_batching?: boolean
-}
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/index.ts b/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/index.ts
deleted file mode 100644
index 5f3040a1..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/index.ts
+++ /dev/null
@@ -1,87 +0,0 @@
-import { ActionDefinition } from '@segment/actions-core'
-import type { Settings } from '../generated-types'
-import type { Payload } from './generated-types'
-
-import { processData } from './operations'
-
-const action: ActionDefinition<Settings, Payload> = {
-  title: 'Post Sheet',
-  description: 'Write values to a Google Sheets spreadsheet.',
-  defaultSubscription: 'event = "updated" or event = "new"',
-  // TODO: Hide record_identifier and operation_type
-  fields: {
-    record_identifier: {
-      label: 'Record Identifier',
-      description: 'Property which uniquely identifies each row in the spreadsheet.',
-      type: 'string',
-      required: true,
-      default: { '@path': '$.__segment_id' }
-    },
-    operation_type: {
-      label: 'Operation Type',
-      description:
-        "Describes the nature of the operation being performed. Only supported values are 'new' and 'updated'.",
-      type: 'hidden',
-      required: true,
-      default: { '@path': '$.event' }
-    },
-    spreadsheet_id: {
-      label: 'Spreadsheet ID',
-      description:
-        'The identifier of the spreadsheet. You can find this value in the URL of the spreadsheet. e.g. https://docs.google.com/spreadsheets/d/{SPREADSHEET_ID}/edit',
-      type: 'string',
-      required: true,
-      default: ''
-    },
-    spreadsheet_name: {
-      label: 'Spreadsheet Name',
-      description:
-        'The name of the spreadsheet. You can find this value on the tab at the bottom of the spreadsheet. Please provide a valid name of a sheet that already exists.',
-      type: 'string',
-      required: true,
-      default: 'Sheet1'
-    },
-    data_format: {
-      label: 'Data Format',
-      description:
-        'The way Google will interpret values. If you select raw, values will not be parsed and will be stored as-is. If you select user entered, values will be parsed as if you typed them into the UI. Numbers will stay as numbers, but strings may be converted to numbers, dates, etc. following the same rules that are applied when entering text into a cell via the Google Sheets UI.',
-      type: 'string',
-      required: true,
-      default: 'RAW',
-      choices: [
-        { label: 'Raw', value: 'RAW' },
-        { label: 'User Entered', value: 'USER_ENTERED' }
-      ]
-    },
-    fields: {
-      label: 'Fields',
-      description: `
-  The fields to write to the spreadsheet. 
-
-  On the left-hand side, input the name of the field as it will appear in the Google Sheet. 
-  
-  On the right-hand side, select the field from your data model that maps to the given field in your sheet.
-     
-  ---
-      
-  `,
-      type: 'object',
-      required: true,
-      defaultObjectUI: 'keyvalue:only'
-    },
-    enable_batching: {
-      type: 'boolean',
-      label: 'Batch Data to Google Sheets',
-      description: 'Set as true to ensure Segment sends data to Google Sheets in batches. Please do not set to false.',
-      default: true
-    }
-  },
-  perform: (request, { payload }) => {
-    return processData(request, [payload])
-  },
-  performBatch: (request, { payload }) => {
-    return processData(request, payload)
-  }
-}
-
-export default action
diff --git a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/operations.ts b/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/operations.ts
deleted file mode 100644
index 0b4a33ce..00000000
--- a/packages/destination-actions/src/destinations/google-sheets-partner/postSheet/operations.ts
+++ /dev/null
@@ -1,232 +0,0 @@
-import type { Payload } from './generated-types'
-import { IntegrationError, RequestClient } from '@segment/actions-core'
-import { GoogleSheets, GetResponse } from '../googleapis/index'
-import { CONSTANTS } from '../constants'
-
-import A1 from '@segment/a1-notation'
-
-type Fields = {
-  [k: string]: string
-}
-
-interface Identifiable {
-  identifier: string
-}
-
-interface Indexable {
-  index: number
-}
-
-type UpdateBatch = Identifiable & Indexable & { event: Fields }
-type AppendBatch = Identifiable & { event: Fields }
-
-/**
- * Invariant settings that are common to all events in the payload.
- */
-export type MappingSettings = {
-  spreadsheetId: string
-  spreadsheetName: string
-  dataFormat: string
-  columns: string[]
-}
-
-// The data in the spreadsheet begins in row 2, because it's assumed that the first row will contain the column names.
-const DATA_ROW_OFFSET = 2
-
-/**
- * Utility function that converts the event properties into an array of strings that Google Sheets API can understand.
- * Note that the identifier is forced as the first column. 
- * @param identifier value used to imbue fields with a uniqueness constraint
- * @param fields list of properties contained in the event
- * @param columns list of properties that will be committed to the spreadsheet
- * @returns a string object that has used the `fields` data to populate the `columns` ordering
- * 
- * @example
- * fields: 
-    {
-      "CLOSE_DATE": "2022-07-08T00:00:00Z",
-      "CLOSE_DATE_EOQ": "2022-07-08",
-      "ENTRY_POINT": "Website Demo Request",
-      "E_ARR_POST_LAUNCH_C": "100000.0",
-      "FINANCE_ENTRY_POINT": "Inbound High Intent"
-    } 
-    columns: ["ENTRY_POINT", "MISSING_COLUMN", "CLOSE_DATE"]
-
-    return => ["Website Demo Request", "", "2022-07-08T00:00:00Z"]
-
- */
-const generateColumnValuesFromFields = (identifier: string, fields: Fields, columns: string[]) => {
-  const retVal = columns.map((col) => fields[col] ?? '')
-  retVal.unshift(identifier) // Write identifier as first column
-  return retVal
-}
-
-/**
- * Processes the response of the Google Sheets GET call and parses the events into separate operation buckets.
- * @param response result of the Google Sheets API get call
- * @param events data to be written to the spreadsheet
- * @returns
- */
-function processGetSpreadsheetResponse(response: GetResponse, events: Payload[], mappingSettings: MappingSettings) {
-  const numColumns = mappingSettings.columns.length
-  const numRows = response.values?.length
-
-  if (numRows * numColumns > CONSTANTS.MAX_CELLS) {
-    throw new IntegrationError('Sheet has reached maximum limit', 'INVALID_REQUEST_DATA', 400)
-  }
-
-  const updateBatch: UpdateBatch[] = []
-  const appendBatch: AppendBatch[] = []
-
-  // Use a hashmap to efficiently find if the event already exists in the spreadsheet (update) or not (append).
-  const eventMap = new Map(events.map((e) => [e.record_identifier, e]))
-
-  if (response.values && response.values.length > 0) {
-    for (let i = 0; i < response.values.length; i++) {
-      const targetIdentifier = response.values[i][0]
-      if (eventMap.has(targetIdentifier)) {
-        // The event being processed already exists in the spreadsheet.
-        const targetEvent = eventMap.get(targetIdentifier) as Payload
-        if (targetEvent.operation_type != 'deleted') {
-          updateBatch.push({
-            identifier: targetIdentifier,
-            event: targetEvent.fields as Fields,
-            index: i
-          })
-        }
-        eventMap.delete(targetIdentifier)
-      }
-    }
-  }
-
-  // At this point, eventMap contains all the rows we couldn't find in the spreadsheet.
-  eventMap.forEach((value, key) => {
-    // If delete, just drop event
-    if (value.operation_type != 'deleted') {
-      appendBatch.push({
-        identifier: key,
-        event: value.fields as Fields
-      })
-    }
-  })
-
-  return { appendBatch, updateBatch }
-}
-
-/**
- * Commits all passed events to the correct row in the spreadsheet, as well as the columns header row.
- * @param mappingSettings configuration object detailing parameters for the call
- * @param updateBatch array of events to commit to the spreadsheet
- * @param gs interface object capable of interacting with Google Sheets API
- */
-async function processUpdateBatch(mappingSettings: MappingSettings, updateBatch: UpdateBatch[], gs: GoogleSheets) {
-  // Utility function used to calculate which range an event should be written to
-  const getRange = (targetIndex: number, columnCount: number) => {
-    const targetRange = new A1(1, targetIndex)
-    targetRange.addX(columnCount)
-    return targetRange.toString()
-  }
-
-  const batchPayload = updateBatch.map(({ identifier, event, index }) => {
-    // Flatten event fields to be just the values
-    const values = generateColumnValuesFromFields(identifier, event, mappingSettings.columns)
-    return {
-      range: `${mappingSettings.spreadsheetName}!${getRange(index + DATA_ROW_OFFSET, values.length)}`,
-      values: [values]
-    }
-  })
-
-  // Always add to the payload a write to the first row (containing column names) in case that columns have been updated
-  const headerRowRange = new A1(1, 1, 1, mappingSettings.columns.length + 1)
-  batchPayload.push({
-    range: `${mappingSettings.spreadsheetName}!${headerRowRange.toString()}`,
-    values: [['id', ...mappingSettings.columns]]
-  })
-
-  return gs.batchUpdate(mappingSettings, batchPayload)
-}
-
-// TODO: Re-enable delete once locking is supported.
-/**
- * Clears all passed events from the spreadsheet.
- * @param mappingSettings configuration object detailing parameters for the call
- * @param updateBatch array of events to clear from the spreadsheet
- * @param gs interface object capable of interacting with Google Sheets API
- */
-// async function processDeleteBatch(
-//   mappingSettings: MappingSettings,
-//   deleteBatch: { identifier: string; targetIndex: number }[],
-//   gs: GoogleSheets
-// ) {
-//   if (deleteBatch.length <= 0) {
-//     return
-//   }
-
-//   // TODO: fix a1-notation package to support 1:1 notation
-//   const deletePayload = deleteBatch.map(({ targetIndex }) => {
-//     return {
-//       range: `${mappingSettings.spreadsheetName}!${targetIndex}:${targetIndex}`
-//     }
-//   })
-
-//   return gs
-//     .batchClear(mappingSettings, deletePayload)
-//     .then(() => {
-//       console.log('delete')
-//     })
-//     .catch((error) => {
-//       console.log(error)
-//     })
-// }
-
-/**
- * Commits all passed events to the bottom of the spreadsheet.
- * @param mappingSettings configuration object detailing parameters for the call
- * @param appendBatch array of events to commit to the spreadsheet
- * @param gs interface object capable of interacting with Google Sheets API
- * @returns
- */
-async function processAppendBatch(mappingSettings: MappingSettings, appendBatch: AppendBatch[], gs: GoogleSheets) {
-  if (appendBatch.length <= 0) {
-    return
-  }
-
-  // Flatten event fields to be just the values
-  const values = appendBatch.map(({ identifier, event }) =>
-    generateColumnValuesFromFields(identifier, event, mappingSettings.columns)
-  )
-
-  return gs.append(mappingSettings, `A${DATA_ROW_OFFSET}`, values)
-}
-
-/**
- * Takes an array of events and dynamically decides whether to append, update or delete rows from the spreadsheet.
- * @param request request object used to perform HTTP calls
- * @param events array of events to commit to the spreadsheet
- */
-async function processData(request: RequestClient, events: Payload[]) {
-  // These are assumed to be constant across all events
-  const mappingSettings = {
-    spreadsheetId: events[0].spreadsheet_id,
-    spreadsheetName: events[0].spreadsheet_name,
-    dataFormat: events[0].data_format,
-    columns: Object.getOwnPropertyNames(events[0].fields)
-  }
-
-  const gs: GoogleSheets = new GoogleSheets(request)
-
-  // Get all of the row identifiers (assumed to be in the first column A)
-  const response = await gs.get(mappingSettings, `A${DATA_ROW_OFFSET}:A`)
-
-  // Use the retrieved row identifiers along with the incoming events to decide which ones should be appended or updated.
-  const { appendBatch, updateBatch } = processGetSpreadsheetResponse(response.data, events, mappingSettings)
-
-  const promises = [
-    processUpdateBatch(mappingSettings, updateBatch, gs),
-    processAppendBatch(mappingSettings, appendBatch, gs)
-  ]
-
-  return await Promise.all(promises)
-}
-
-export { processData }
diff --git a/packages/destination-actions/src/destinations/hubspot/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/hubspot/__tests__/__snapshots__/snapshot.test.ts.snap
index f11f1f01..7c3ba87b 100644
--- a/packages/destination-actions/src/destinations/hubspot/__tests__/__snapshots__/snapshot.test.ts.snap
+++ b/packages/destination-actions/src/destinations/hubspot/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -19,9 +19,33 @@ Object {
 }
 `;
 
-exports[`Testing snapshot for actions-hubspot-cloud destination: upsertCompany action - all fields 1`] = `[IntegrationError: Identify (Upsert Contact) must be called before Group (Upsert Company) for the HubSpot Cloud (Actions) destination.]`;
+exports[`Testing snapshot for actions-hubspot-cloud destination: upsertCompany action - all fields 1`] = `
+Object {
+  "properties": Object {
+    "address": "xz1CFcz1FfyLPZgppeg",
+    "city": "xz1CFcz1FfyLPZgppeg",
+    "description": "xz1CFcz1FfyLPZgppeg",
+    "domain": "xz1CFcz1FfyLPZgppeg",
+    "industry": "xz1CFcz1FfyLPZgppeg",
+    "lifecyclestage": "xz1cfcz1ffylpzgppeg",
+    "name": "xz1CFcz1FfyLPZgppeg",
+    "numberofemployees": 6931055592341504,
+    "phone": "xz1CFcz1FfyLPZgppeg",
+    "segment_group_id": "xz1CFcz1FfyLPZgppeg",
+    "state": "xz1CFcz1FfyLPZgppeg",
+    "testType": "xz1CFcz1FfyLPZgppeg",
+    "zip": "xz1CFcz1FfyLPZgppeg",
+  },
+}
+`;
 
-exports[`Testing snapshot for actions-hubspot-cloud destination: upsertCompany action - required fields 1`] = `[IntegrationError: Identify (Upsert Contact) must be called before Group (Upsert Company) for the HubSpot Cloud (Actions) destination.]`;
+exports[`Testing snapshot for actions-hubspot-cloud destination: upsertCompany action - required fields 1`] = `
+Object {
+  "properties": Object {
+    "segment_group_id": "xz1CFcz1FfyLPZgppeg",
+  },
+}
+`;
 
 exports[`Testing snapshot for actions-hubspot-cloud destination: upsertContact action - all fields 1`] = `
 Object {
diff --git a/packages/destination-actions/src/destinations/hubspot/errors.ts b/packages/destination-actions/src/destinations/hubspot/errors.ts
index e69913af..a36c013e 100644
--- a/packages/destination-actions/src/destinations/hubspot/errors.ts
+++ b/packages/destination-actions/src/destinations/hubspot/errors.ts
@@ -12,7 +12,7 @@ export class HubSpotError extends HTTPError {
   }
 }
 export const MissingIdentityCallThrowableError = new IntegrationError(
-  'Identify (Upsert Contact) must be called before Group (Upsert Company) for the HubSpot Cloud (Actions) destination.',
+  'Identify (Upsert Contact) must be called before Group (Upsert Company) for the HubSpot Cloud (Actions) destination if ’Associate Contact with Company’ property is set to Yes (true).',
   'Missing Identity Call',
   400
 )
diff --git a/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/index.test.ts.snap b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/index.test.ts.snap
new file mode 100644
index 00000000..18a033d5
--- /dev/null
+++ b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/index.test.ts.snap
@@ -0,0 +1,413 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 2`] = `
+Object {
+  "filterGroups": Array [
+    Object {
+      "filters": Array [
+        Object {
+          "operator": "EQ",
+          "propertyName": "domain",
+          "value": "test-company.com",
+        },
+      ],
+    },
+  ],
+  "properties": Array [
+    "name",
+    "domain",
+    "lifecyclestage",
+    "segment_group_id",
+  ],
+  "sorts": Array [
+    "name",
+  ],
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 3`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 4`] = `
+Object {
+  "description": "Unique Property to map Segment Group ID with a HubSpot Company Object",
+  "displayOrder": -1,
+  "fieldType": "text",
+  "formField": false,
+  "groupName": "companyinformation",
+  "hasUniqueValue": true,
+  "hidden": true,
+  "label": "Segment Group ID",
+  "name": "segment_group_id",
+  "type": "string",
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 5`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 6`] = `undefined`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 2`] = `
+Object {
+  "filterGroups": Array [
+    Object {
+      "filters": Array [
+        Object {
+          "operator": "EQ",
+          "propertyName": "domain",
+          "value": "test-company.com",
+        },
+      ],
+    },
+  ],
+  "properties": Array [
+    "name",
+    "domain",
+    "lifecyclestage",
+    "segment_group_id",
+  ],
+  "sorts": Array [
+    "name",
+  ],
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 3`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 4`] = `
+Object {
+  "description": "Unique Property to map Segment Group ID with a HubSpot Company Object",
+  "displayOrder": -1,
+  "fieldType": "text",
+  "formField": false,
+  "groupName": "companyinformation",
+  "hasUniqueValue": true,
+  "hidden": true,
+  "label": "Segment Group ID",
+  "name": "segment_group_id",
+  "type": "string",
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 5`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found 6`] = `undefined`;
+
+exports[`HubSpot.upsertCompany should create a company with and associate a contact 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create a company with and associate a contact 2`] = `
+Object {
+  "filterGroups": Array [
+    Object {
+      "filters": Array [
+        Object {
+          "operator": "EQ",
+          "propertyName": "domain",
+          "value": "test-company.com",
+        },
+      ],
+    },
+  ],
+  "properties": Array [
+    "name",
+    "domain",
+    "lifecyclestage",
+    "segment_group_id",
+  ],
+  "sorts": Array [
+    "name",
+  ],
+}
+`;
+
+exports[`HubSpot.upsertCompany should create a company with and associate a contact 3`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should create a company with and associate a contact 4`] = `undefined`;
+
+exports[`HubSpot.upsertCompany should not associate contact if associateContact flag is set to false 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should skip creating a company if createNewCompany flag is set to false 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should skip creating a company if createNewCompany flag is set to false 2`] = `
+Object {
+  "filterGroups": Array [
+    Object {
+      "filters": Array [
+        Object {
+          "operator": "EQ",
+          "propertyName": "domain",
+          "value": "test-company.com",
+        },
+      ],
+    },
+  ],
+  "properties": Array [
+    "name",
+    "domain",
+    "lifecyclestage",
+    "segment_group_id",
+  ],
+  "sorts": Array [
+    "name",
+  ],
+}
+`;
+
+exports[`HubSpot.upsertCompany should update a company with Company Search Fields and associate a contact 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should update a company with Company Search Fields and associate a contact 2`] = `
+Object {
+  "filterGroups": Array [
+    Object {
+      "filters": Array [
+        Object {
+          "operator": "EQ",
+          "propertyName": "domain",
+          "value": "test-company.com",
+        },
+      ],
+    },
+  ],
+  "properties": Array [
+    "name",
+    "domain",
+    "lifecyclestage",
+    "segment_group_id",
+  ],
+  "sorts": Array [
+    "name",
+  ],
+}
+`;
+
+exports[`HubSpot.upsertCompany should update a company with Company Search Fields and associate a contact 3`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should update a company with Company Search Fields and associate a contact 4`] = `undefined`;
+
+exports[`HubSpot.upsertCompany should update a company with SEGMENT_UNIQUE_IDENTIFIER and associate a contact 1`] = `
+Object {
+  "properties": Object {
+    "address": undefined,
+    "city": undefined,
+    "description": undefined,
+    "domain": "test-company.com",
+    "industry": undefined,
+    "lifecyclestage": undefined,
+    "name": "Test Company",
+    "numberofemployees": undefined,
+    "phone": undefined,
+    "segment_group_id": "test-group-id",
+    "state": undefined,
+    "zip": undefined,
+  },
+}
+`;
+
+exports[`HubSpot.upsertCompany should update a company with SEGMENT_UNIQUE_IDENTIFIER and associate a contact 2`] = `undefined`;
diff --git a/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/snapshot.test.ts.snap
index e3310746..f83a121f 100644
--- a/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/snapshot.test.ts.snap
+++ b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -23,7 +23,6 @@ Object {
 exports[`Testing snapshot for HubSpot's upsertCompany destination action: required fields 1`] = `
 Object {
   "properties": Object {
-    "name": "F9hZOtvgHY(T6dF5vS7",
     "segment_group_id": "F9hZOtvgHY(T6dF5vS7",
   },
 }
diff --git a/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/index.test.ts b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/index.test.ts
index cfaf8d40..67e928a2 100644
--- a/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/hubspot/upsertCompany/__tests__/index.test.ts
@@ -1,5 +1,5 @@
 import nock from 'nock'
-import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { createTestEvent, createTestIntegration, DecoratedResponse } from '@segment/actions-core'
 import Destination from '../../index'
 import { HUBSPOT_BASE_URL, SEGMENT_UNIQUE_IDENTIFIER, ASSOCIATION_TYPE } from '../../properties'
 import {
@@ -10,11 +10,14 @@ import {
   SegmentUniqueIdentifierMissingRetryableError
 } from '../../errors'
 
-const testDestination = createTestIntegration(Destination)
+let testDestination = createTestIntegration(Destination)
 
 const setTransaction = () => {}
 
 beforeEach((done) => {
+  // Re-Initialize the destination before each test
+  // This is done to mitigate a bug where action responses persist into other tests
+  testDestination = createTestIntegration(Destination)
   nock.cleanAll()
   done()
 })
@@ -28,6 +31,8 @@ const defaultGroupMapping = {
       else: { '@path': '$.context.groupId' }
     }
   },
+  createNewCompany: true,
+  associateContact: true,
   name: {
     '@path': '$.traits.name'
   },
@@ -70,8 +75,17 @@ const defaultGroupMapping = {
   // properties: {}
 }
 
+// Helper function to check length of responses, match status code and snapshot
+const checkResponses = (responses: DecoratedResponse[], expectedResponseCodes: number[]) => {
+  expect(responses).toHaveLength(expectedResponseCodes.length)
+  for (let i = 0; i < responses.length; i++) {
+    expect(responses[i].status).toEqual(expectedResponseCodes[i])
+    expect(responses[i].options.json).toMatchSnapshot()
+  }
+}
+
 describe('HubSpot.upsertCompany', () => {
-  it('should throw an error if contact_id is missing in transactionContext', async () => {
+  it('should throw an error if associateContact flag is set to true and contact_id is missing in transactionContext', async () => {
     const event = createTestEvent({
       type: 'group',
       traits: {
@@ -85,12 +99,7 @@ describe('HubSpot.upsertCompany', () => {
       testDestination.testAction('upsertCompany', {
         event,
         mapping: {
-          ...defaultGroupMapping,
-          companysearchfields: {
-            domain: {
-              '@path': '$.traits.website'
-            }
-          }
+          ...defaultGroupMapping
         },
         transactionContext: {
           transaction: {},
@@ -171,12 +180,7 @@ describe('HubSpot.upsertCompany', () => {
     const responses = await testDestination.testAction('upsertCompany', {
       event,
       mapping: {
-        ...defaultGroupMapping,
-        companysearchfields: {
-          domain: {
-            '@path': '$.traits.website'
-          }
-        }
+        ...defaultGroupMapping
       },
       transactionContext: {
         transaction: {
@@ -186,8 +190,8 @@ describe('HubSpot.upsertCompany', () => {
       }
     })
 
-    expect(responses[0].status).toEqual(200)
-    expect(responses[1].status).toEqual(200)
+    const expectedResponseCodes = [200, 200]
+    checkResponses(responses, expectedResponseCodes)
   })
 
   it('should update a company with Company Search Fields and associate a contact', async () => {
@@ -310,10 +314,8 @@ describe('HubSpot.upsertCompany', () => {
       }
     })
 
-    expect(responses[0].status).toEqual(404)
-    expect(responses[1].status).toEqual(200)
-    expect(responses[2].status).toEqual(200)
-    expect(responses[3].status).toEqual(200)
+    const expectedResponseCodes = [404, 200, 200, 200]
+    checkResponses(responses, expectedResponseCodes)
   })
 
   it('should create a company with and associate a contact', async () => {
@@ -419,10 +421,8 @@ describe('HubSpot.upsertCompany', () => {
       }
     })
 
-    expect(responses[0].status).toEqual(404)
-    expect(responses[1].status).toEqual(200)
-    expect(responses[2].status).toEqual(201)
-    expect(responses[3].status).toEqual(200)
+    const expectedResponseCodes = [404, 200, 201, 200]
+    checkResponses(responses, expectedResponseCodes)
   })
 
   it('should create SEGMENT_UNIQUE_IDENTIFIER and create a company if SEGMENT_UNIQUE_IDENTIFIER property is not found', async () => {
@@ -566,12 +566,8 @@ describe('HubSpot.upsertCompany', () => {
       }
     })
 
-    expect(responses[0].status).toEqual(404)
-    expect(responses[1].status).toEqual(200)
-    expect(responses[2].status).toEqual(400)
-    expect(responses[3].status).toEqual(201)
-    expect(responses[4].status).toEqual(201)
-    expect(responses[5].status).toEqual(200)
+    const expectedResponseCodes = [404, 200, 400, 201, 201, 200]
+    checkResponses(responses, expectedResponseCodes)
   })
 
   it('should create SEGMENT_UNIQUE_IDENTIFIER and update a company if SEGMENT_UNIQUE_IDENTIFIER property is not found', async () => {
@@ -732,11 +728,8 @@ describe('HubSpot.upsertCompany', () => {
       }
     })
 
-    expect(responses[0].status).toEqual(404)
-    expect(responses[1].status).toEqual(200)
-    expect(responses[2].status).toEqual(400)
-    expect(responses[3].status).toEqual(201)
-    expect(responses[4].status).toEqual(200)
+    const expectedResponseCodes = [404, 200, 400, 201, 200, 200]
+    checkResponses(responses, expectedResponseCodes)
   })
 
   it('should throw an error if SEGMENT_UNIQUE_IDENTIFIER is defined in options', async () => {
@@ -1098,6 +1091,57 @@ describe('HubSpot.upsertCompany', () => {
     })
   })
 
+  it('should skip creating a company if createNewCompany flag is set to false', async () => {
+    const event = createTestEvent({
+      type: 'group',
+      traits: {
+        name: 'Test Company',
+        website: 'test-company.com'
+      },
+      groupId: 'test-group-id'
+    })
+
+    const contactId = '123456789'
+
+    // Mock: Failed to search company with SEGMENT_UNIQUE_IDENTIFIER
+    nock(HUBSPOT_BASE_URL)
+      .patch(`/crm/v3/objects/companies/${event.groupId}?idProperty=${SEGMENT_UNIQUE_IDENTIFIER}`)
+      .reply(404, {
+        status: 'error',
+        message: 'resource not found',
+        correlationId: 'aabbcc5b01-c9c7-4000-9191-000000000000'
+      })
+
+    // Mock: Search company returned no results
+    nock(HUBSPOT_BASE_URL).post('/crm/v3/objects/companies/search').reply(200, {
+      total: 0,
+      results: []
+    })
+
+    const responses = await testDestination.testAction('upsertCompany', {
+      event,
+      mapping: {
+        ...defaultGroupMapping,
+        // Disable create company flag
+        createNewCompany: false,
+        companysearchfields: {
+          domain: {
+            '@path': '$.traits.website'
+          }
+        }
+      },
+      transactionContext: {
+        transaction: {
+          contact_id: contactId
+        },
+        setTransaction
+      }
+    })
+
+    const expectedResponseCodes = [404, 200]
+    checkResponses(responses, expectedResponseCodes)
+  })
+
   it('should throw an error if updateCompany returns an unexpected HTTP error', async () => {
     const event = createTestEvent({
       type: 'group',
@@ -1353,6 +1397,148 @@ describe('HubSpot.upsertCompany', () => {
     })
   })
 
+  it('should not associate contact if associateContact flag is set to false', async () => {
+    const event = createTestEvent({
+      type: 'group',
+      traits: {
+        name: 'Test Company',
+        website: 'test-company.com'
+      },
+      groupId: 'test-group-id'
+    })
+
+    const contactId = '123456789'
+    const hubspotGeneratedCompanyID = '1000000000'
+
+    // Mock: Update company using SEGMENT_UNIQUE_IDENTIFIER
+    nock(HUBSPOT_BASE_URL)
+      .patch(`/crm/v3/objects/companies/${event.groupId}?idProperty=${SEGMENT_UNIQUE_IDENTIFIER}`)
+      .reply(200, {
+        id: hubspotGeneratedCompanyID,
+        properties: {
+          createdate: '2022-10-13T17:57:46.778Z',
+          hs_all_owner_ids: '100000000',
+          hs_created_by_user_id: '10000000',
+          hs_lastmodifieddate: '2022-10-13T17:58:14.622Z',
+          hs_object_id: hubspotGeneratedCompanyID,
+          hs_pipeline: 'companies-lifecycle-pipeline',
+          hs_updated_by_user_id: '10000000',
+          hs_user_ids_of_all_owners: '10000000',
+          hubspot_owner_assigneddate: '2022-10-13T17:57:46.778Z',
+          hubspot_owner_id: '100000000',
+          lifecyclestage: 'lead',
+          segment_group_id: event?.groupId
+        },
+        createdAt: '2022-10-13T17:57:46.778Z',
+        updatedAt: '2022-10-13T17:58:14.622Z',
+        archived: false
+      })
+
+    const responses = await testDestination.testAction('upsertCompany', {
+      event,
+      mapping: {
+        ...defaultGroupMapping,
+        associateContact: false
+      },
+      transactionContext: {
+        transaction: {
+          contact_id: contactId
+        },
+        setTransaction
+      }
+    })
+
+    const expectedResponseCodes = [200]
+    checkResponses(responses, expectedResponseCodes)
+  })
+
+  it('should throw an error if associateContact flag is set to true and contact doesn’t exist', async () => {
+    const event = createTestEvent({
+      type: 'group',
+      traits: {
+        name: 'Test Company',
+        website: 'test-company.com'
+      },
+      groupId: 'test-group-id'
+    })
+
+    const contactId = '123456789'
+    const hubspotGeneratedCompanyID = '1000000000'
+
+    const errorResponse = {
+      status: 'error',
+      message: `No contact with ID ${contactId} exists`,
+      correlationId: 'aabbcc5b01-c9c7-4000-9191-000000000000',
+      category: 'OBJECT_NOT_FOUND'
+    }
+
+    // Mock: Update company using SEGMENT_UNIQUE_IDENTIFIER
+    nock(HUBSPOT_BASE_URL)
+      .patch(`/crm/v3/objects/companies/${event.groupId}?idProperty=${SEGMENT_UNIQUE_IDENTIFIER}`)
+      .reply(200, {
+        id: hubspotGeneratedCompanyID,
+        properties: {
+          createdate: '2022-10-13T17:57:46.778Z',
+          hs_all_owner_ids: '100000000',
+          hs_created_by_user_id: '10000000',
+          hs_lastmodifieddate: '2022-10-13T17:58:14.622Z',
+          hs_object_id: hubspotGeneratedCompanyID,
+          hs_pipeline: 'companies-lifecycle-pipeline',
+          hs_updated_by_user_id: '10000000',
+          hs_user_ids_of_all_owners: '10000000',
+          hubspot_owner_assigneddate: '2022-10-13T17:57:46.778Z',
+          hubspot_owner_id: '100000000',
+          lifecyclestage: 'lead',
+          segment_group_id: event?.groupId
+        },
+        createdAt: '2022-10-13T17:57:46.778Z',
+        updatedAt: '2022-10-13T17:58:14.622Z',
+        archived: false
+      })
+
+    // Mock: Associate a contact with company
+    nock(HUBSPOT_BASE_URL)
+      .put(
+        `/crm/v3/objects/companies/${hubspotGeneratedCompanyID}/associations/contacts/${contactId}/${ASSOCIATION_TYPE}`
+      )
+      .reply(404, {
+        status: 'error',
+        message: `No contact with ID ${contactId} exists`,
+        correlationId: 'aabbcc5b01-c9c7-4000-9191-000000000000',
+        context: {
+          objectType: ['contact'],
+          id: [contactId]
+        },
+        category: 'OBJECT_NOT_FOUND',
+        subCategory: 'crm.associations.TO_OBJECT_NOT_FOUND'
+      })
+
+    await expect(
+      testDestination.testAction('upsertCompany', {
+        event,
+        mapping: {
+          ...defaultGroupMapping,
+          companysearchfields: {
+            domain: {
+              '@path': '$.traits.website'
+            }
+          }
+        },
+        transactionContext: {
+          transaction: {
+            contact_id: contactId
+          },
+          setTransaction
+        }
+      })
+    ).rejects.toMatchObject({
+      response: {
+        status: 404,
+        data: errorResponse
+      }
+    })
+  })
+
   // Special Case: If a company already has a SEGMENT_UNIQUE_IDENTIFIER property value, but the property is later deleted from HubSpot
   // the search would still find the correct company, but the update would fail with a 400 error stating property doesn't exist
   // Segment will attempt to create the SEGMENT_UNIQUE_IDENTIFIER property and throw a retryable error to Centrifuge
diff --git a/packages/destination-actions/src/destinations/hubspot/upsertCompany/generated-types.ts b/packages/destination-actions/src/destinations/hubspot/upsertCompany/generated-types.ts
index bdf7a2cb..ed9debff 100644
--- a/packages/destination-actions/src/destinations/hubspot/upsertCompany/generated-types.ts
+++ b/packages/destination-actions/src/destinations/hubspot/upsertCompany/generated-types.ts
@@ -2,19 +2,27 @@
 
 export interface Payload {
   /**
-   * Used for constructing the unique segment_group_id for HubSpot.
+   * A unique identifier you assign to a company. Segment creates a custom property in HubSpot to store this value for each company so it can be used as a unique search field. Segment recommends not changing this value once set to avoid creating duplicate companies.
    */
   groupid: string
+  /**
+   * If true, Segment will attempt to update an existing company in HubSpot and if no company is found, Segment will create a new company. If false, Segment will only attempt to update an existing company and never create a new company. This is set to true by default.
+   */
+  createNewCompany: boolean
+  /**
+   * If true, Segment will associate the company with the user identified in your payload. If no contact is found in HubSpot, an error is thrown and the company is not created/updated. If false, Segment will not attempt to associate a contact with the company and companies can be created/updated without requiring a contact association. This is set to true by default.
+   */
+  associateContact: boolean
   /**
    * The unique field(s) used to search for an existing company in HubSpot to update. By default, Segment creates a custom property to store groupId for each company and uses this property to search for companies. If a company is not found, the fields provided here are then used to search. If a company is still not found, a new one is created.
    */
-  companysearchfields: {
+  companysearchfields?: {
     [k: string]: unknown
   }
   /**
    * The name of the company.
    */
-  name: string
+  name?: string
   /**
    * A short statement about the company’s mission and goals.
    */
diff --git a/packages/destination-actions/src/destinations/hubspot/upsertCompany/index.ts b/packages/destination-actions/src/destinations/hubspot/upsertCompany/index.ts
index 8a523cd4..6a6e4345 100644
--- a/packages/destination-actions/src/destinations/hubspot/upsertCompany/index.ts
+++ b/packages/destination-actions/src/destinations/hubspot/upsertCompany/index.ts
@@ -83,8 +83,8 @@ type UpsertCompanyFunction = () => Promise<ModifiedResponse<UpsertCompanyRespons
 
 /**
  * Upsert Company Action works as follows:
- * 1. Check if contact_id is available in transactionContext,
- *    if not available throw error, else continue to step 2
+ * 1. Check if associateContact flag is set to true AND contact_id is not defined in transactionContext,
+ *    if the above condition is true then throw error, else continue to step 2
  * 2. Check if internal property SEGMENT_UNIQUE_IDENTIFIER is re-defined in other properties,
  *    if defined throw error, else continue to step 3
  * 3. Try to update the company using SEGMENT_UNIQUE_IDENTIFIER
@@ -96,27 +96,34 @@ type UpsertCompanyFunction = () => Promise<ModifiedResponse<UpsertCompanyRespons
  * 4. If Company Search Fields are defined, attempt to search for a Company
  *    Case a: If company is not found, move to Step 5
  *    Case b: If a company is found, move to Step 6
- * 5. An existing company was not found, create a new company
- *    case a: If company is created, move to Step 7
- *    case b: If company is not created due to missing SEGMENT_UNIQUE_IDENTIFIER
+ * 5. An existing company was not found, try creating a company
+ *    Case a: If createNewCompany flag is set to false, exit the flow without creating a company
+ *    Case b: If company is created, move to Step 7
+ *    Case c: If company is not created due to missing SEGMENT_UNIQUE_IDENTIFIER
  *            create the property and retry creation of company, move to Step 7 if it succeeds
- *    Case c: If any other error occurs in the flow, throw the error
+ *    Case d: If any other error occurs in the flow, throw the error
  * 6. Existing company is found, update the company with new properties
- *    case a: If company is updated, move to Step 7
- *    case b: If company is not updated due to missing SEGMENT_UNIQUE_IDENTIFIER
+ *    Case a: If company is updated, move to Step 7
+ *    Case b: If company is not updated due to missing SEGMENT_UNIQUE_IDENTIFIER
  *            create the property and retry to update of company, move to Step 7 if it succeeds
  *    Case c: If any other error occurs in the flow, throw the error
- * 7. Associate company with Contact ID from transactionContext, throw error if any
+ * 7. Check if associateContact flag is set to true
+ *    Case a: If true, associate company with Contact ID from transactionContext, throw error if any
+ *    Case b: If false, skip association of contact with company
  */
+
+// Note: Some of the action fields are not in Camel Case to maintain parity with HubSpot API
+
 const action: ActionDefinition<Settings, Payload> = {
   title: 'Upsert Company',
   description: 'Create or update a company in HubSpot.',
   defaultSubscription: 'type = "group"',
   fields: {
     groupid: {
-      label: 'Group ID',
-      description: `Used for constructing the unique ${SEGMENT_UNIQUE_IDENTIFIER} for HubSpot.`,
-      type: 'hidden',
+      label: 'Unique Company Identifier',
+      description:
+        'A unique identifier you assign to a company. Segment creates a custom property in HubSpot to store this value for each company so it can be used as a unique search field. Segment recommends not changing this value once set to avoid creating duplicate companies.',
+      type: 'string',
       required: true,
       default: {
         '@if': {
@@ -126,19 +133,33 @@ const action: ActionDefinition<Settings, Payload> = {
         }
       }
     },
+    createNewCompany: {
+      label: 'Create Company if Not Found',
+      description:
+        'If true, Segment will attempt to update an existing company in HubSpot and if no company is found, Segment will create a new company. If false, Segment will only attempt to update an existing company and never create a new company. This is set to true by default.',
+      type: 'boolean',
+      required: true,
+      default: true
+    },
+    associateContact: {
+      label: 'Associate Contact with Company',
+      description:
+        'If true, Segment will associate the company with the user identified in your payload. If no contact is found in HubSpot, an error is thrown and the company is not created/updated. If false, Segment will not attempt to associate a contact with the company and companies can be created/updated without requiring a contact association. This is set to true by default.',
+      type: 'boolean',
+      required: true,
+      default: true
+    },
     companysearchfields: {
       label: 'Company Search Fields',
       description:
         'The unique field(s) used to search for an existing company in HubSpot to update. By default, Segment creates a custom property to store groupId for each company and uses this property to search for companies. If a company is not found, the fields provided here are then used to search. If a company is still not found, a new one is created.',
       type: 'object',
-      required: true,
       defaultObjectUI: 'keyvalue:only'
     },
     name: {
       label: 'Company Name',
       description: 'The name of the company.',
       type: 'string',
-      required: true,
       default: {
         '@path': '$.traits.name'
       }
@@ -239,8 +260,8 @@ const action: ActionDefinition<Settings, Payload> = {
       throw RestrictedPropertyThrowableError
     }
 
-    // Check if transactionContext is defined and contact_id is present in TransactionContext
-    if (!transactionContext?.transaction?.contact_id) {
+    // If associateContact field is set to true, check if transactionContext is defined and contact_id is present in TransactionContext
+    if (payload.associateContact && !transactionContext?.transaction?.contact_id) {
       throw MissingIdentityCallThrowableError
     }
 
@@ -318,6 +339,11 @@ const action: ActionDefinition<Settings, Payload> = {
       if (!searchCompanyResponse || searchCompanyResponse.data.total === 0) {
         // No existing company found with search criteria, attempt to create a new company
 
+        // If Create New Company flag is set to false, skip creation
+        if (!payload.createNewCompany) {
+          return
+        }
+
         // Create a wrapper function which calls createCompany and returns the response
         const createCompanyWrapper = function () {
           return createCompany(request, companyProperties)
@@ -342,13 +368,10 @@ const action: ActionDefinition<Settings, Payload> = {
       }
     }
 
-    // If upsert company is successful, associate company with contact
-    await associateCompanyToContact(
-      request,
-      companyId,
-      transactionContext?.transaction?.['contact_id'],
-      ASSOCIATION_TYPE
-    )
+    // Associate company with contact if Associate Contact flag is set to true
+    if (payload.associateContact && transactionContext?.transaction?.contact_id) {
+      await associateCompanyToContact(request, companyId, transactionContext.transaction.contact_id, ASSOCIATION_TYPE)
+    }
   }
 }
 
diff --git a/packages/destination-actions/src/destinations/index.ts b/packages/destination-actions/src/destinations/index.ts
index ee702674..2e65edd3 100644
--- a/packages/destination-actions/src/destinations/index.ts
+++ b/packages/destination-actions/src/destinations/index.ts
@@ -49,7 +49,6 @@ register('615c7438d93d9b61b1e9e192', './mixpanel')
 register('61a8032ea5f157ee37a720be', './metronome')
 register('620feaa207e70f6c6a765ff7', './moengage')
 register('62df16e45ba0058c864a75d1', './actions-pardot')
-register('637c12fa86e32b125be33bca', './actions-bingads')
 register('5f7dd8191ad74f868ab1fc48', './pipedrive')
 register('62e17e6f687e4a3d32d0f875', './qualtrics')
 register('61957755c4d820be968457de', './salesforce')
@@ -64,11 +63,11 @@ register('61dc4e96894a6d7954cc6e45', './voyage')
 register('62ded0cf5753c743883ca0f3', './intercom')
 register('631a6f32946dd8197e9cab66', './sendgrid')
 register('632b1116e0cb83902f3fd717', './hubspot')
-register('635fea9131814aa2aa18a640', './google-sheets-partner')
 register('636d38db78d7834347d76c44', './1plusx-asset-api')
 register('6371eee1ae5e324869aa8b1b', './segment')
-register('637c12fa86e32b125be33bca', './actions-bingads')
 register('63936c37dbc54a052e34e30e', './google-sheets-dev')
+register('63872c01c0c112b9b4d75412', './braze-cohorts')
+register('639c2dbb1309fdcad13951b6', './segment-profiles')
 
 function register(id: MetadataId, destinationPath: string) {
   // eslint-disable-next-line @typescript-eslint/no-var-requires
diff --git a/packages/destination-actions/src/destinations/mixpanel/index.ts b/packages/destination-actions/src/destinations/mixpanel/index.ts
index 28efed7b..d229f162 100644
--- a/packages/destination-actions/src/destinations/mixpanel/index.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/index.ts
@@ -93,7 +93,7 @@ const destination: DestinationDefinition<Settings> = {
         label: 'Source Name',
         description:
           "This value, if it's not blank, will be sent as segment_source_name to Mixpanel for every event/page/screen call.",
-        type: 'string'
+        type: 'string',
       },
       strictMode: {
         label: 'Strict Mode',
diff --git a/packages/destination-actions/src/destinations/mixpanel/mixpanel-properties.ts b/packages/destination-actions/src/destinations/mixpanel/mixpanel-properties.ts
index ef7052bd..79d032f9 100644
--- a/packages/destination-actions/src/destinations/mixpanel/mixpanel-properties.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/mixpanel-properties.ts
@@ -40,7 +40,8 @@ export const eventProperties: Record<string, InputField> = {
   insert_id: {
     label: 'Insert ID',
     type: 'string',
-    description: 'A random id that is unique to an event. Mixpanel uses $insert_id to deduplicate events.',
+    description:
+      'A random id that is unique to an event. Mixpanel uses $insert_id to deduplicate events.',
     default: {
       '@path': '$.messageId'
     }
@@ -301,7 +302,8 @@ export const eventProperties: Record<string, InputField> = {
   },
   context: {
     label: 'Event context',
-    description: 'An object of key-value pairs that provides useful context about the event.',
+    description:
+      'An object of key-value pairs that provides useful context about the event.',
     type: 'object',
     default: {
       '@path': '$.context'
@@ -360,37 +362,44 @@ export const productsProperties: Record<string, InputField> = {
       product_id: {
         label: 'Product Id',
         type: 'string',
-        description: 'Database id of the product being viewed.'
+        description:
+          'Database id of the product being viewed.'
       },
       sku: {
         label: 'SKU',
         type: 'string',
-        description: 'Sku of the product being viewed.'
+        description:
+          'Sku of the product being viewed.'
       },
       category: {
         label: 'Category',
         type: 'string',
-        description: 'Product category being viewed.'
+        description:
+          'Product category being viewed.'
       },
       name: {
         label: 'Name',
         type: 'string',
-        description: 'Name of the product being viewed.'
+        description:
+          'Name of the product being viewed.'
       },
       brand: {
         label: 'Brand',
         type: 'string',
-        description: 'Brand associated with the product.'
+        description:
+          'Brand associated with the product.'
       },
       variant: {
         label: 'Variant',
         type: 'string',
-        description: 'Variant of the product.'
+        description:
+          'Variant of the product.'
       },
       price: {
         label: 'Price',
         type: 'number',
-        description: 'Price ($) of the product being viewed.'
+        description:
+          'Price ($) of the product being viewed.'
       },
       quantity: {
         label: 'Quantity',
@@ -400,22 +409,26 @@ export const productsProperties: Record<string, InputField> = {
       coupon: {
         label: 'Coupon',
         type: 'string',
-        description: 'Coupon code associated with a product (for example, MAY_DEALS_3).'
+        description:
+          'Coupon code associated with a product (for example, MAY_DEALS_3).'
       },
       position: {
         label: 'position',
         type: 'number',
-        description: 'Position in the product list (ex. 3).'
+        description:
+          'Position in the product list (ex. 3).'
       },
       url: {
         label: 'url',
         type: 'string',
-        description: 'URL of the product page.'
+        description:
+          'URL of the product page.'
       },
       image_url: {
         label: 'Image url',
         type: 'string',
-        description: 'Image url of the product.'
+        description:
+          'Image url of the product.'
       }
     },
     default: {
diff --git a/packages/destination-actions/src/destinations/mixpanel/trackEvent/functions.ts b/packages/destination-actions/src/destinations/mixpanel/trackEvent/functions.ts
index 248d0521..28f6b93e 100644
--- a/packages/destination-actions/src/destinations/mixpanel/trackEvent/functions.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/trackEvent/functions.ts
@@ -1,3 +1,4 @@
+
 import { omit } from '@segment/actions-core'
 import type { Settings } from '../generated-types'
 import type { Payload } from './generated-types'
@@ -8,61 +9,61 @@ import { getBrowser, getBrowserVersion, cheapGuid } from '../utils'
 const mixpanelReservedProperties = ['time', 'id', '$anon_id', 'distinct_id', '$group_id', '$insert_id', '$user_id']
 
 export function getEventProperties(payload: Payload, settings: Settings): MixpanelEventProperties {
-  const datetime = payload.time
-  const time = datetime && dayjs.utc(datetime).isValid() ? dayjs.utc(datetime).valueOf() : Date.now()
-  const utm = payload.utm_properties || {}
-  let browser, browserVersion
-  if (payload.userAgent) {
-    browser = getBrowser(payload.userAgent, payload.device_manufacturer)
-    browserVersion = getBrowserVersion(payload.userAgent, payload.device_manufacturer)
-  }
-  const integration = payload.context?.integration as Record<string, string>
-  return {
-    time: time,
-    ip: payload.ip,
-    id: payload.distinct_id,
-    $anon_id: payload.anonymous_id,
-    distinct_id: payload.distinct_id,
-    $app_build_number: payload.app_build,
-    $app_version_string: payload.app_version,
-    $app_namespace: payload.app_namespace,
-    $app_name: payload.app_name,
-    $browser: browser,
-    $browser_version: browserVersion,
-    $bluetooth_enabled: payload.bluetooth,
-    $cellular_enabled: payload.cellular,
-    $carrier: payload.carrier,
-    $current_url: payload.url,
-    $device: payload.device_name,
-    $device_id: payload.device_id,
-    $device_type: payload.device_type,
-    $device_name: payload.device_name,
-    $group_id: payload.group_id,
-    $identified_id: payload.user_id,
-    $insert_id: payload.insert_id ?? cheapGuid(),
-    $ios_ifa: payload.idfa,
-    $lib_version: payload.library_version,
-    $locale: payload.language,
-    $manufacturer: payload.device_manufacturer,
-    $model: payload.device_model,
-    $os: payload.os_name,
-    $os_version: payload.os_version,
-    $referrer: payload.referrer,
-    $screen_height: payload.screen_height,
-    $screen_width: payload.screen_width,
-    $screen_density: payload.screen_density,
-    $source: integration?.name == 'Iterable' ? 'Iterable' : 'segment',
-    $user_id: payload.user_id,
-    $wifi_enabled: payload.wifi,
-    mp_country_code: payload.country,
-    mp_lib: payload.library_name && `Segment Actions: ${payload.library_name}`,
-    segment_source_name: settings.sourceName,
-    utm_campaign: utm.utm_campaign,
-    utm_content: utm.utm_content,
-    utm_medium: utm.utm_medium,
-    utm_source: utm.utm_source,
-    utm_term: utm.utm_term,
-    // Ignore Mixpanel reserved properties
-    ...omit(payload.event_properties, mixpanelReservedProperties)
-  }
-}
+    const datetime = payload.time
+    const time = datetime && dayjs.utc(datetime).isValid() ? dayjs.utc(datetime).valueOf() : Date.now()
+    const utm = payload.utm_properties || {}
+    let browser, browserVersion
+    if (payload.userAgent) {
+        browser = getBrowser(payload.userAgent, payload.device_manufacturer)
+        browserVersion = getBrowserVersion(payload.userAgent, payload.device_manufacturer)
+    }
+    const integration = payload.context?.integration as Record<string, string>
+    return {
+        time: time,
+        ip: payload.ip,
+        id: payload.distinct_id,
+        $anon_id: payload.anonymous_id,
+        distinct_id: payload.distinct_id,
+        $app_build_number: payload.app_build,
+        $app_version_string: payload.app_version,
+        $app_namespace: payload.app_namespace,
+        $app_name: payload.app_name,
+        $browser: browser,
+        $browser_version: browserVersion,
+        $bluetooth_enabled: payload.bluetooth,
+        $cellular_enabled: payload.cellular,
+        $carrier: payload.carrier,
+        $current_url: payload.url,
+        $device: payload.device_name,
+        $device_id: payload.device_id,
+        $device_type: payload.device_type,
+        $device_name: payload.device_name,
+        $group_id: payload.group_id,
+        $identified_id: payload.user_id,
+        $insert_id: payload.insert_id ?? cheapGuid(),
+        $ios_ifa: payload.idfa,
+        $lib_version: payload.library_version,
+        $locale: payload.language,
+        $manufacturer: payload.device_manufacturer,
+        $model: payload.device_model,
+        $os: payload.os_name,
+        $os_version: payload.os_version,
+        $referrer: payload.referrer,
+        $screen_height: payload.screen_height,
+        $screen_width: payload.screen_width,
+        $screen_density: payload.screen_density,
+        $source: integration?.name == "Iterable" ? "Iterable" : 'segment',
+        $user_id: payload.user_id,
+        $wifi_enabled: payload.wifi,
+        mp_country_code: payload.country,
+        mp_lib: payload.library_name && `Segment Actions: ${ payload.library_name }`,
+        segment_source_name: settings.sourceName,
+        utm_campaign: utm.utm_campaign,
+        utm_content: utm.utm_content,
+        utm_medium: utm.utm_medium,
+        utm_source: utm.utm_source,
+        utm_term: utm.utm_term,
+        // Ignore Mixpanel reserved properties
+        ...omit(payload.event_properties, mixpanelReservedProperties)
+    }
+}
\ No newline at end of file
diff --git a/packages/destination-actions/src/destinations/mixpanel/trackEvent/index.ts b/packages/destination-actions/src/destinations/mixpanel/trackEvent/index.ts
index 6fd6ac81..1445bb1e 100644
--- a/packages/destination-actions/src/destinations/mixpanel/trackEvent/index.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/trackEvent/index.ts
@@ -19,11 +19,11 @@ const getEventFromPayload = (payload: Payload, settings: Settings): MixpanelEven
 const processData = async (request: RequestClient, settings: Settings, payload: Payload[]) => {
   const events = payload.map((value) => getEventFromPayload(value, settings))
 
-  return request(`${getApiServerUrl(settings.apiRegion)}/import?strict=${settings.strictMode ?? `1`}`, {
+  return request(`${ getApiServerUrl(settings.apiRegion) }/import?strict=${ settings.strictMode ?? `1` }`, {
     method: 'post',
     json: events,
     headers: {
-      authorization: `Basic ${Buffer.from(`${settings.apiSecret}:`).toString('base64')}`
+      authorization: `Basic ${ Buffer.from(`${ settings.apiSecret }:`).toString('base64') }`
     }
   })
 }
diff --git a/packages/destination-actions/src/destinations/mixpanel/trackPurchase/__tests__/index.test.ts b/packages/destination-actions/src/destinations/mixpanel/trackPurchase/__tests__/index.test.ts
index fc87ecf4..2b35a694 100644
--- a/packages/destination-actions/src/destinations/mixpanel/trackPurchase/__tests__/index.test.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/trackPurchase/__tests__/index.test.ts
@@ -55,7 +55,7 @@ const orderCompletedEvent: Partial<SegmentEvent> = {
 }
 
 const expectedOrderCompleted = {
-  ...omit(orderCompletedEvent, ['anonymousId', 'messageId', 'timestamp', 'type', 'userId'])
+  ...omit(orderCompletedEvent, ['anonymousId', 'messageId', 'timestamp', 'type', 'userId']),
 }
 
 const mapping = {
@@ -76,6 +76,7 @@ describe('Mixpanel.trackPurchase', () => {
 
     nock('https://api.mixpanel.com').post('/import?strict=1').reply(200, {})
 
+
     const responses = await testDestination.testAction('trackPurchase', {
       event,
       mapping,
@@ -182,7 +183,7 @@ describe('Mixpanel.trackPurchase', () => {
       settings: {
         projectToken: MIXPANEL_PROJECT_TOKEN,
         apiSecret: MIXPANEL_API_SECRET,
-        apiRegion: ApiRegions.US
+        apiRegion: ApiRegions.US,
       }
     })
     expect(responses.length).toBe(1)
diff --git a/packages/destination-actions/src/destinations/mixpanel/trackPurchase/index.ts b/packages/destination-actions/src/destinations/mixpanel/trackPurchase/index.ts
index 2e640429..8d7831c4 100644
--- a/packages/destination-actions/src/destinations/mixpanel/trackPurchase/index.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/trackPurchase/index.ts
@@ -51,11 +51,11 @@ const getPurchaseEventsFromPayload = (payload: Payload, settings: Settings): Mix
 
 const processData = async (request: RequestClient, settings: Settings, payload: Payload[]) => {
   const events = payload.map((value) => getPurchaseEventsFromPayload(value, settings)).flat()
-  return request(`${getApiServerUrl(settings.apiRegion)}/import?strict=${settings.strictMode ?? `1`}`, {
+  return request(`${ getApiServerUrl(settings.apiRegion) }/import?strict=${ settings.strictMode ?? `1` }`, {
     method: 'post',
     json: events,
     headers: {
-      authorization: `Basic ${Buffer.from(`${settings.apiSecret}:`).toString('base64')}`
+      authorization: `Basic ${ Buffer.from(`${ settings.apiSecret }:`).toString('base64') }`
     }
   })
 }
diff --git a/packages/destination-actions/src/destinations/mixpanel/utils.ts b/packages/destination-actions/src/destinations/mixpanel/utils.ts
index 44267003..e21eb8ea 100644
--- a/packages/destination-actions/src/destinations/mixpanel/utils.ts
+++ b/packages/destination-actions/src/destinations/mixpanel/utils.ts
@@ -9,7 +9,9 @@ export enum StrictMode {
 }
 
 export function getConcatenatedName(firstName: unknown, lastName: unknown, name: unknown): unknown {
-  return name ?? (firstName && lastName ? `${firstName} ${lastName}` : undefined)
+  return (
+    name ?? (firstName && lastName ? `${ firstName } ${ lastName }` : undefined)
+  )
 }
 
 export function getApiServerUrl(apiRegion: string | undefined) {
diff --git a/packages/destination-actions/src/destinations/pipedrive/createUpdateOrganization/index.ts b/packages/destination-actions/src/destinations/pipedrive/createUpdateOrganization/index.ts
index 04effd2d..4d4e140a 100644
--- a/packages/destination-actions/src/destinations/pipedrive/createUpdateOrganization/index.ts
+++ b/packages/destination-actions/src/destinations/pipedrive/createUpdateOrganization/index.ts
@@ -65,7 +65,7 @@ const action: ActionDefinition<Settings, Payload> = {
   },
 
   perform: async (request, { payload, settings }) => {
-    const searchField = payload.match_field || settings.personField || 'id'
+    const searchField = payload.match_field || settings.organizationField || 'id'
 
     const client = new PipedriveClient(settings, request)
 
diff --git a/packages/destination-actions/src/destinations/salesforce/__tests__/sf-operations.test.ts b/packages/destination-actions/src/destinations/salesforce/__tests__/sf-operations.test.ts
index 31222c04..3e1d0113 100644
--- a/packages/destination-actions/src/destinations/salesforce/__tests__/sf-operations.test.ts
+++ b/packages/destination-actions/src/destinations/salesforce/__tests__/sf-operations.test.ts
@@ -141,6 +141,48 @@ describe('Salesforce', () => {
       )
     })
 
+    it('should support the AND soql operator', async () => {
+      const query = encodeURIComponent(
+        `SELECT Id FROM Lead WHERE email = 'sponge@seamail.com' AND isDeleted = false AND NumberOfEmployees = 3`
+      )
+      nock(`${settings.instanceUrl}services/data/${API_VERSION}/query`)
+        .get(`/?q=${query}`)
+        .reply(201, {
+          Id: 'abc123',
+          totalSize: 1,
+          records: [{ Id: '123456' }]
+        })
+
+      nock(`${settings.instanceUrl}services/data/${API_VERSION}/sobjects`).patch('/Lead/123456').reply(201, {})
+
+      await sf.updateRecord(
+        {
+          recordMatcherOperator: 'AND',
+          traits: {
+            email: 'sponge@seamail.com',
+            isDeleted: false,
+            NumberOfEmployees: 3
+          }
+        },
+        'Lead'
+      )
+    })
+
+    it('should fail when the soql operator is not OR and not AND', async () => {
+      await expect(
+        sf.updateRecord(
+          {
+            recordMatcherOperator: 'NOR',
+            traits: {
+              email: { key: 'sponge@seamail.com' },
+              NoOfEmployees: [1, 2]
+            }
+          },
+          'Lead'
+        )
+      ).rejects.toThrowError('Invalid SOQL operator - NOR')
+    })
+
     it('should fail when trait value is of an unsupported datatype - object or arrays', async () => {
       await expect(
         sf.updateRecord(
@@ -532,6 +574,50 @@ describe('Salesforce', () => {
       await sf.bulkHandler(bulkUpdatePayloads, 'Account')
     })
 
+    it('should pass NO_VALUE when a bulk record ID is missing', async () => {
+      const missingRecordPayload = {
+        operation: 'update',
+        enable_batching: true,
+        bulkUpdateRecordId: undefined,
+        name: 'Plankton',
+        phone: '123-evil',
+        description: 'Proprietor of the 1 star restaurant, The Chum Bucket'
+      }
+
+      //create bulk job
+      nock(`${settings.instanceUrl}services/data/${API_VERSION}/jobs/ingest`)
+        .post('', {
+          object: 'Account',
+          externalIdFieldName: 'Id',
+          operation: 'update',
+          contentType: 'CSV'
+        })
+        .reply(201, {
+          id: 'abc123'
+        })
+
+      const CSV = `Name,Phone,Description,Id\n"SpongeBob Squarepants","1234567890","Krusty Krab","ab"\n"Squidward Tentacles","1234567891","Krusty Krab","cd"\n"Plankton","123-evil","Proprietor of the 1 star restaurant, The Chum Bucket","#N/A"\n`
+
+      //upload csv
+      nock(`${settings.instanceUrl}services/data/${API_VERSION}/jobs/ingest/abc123/batches`, {
+        reqheaders: {
+          'Content-Type': 'text/csv',
+          Accept: 'application/json'
+        }
+      })
+        .put('', CSV)
+        .reply(201, {})
+
+      //close bulk job
+      nock(`${settings.instanceUrl}services/data/${API_VERSION}/jobs/ingest/abc123`)
+        .patch('', {
+          state: 'UploadComplete'
+        })
+        .reply(201, {})
+
+      await sf.bulkHandler([...bulkUpdatePayloads, missingRecordPayload], 'Account')
+    })
+
     it('should fail if the bulkHandler is triggered but enable_batching is not true', async () => {
       const payloads: GenericPayload[] = [
         {
diff --git a/packages/destination-actions/src/destinations/salesforce/__tests__/sf-utils.test.ts b/packages/destination-actions/src/destinations/salesforce/__tests__/sf-utils.test.ts
index 7edb3a8d..7a350e7e 100644
--- a/packages/destination-actions/src/destinations/salesforce/__tests__/sf-utils.test.ts
+++ b/packages/destination-actions/src/destinations/salesforce/__tests__/sf-utils.test.ts
@@ -164,6 +164,36 @@ describe('Salesforce Utils', () => {
       expect(csv).toEqual(expected)
     })
 
+    it('should handle null data correctly', async () => {
+      const nullPayloads: GenericPayload[] = [
+        {
+          operation: 'upsert',
+          enable_batching: true,
+          bulkUpsertExternalId: {
+            externalIdName: 'test__c',
+            externalIdValue: '00'
+          },
+          name: 'SpongeBob Squarepants',
+          description: undefined
+        },
+        {
+          operation: 'upsert',
+          enable_batching: true,
+          bulkUpsertExternalId: {
+            externalIdName: 'test__c',
+            externalIdValue: '01'
+          },
+          name: 'Squidward Tentacles',
+          description: undefined
+        }
+      ]
+
+      const csv = buildCSVData(nullPayloads, 'test__c')
+      const expected = `Name,Description,test__c\n"SpongeBob Squarepants",#N/A,"00"\n"Squidward Tentacles",#N/A,"01"\n`
+
+      expect(csv).toEqual(expected)
+    })
+
     it('should correctly escape double quotes', async () => {
       const updatePayloads: GenericPayload[] = [
         {
@@ -186,5 +216,34 @@ describe('Salesforce Utils', () => {
       const expected = `Name,Description,Id\n"Sponge """"Bob"""" ""Square"" ""pants""",#N/A,"00"\n"Tentacles, ""Squidward""","Squidward Tentacles is a fictional character in the American animated television series ""SpongeBob SquarePants"".\n He is voiced by actor Rodger Bumpass and first appeared on television in the series' pilot episode on May 1, 1999.","01"\n`
       expect(csv).toEqual(expected)
     })
+
+    it('should handle non-string data correctly', async () => {
+      const updatePayloads: GenericPayload[] = [
+        {
+          operation: 'update',
+          enable_batching: true,
+          bulkUpdateRecordId: '00',
+          name: 'Krusty Krab',
+          number_of_employees: 2,
+          customFields: {
+            sellsKrabbyPatties__c: true
+          }
+        },
+        {
+          operation: 'update',
+          enable_batching: true,
+          bulkUpdateRecordId: '01',
+          name: 'Chum Bucket',
+          number_of_employees: 1,
+          customFields: {
+            sellsKrabbyPatties__c: false
+          }
+        }
+      ]
+
+      const csv = buildCSVData(updatePayloads, 'Id')
+      const expected = `Name,NumberOfEmployees,sellsKrabbyPatties__c,Id\n"Krusty Krab","2","true","00"\n"Chum Bucket","1","false","01"\n`
+      expect(csv).toEqual(expected)
+    })
   })
 })
diff --git a/packages/destination-actions/src/destinations/salesforce/sf-operations.ts b/packages/destination-actions/src/destinations/salesforce/sf-operations.ts
index acf93636..ff09f185 100644
--- a/packages/destination-actions/src/destinations/salesforce/sf-operations.ts
+++ b/packages/destination-actions/src/destinations/salesforce/sf-operations.ts
@@ -14,6 +14,19 @@ const throwBulkMismatchError = () => {
   throw new IntegrationError(errorMsg, errorMsg, 400)
 }
 
+const validateSOQLOperator = (operator: string | undefined): SOQLOperator => {
+  if (operator !== undefined && operator !== 'OR' && operator !== 'AND') {
+    throw new IntegrationError(`Invalid SOQL operator - ${operator}`, 'Invalid SOQL operator', 400)
+  }
+
+  // 'OR' is the default operator. Therefore, when we encounter 'undefined' we will return 'OR'.
+  if (operator === undefined) {
+    return 'OR'
+  }
+
+  return operator
+}
+
 interface Records {
   Id?: string
 }
@@ -50,6 +63,8 @@ interface SalesforceError {
   }
 }
 
+type SOQLOperator = 'OR' | 'AND'
+
 export default class Salesforce {
   instanceUrl: string
   request: RequestClient
@@ -79,7 +94,9 @@ export default class Salesforce {
       return await this.baseUpdate(payload.traits['Id'] as string, sobject, payload)
     }
 
-    const [recordId, err] = await this.lookupTraits(payload.traits, sobject, payload.recordMatcherOperator ?? 'OR')
+    const soqlOperator: SOQLOperator = validateSOQLOperator(payload.recordMatcherOperator)
+    const [recordId, err] = await this.lookupTraits(payload.traits, sobject, soqlOperator)
+
     if (err) {
       throw err
     }
@@ -92,7 +109,8 @@ export default class Salesforce {
       throw new IntegrationError('Undefined Traits when using upsert operation', 'Undefined Traits', 400)
     }
 
-    const [recordId, err] = await this.lookupTraits(payload.traits, sobject, payload.recordMatcherOperator ?? 'OR')
+    const soqlOperator: SOQLOperator = validateSOQLOperator(payload.recordMatcherOperator)
+    const [recordId, err] = await this.lookupTraits(payload.traits, sobject, soqlOperator)
 
     if (err) {
       if (err.status === 404) {
@@ -282,7 +300,7 @@ export default class Salesforce {
     }
   }
 
-  private buildQuery = (traits: object, sobject: string, operator: string) => {
+  private buildQuery = (traits: object, sobject: string, soqlOperator: SOQLOperator) => {
     let soql = `SELECT Id FROM ${sobject} WHERE `
 
     const entries = Object.entries(traits)
@@ -291,21 +309,22 @@ export default class Salesforce {
       let token = `${this.removeInvalidChars(key)} = ${this.typecast(value)}`
 
       if (i < entries.length - 1) {
-        token += ' ' + operator + ' ' // We need to change here...
+        token += ' ' + soqlOperator + ' '
       }
 
       soql += token
       i += 1
     }
+
     return soql
   }
 
   private lookupTraits = async (
     traits: object,
     sobject: string,
-    operator: string
+    soqlOperator: SOQLOperator
   ): Promise<[string, IntegrationError | undefined]> => {
-    const SOQLQuery = encodeURIComponent(this.buildQuery(traits, sobject, operator))
+    const SOQLQuery = encodeURIComponent(this.buildQuery(traits, sobject, soqlOperator))
 
     const res = await this.request<LookupResponseData>(
       `${this.instanceUrl}services/data/${API_VERSION}/query/?q=${SOQLQuery}`,
diff --git a/packages/destination-actions/src/destinations/salesforce/sf-properties.ts b/packages/destination-actions/src/destinations/salesforce/sf-properties.ts
index 6aea7075..20fedd1f 100644
--- a/packages/destination-actions/src/destinations/salesforce/sf-properties.ts
+++ b/packages/destination-actions/src/destinations/salesforce/sf-properties.ts
@@ -48,16 +48,18 @@ export const bulkUpdateRecordId: InputField = {
   type: 'string'
 }
 
+// Any actions configured before this field was added will have an undefined value for this field.
+// We default to the 'OR' when consuming this field if it is undefined.
 export const recordMatcherOperator: InputField = {
   label: 'Record Matchers Operator',
   description:
     'This field affects how Segment uses the record matchers to query Salesforce records. By default, Segment uses the "OR" operator to query Salesforce for a record. If you would like to query Salesforce records using a combination of multiple record matchers, change this to "AND".',
   type: 'string',
-  required: false,
   choices: [
     { label: 'OR', value: 'OR' },
     { label: 'AND', value: 'AND' }
-  ]
+  ],
+  default: 'OR'
 }
 
 export const traits: InputField = {
@@ -92,7 +94,6 @@ export const customFields: InputField = {
 interface Payload {
   operation?: string
   traits?: object
-  operator?: string
 }
 
 export const validateLookup = (payload: Payload) => {
diff --git a/packages/destination-actions/src/destinations/salesforce/sf-utils.ts b/packages/destination-actions/src/destinations/salesforce/sf-utils.ts
index 82664ff7..adac5d5f 100644
--- a/packages/destination-actions/src/destinations/salesforce/sf-utils.ts
+++ b/packages/destination-actions/src/destinations/salesforce/sf-utils.ts
@@ -2,6 +2,8 @@ import { IntegrationError } from '@segment/actions-core'
 import { GenericPayload } from './sf-types'
 import camelCase from 'lodash/camelCase'
 
+type CSVData = string | number | boolean
+
 const isSettingsKey = new Set<string>([
   'operation',
   'traits',
@@ -25,7 +27,9 @@ const validateHeaderField = (field: string): void => {
 
 // Salesforce bulk API CSVs require double quotes to be escaped with another double quote.
 // https://developer.salesforce.com/docs/atlas.en-us.api_asynch.meta/api_asynch/datafiles_csv_valid_record_rows.htm
-const escapeDoubleQuotes = (value: string): string => {
+const escapeDoubleQuotes = (value: CSVData): CSVData => {
+  if (typeof value !== 'string') return value
+
   return value.replace(/"/g, '""')
 }
 
@@ -37,8 +41,8 @@ const escapeDoubleQuotes = (value: string): string => {
  * map of each column in the CSV file. The index is the index of the payload in the batch and is used
  * to maintain ordering when the CSV is generated.
  */
-const buildHeaderMap = (payloads: GenericPayload[]): Map<string, [[string, number]]> => {
-  const headerMap = new Map<string, [[string, number]]>()
+const buildHeaderMap = (payloads: GenericPayload[]): Map<string, [[CSVData, number]]> => {
+  const headerMap = new Map<string, [[CSVData, number]]>()
 
   //iterate in reverse over payloads to use each headerMap array as a queue.
   for (let i = payloads.length - 1; i >= 0; i--) {
@@ -46,7 +50,7 @@ const buildHeaderMap = (payloads: GenericPayload[]): Map<string, [[string, numbe
     Object.entries(payload).forEach(([key, value]) => {
       if (!isSettingsKey.has(key)) {
         const pascalKey = snakeCaseToPascalCase(key)
-        const actualValue = value as string
+        const actualValue = value as CSVData
         if (headerMap.has(pascalKey)) {
           headerMap.get(pascalKey)?.push([actualValue, i])
         } else {
@@ -77,7 +81,7 @@ const buildHeaderMap = (payloads: GenericPayload[]): Map<string, [[string, numbe
  * @param headerMap A map representing each column in the CSV file.
  * @returns The first row of the CSV file, which contains the header names.
  */
-const buildHeaders = (headerMap: Map<string, [[string, number]]>): string => {
+const buildHeaders = (headerMap: Map<string, [[CSVData, number]]>): string => {
   let headers = ''
   for (const [key, _] of headerMap.entries()) {
     headers += `${key},`
@@ -98,7 +102,7 @@ const buildHeaders = (headerMap: Map<string, [[string, number]]>): string => {
  */
 const buildCSVFromHeaderMap = (
   payloads: GenericPayload[],
-  headerMap: Map<string, [[string, number]]>,
+  headerMap: Map<string, [[CSVData, number]]>,
   n: number
 ): string => {
   let rows = ''
@@ -108,7 +112,7 @@ const buildCSVFromHeaderMap = (
     for (const [key, _] of headerMap.entries()) {
       let noValueFound = true
       if (headerMap.has(key)) {
-        const column = headerMap.get(key) as [[string, number]]
+        const column = headerMap.get(key) as [[CSVData, number]]
 
         if (column !== undefined && column.length > 0 && column[column.length - 1][1] === i) {
           const valueTuple = column.pop()
@@ -144,11 +148,7 @@ const getUniqueIdValue = (payload: GenericPayload): string => {
     return payload.bulkUpdateRecordId
   }
 
-  throw new IntegrationError(
-    `bulk ${payload.operation} is missing the required bulk ID`,
-    `bulk ${payload.operation} is missing the required bulk ID`,
-    400
-  )
+  return NO_VALUE
 }
 
 /**
diff --git a/packages/destination-actions/src/destinations/segment-profiles/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/segment-profiles/__tests__/__snapshots__/snapshot.test.ts.snap
new file mode 100644
index 00000000..0b384997
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -0,0 +1,41 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Testing snapshot for actions-segment-profiles destination: sendGroup action - all fields 1`] = `
+Object {
+  "anonymousId": "cZE8HyAL0!BF#)WQb^",
+  "groupId": "cZE8HyAL0!BF#)WQb^",
+  "traits": Object {
+    "testType": "cZE8HyAL0!BF#)WQb^",
+  },
+  "userId": "cZE8HyAL0!BF#)WQb^",
+}
+`;
+
+exports[`Testing snapshot for actions-segment-profiles destination: sendGroup action - required fields 1`] = `
+Object {
+  "anonymousId": "cZE8HyAL0!BF#)WQb^",
+  "groupId": "cZE8HyAL0!BF#)WQb^",
+  "traits": Object {},
+  "userId": "cZE8HyAL0!BF#)WQb^",
+}
+`;
+
+exports[`Testing snapshot for actions-segment-profiles destination: sendIdentify action - all fields 1`] = `
+Object {
+  "anonymousId": "hIC1OAmWa[Q!&d%o",
+  "groupId": "hIC1OAmWa[Q!&d%o",
+  "traits": Object {
+    "testType": "hIC1OAmWa[Q!&d%o",
+  },
+  "userId": "hIC1OAmWa[Q!&d%o",
+}
+`;
+
+exports[`Testing snapshot for actions-segment-profiles destination: sendIdentify action - required fields 1`] = `
+Object {
+  "anonymousId": "hIC1OAmWa[Q!&d%o",
+  "groupId": "hIC1OAmWa[Q!&d%o",
+  "traits": Object {},
+  "userId": "hIC1OAmWa[Q!&d%o",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/segment-profiles/__tests__/index.test.ts b/packages/destination-actions/src/destinations/segment-profiles/__tests__/index.test.ts
new file mode 100644
index 00000000..ebf9bb3b
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/__tests__/index.test.ts
@@ -0,0 +1,32 @@
+import nock from 'nock'
+import { createTestIntegration } from '@segment/actions-core'
+import Definition from '../index'
+import { Settings } from '../generated-types'
+import { SEGMENT_ENDPOINTS, DEFAULT_SEGMENT_ENDPOINT } from '../properties'
+
+const testDestination = createTestIntegration(Definition)
+
+describe('Segment Profiles', () => {
+  describe('testAuthentication', () => {
+    it('should validate authentication inputs', async () => {
+      const segmentPAPIToken = 'segment-papi-token'
+
+      nock(SEGMENT_ENDPOINTS[DEFAULT_SEGMENT_ENDPOINT].papi, {
+        reqheaders: {
+          // Check if the request has the correct authorization header
+          authorization: (value) => value === `Bearer ${segmentPAPIToken}`
+        }
+      })
+        .get(/.*/)
+        .reply(200, {})
+
+      // This should match your authentication.fields
+      const authData: Settings = {
+        segment_papi_token: segmentPAPIToken,
+        endpoint: DEFAULT_SEGMENT_ENDPOINT
+      }
+
+      await expect(testDestination.testAuthentication(authData)).resolves.not.toThrowError()
+    })
+  })
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/__tests__/snapshot.test.ts b/packages/destination-actions/src/destinations/segment-profiles/__tests__/snapshot.test.ts
new file mode 100644
index 00000000..379f010f
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/__tests__/snapshot.test.ts
@@ -0,0 +1,78 @@
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { generateTestData } from '../../../lib/test-data'
+import destination from '../index'
+import { DEFAULT_SEGMENT_ENDPOINT } from '../properties'
+import nock from 'nock'
+
+const testDestination = createTestIntegration(destination)
+const destinationSlug = 'actions-segment-profiles'
+
+describe(`Testing snapshot for ${destinationSlug} destination:`, () => {
+  for (const actionSlug in destination.actions) {
+    it(`${actionSlug} action - required fields`, async () => {
+      const seedName = `${destinationSlug}#${actionSlug}`
+      const action = destination.actions[actionSlug]
+      const [eventData, settingsData] = generateTestData(seedName, destination, action, true)
+
+      nock(/.*/).persist().get(/.*/).reply(200)
+      nock(/.*/).persist().post(/.*/).reply(200)
+      nock(/.*/).persist().put(/.*/).reply(200)
+
+      const event = createTestEvent({
+        properties: eventData
+      })
+
+      const responses = await testDestination.testAction(actionSlug, {
+        event: event,
+        mapping: event.properties,
+        settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+        auth: undefined
+      })
+
+      const request = responses[0].request
+      const rawBody = await request.text()
+
+      try {
+        const json = JSON.parse(rawBody)
+        expect(json).toMatchSnapshot()
+        return
+      } catch (err) {
+        expect(rawBody).toMatchSnapshot()
+      }
+
+      expect(request.headers).toMatchSnapshot()
+    })
+
+    it(`${actionSlug} action - all fields`, async () => {
+      const seedName = `${destinationSlug}#${actionSlug}`
+      const action = destination.actions[actionSlug]
+      const [eventData, settingsData] = generateTestData(seedName, destination, action, false)
+
+      nock(/.*/).persist().get(/.*/).reply(200)
+      nock(/.*/).persist().post(/.*/).reply(200)
+      nock(/.*/).persist().put(/.*/).reply(200)
+
+      const event = createTestEvent({
+        properties: eventData
+      })
+
+      const responses = await testDestination.testAction(actionSlug, {
+        event: event,
+        mapping: event.properties,
+        settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+        auth: undefined
+      })
+
+      const request = responses[0].request
+      const rawBody = await request.text()
+
+      try {
+        const json = JSON.parse(rawBody)
+        expect(json).toMatchSnapshot()
+        return
+      } catch (err) {
+        expect(rawBody).toMatchSnapshot()
+      }
+    })
+  }
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/errors.ts b/packages/destination-actions/src/destinations/segment-profiles/errors.ts
new file mode 100644
index 00000000..58dd7a39
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/errors.ts
@@ -0,0 +1,25 @@
+import { HTTPError, IntegrationError } from '@segment/actions-core'
+
+export class SegmentPublicAPIError extends HTTPError {
+  response: Response & {
+    errors: {
+      type: string
+      message?: string
+      field?: string
+      data?: string
+      status?: number
+    }
+  }
+}
+
+export const MissingUserOrAnonymousIdThrowableError = new IntegrationError(
+  'Either `Anonymous ID` or `User ID` must be defined.',
+  'Missing Required Field',
+  400
+)
+
+export const InvalidEndpointSelectedThrowableError = new IntegrationError(
+  'A valid endpoint must be selected. Please check your Segment settings.',
+  'Misconfigured Endpoint',
+  400
+)
diff --git a/packages/destination-actions/src/destinations/segment-profiles/generated-types.ts b/packages/destination-actions/src/destinations/segment-profiles/generated-types.ts
new file mode 100644
index 00000000..434b3ab6
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/generated-types.ts
@@ -0,0 +1,12 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Settings {
+  /**
+   * The Segment Public API requires that you have an authentication token before you send requests. [This document](https://docs.segmentapis.com/tag/Getting-Started#section/Get-an-API-token) explains how to setup a token.
+   */
+  segment_papi_token: string
+  /**
+   * The region to send your data.
+   */
+  endpoint: string
+}
diff --git a/packages/destination-actions/src/destinations/segment-profiles/helperFunctions.ts b/packages/destination-actions/src/destinations/segment-profiles/helperFunctions.ts
new file mode 100644
index 00000000..21c934d4
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/helperFunctions.ts
@@ -0,0 +1,99 @@
+import { ModifiedResponse, RequestClient, DynamicFieldResponse, DynamicFieldItem } from '@segment/actions-core'
+import { PAGINATION_COUNT, SEGMENT_ENDPOINTS, DEFAULT_SEGMENT_ENDPOINT } from './properties'
+import { SegmentPublicAPIError } from './errors'
+
+interface SourceListItemMetadata {
+  id: string
+  slug: string
+  name: string
+  description: string
+}
+
+interface SourceListItem {
+  id: string
+  slug: string
+  name: string
+  workspaceId: string
+  enabled: boolean
+  writeKeys: string[]
+  metadata: SourceListItemMetadata
+}
+
+interface SourcesListPagination {
+  current: number
+  previous?: string
+  next?: string
+  totalEntries: number
+}
+
+interface SourcesResponse {
+  data: {
+    sources: SourceListItem[]
+    pagination: SourcesListPagination
+  }
+}
+
+interface GetEngageSpaceParams {
+  endpoint: string
+  bearerToken: string
+}
+
+export async function getEngageSpaces(
+  request: RequestClient,
+  data: GetEngageSpaceParams
+): Promise<DynamicFieldResponse> {
+  let cursor = 'MA=='
+  const choices: DynamicFieldItem[] = []
+  let response: ModifiedResponse<SourcesResponse>
+
+  const segmentPAPIEndpoint = SEGMENT_ENDPOINTS[data.endpoint || DEFAULT_SEGMENT_ENDPOINT].papi
+
+  do {
+    // https://api.segmentapis.build/sources?pagination%5Bcount%5D=<COUNT>&pagination%5Bcursor%5D=<PAGE>
+    const publicApiUrl = `${segmentPAPIEndpoint}/sources?pagination%5Bcount%5D=${PAGINATION_COUNT}&pagination%5Bcursor%5D=${cursor}`
+
+    try {
+      response = await request<SourcesResponse>(publicApiUrl, {
+        headers: {
+          authorization: `Bearer ${data.bearerToken}`
+        },
+        method: 'GET',
+        skipResponseCloning: true
+      })
+
+      for (const source of response.data.data.sources) {
+        if (source.metadata.slug !== 'personas-compute') {
+          continue
+        }
+
+        choices.push({
+          label: source.name,
+          value: source.writeKeys[0]
+        })
+      }
+    } catch (err) {
+      return {
+        choices: [],
+        error: {
+          message: (err as SegmentPublicAPIError)?.response?.errors?.message ?? 'Unknown Error',
+          code: (err as SegmentPublicAPIError)?.response?.statusText ?? 'Unknown Error'
+        }
+      }
+    }
+
+    if (response.data.data.pagination.next) {
+      cursor = response.data.data.pagination.next
+    }
+  } while (response.data.data.pagination.next)
+
+  return {
+    choices
+  }
+}
+
+export function generateSegmentAPIAuthHeaders(writeKey: string): string {
+  // Segment's Tracking API uses HTTP Basic Authentication with the
+  // Source Write Key. A colon needs to be added to the end of the
+  // write key and then base64 encoded. Eg: BASE64(WriteKey + ':')
+  return `Basic ${Buffer.from(writeKey + ':').toString('base64')}`
+}
diff --git a/packages/destination-actions/src/destinations/segment-profiles/index.ts b/packages/destination-actions/src/destinations/segment-profiles/index.ts
new file mode 100644
index 00000000..c6dceaf6
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/index.ts
@@ -0,0 +1,51 @@
+import type { DestinationDefinition } from '@segment/actions-core'
+import type { Settings } from './generated-types'
+import { DEFAULT_SEGMENT_ENDPOINT, SEGMENT_ENDPOINTS } from './properties'
+
+import sendGroup from './sendGroup'
+
+import sendIdentify from './sendIdentify'
+
+const destination: DestinationDefinition<Settings> = {
+  name: 'Segment Profiles',
+  slug: 'actions-segment-profiles',
+  mode: 'cloud',
+  authentication: {
+    scheme: 'custom',
+    fields: {
+      segment_papi_token: {
+        label: 'Segment Public API Token',
+        description:
+          'The Segment Public API requires that you have an authentication token before you send requests. [This document](https://docs.segmentapis.com/tag/Getting-Started#section/Get-an-API-token) explains how to setup a token.',
+        type: 'string',
+        required: true
+      },
+      endpoint: {
+        label: 'Endpoint Region',
+        description: 'The region to send your data.',
+        type: 'string',
+        format: 'text',
+        choices: Object.keys(SEGMENT_ENDPOINTS).map((key) => ({
+          label: SEGMENT_ENDPOINTS[key].label,
+          value: key
+        })),
+        default: DEFAULT_SEGMENT_ENDPOINT,
+        required: true
+      }
+    },
+    testAuthentication: async (request, { settings }) => {
+      const { endpoint } = settings
+      return request(SEGMENT_ENDPOINTS[endpoint || DEFAULT_SEGMENT_ENDPOINT].papi, {
+        headers: {
+          authorization: `Bearer ${settings.segment_papi_token}`
+        }
+      })
+    }
+  },
+  actions: {
+    sendGroup,
+    sendIdentify
+  }
+}
+
+export default destination
diff --git a/packages/destination-actions/src/destinations/segment-profiles/properties.ts b/packages/destination-actions/src/destinations/segment-profiles/properties.ts
new file mode 100644
index 00000000..2e8b423e
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/properties.ts
@@ -0,0 +1,31 @@
+interface SegmentEndpoint {
+  label: string
+  url: string
+  cdn: string
+  papi: string
+}
+
+export const SEGMENT_ENDPOINTS: { [key: string]: SegmentEndpoint } = {
+  north_america: {
+    label: 'North America',
+    url: 'https://api.segment.io/v1',
+    cdn: 'https://cdn.segment.com/v1',
+    papi: 'https://api.segmentapis.com'
+  },
+  europe: {
+    label: 'Europe',
+    url: 'https://events.eu1.segmentapis.com/v1',
+    cdn: 'https://cdn.segment.com/v1',
+    papi: 'https://eu1.api.segmentapis.com'
+  },
+  stage: {
+    label: 'Staging',
+    url: 'https://api.segment.build/v1',
+    cdn: 'https://cdn.segment.build/v1',
+    papi: 'https://api.segmentapis.build'
+  }
+}
+
+export const DEFAULT_SEGMENT_ENDPOINT = 'north_america'
+
+export const PAGINATION_COUNT = 10
diff --git a/packages/destination-actions/src/destinations/segment-profiles/segment-properties.ts b/packages/destination-actions/src/destinations/segment-profiles/segment-properties.ts
new file mode 100644
index 00000000..2cb74ef2
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/segment-properties.ts
@@ -0,0 +1,36 @@
+import { InputField } from '@segment/actions-core/src/destination-kit/types'
+
+export const user_id: InputField = {
+  label: 'User ID',
+  description: 'Unique identifier for the user in your database. A userId or an anonymousId is required.',
+  type: 'string'
+}
+
+export const anonymous_id: InputField = {
+  label: 'Anonymous ID',
+  description:
+    'A pseudo-unique substitute for a User ID, for cases when you don’t have an absolutely unique identifier. A userId or an anonymousId is required.',
+  type: 'string'
+}
+
+export const group_id: InputField = {
+  label: 'Group ID',
+  description: 'The group or account ID a user is associated with.',
+  type: 'string'
+}
+
+export const traits: InputField = {
+  label: 'Traits',
+  description: 'Free-form dictionary of traits that describe the user or group of users.',
+  type: 'object',
+  defaultObjectUI: 'keyvalue',
+  additionalProperties: true
+}
+
+export const engage_space: InputField = {
+  label: 'Engage Space',
+  description: 'The engage space to use for creating a record.',
+  type: 'string',
+  required: true,
+  dynamic: true
+}
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/index.test.ts.snap b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/index.test.ts.snap
new file mode 100644
index 00000000..b472420c
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/index.test.ts.snap
@@ -0,0 +1,26 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`SegmentProfiles.sendGroup Should send an group event to Segment 1`] = `
+Headers {
+  Symbol(map): Object {
+    "authorization": Array [
+      "Basic ZW5nYWdlLXNwYWNlLXdyaXRla2V5Og==",
+    ],
+    "user-agent": Array [
+      "Segment (Actions)",
+    ],
+  },
+}
+`;
+
+exports[`SegmentProfiles.sendGroup Should send an group event to Segment 2`] = `
+Object {
+  "anonymousId": "arky4h2sh7k",
+  "groupId": "test-group-ks2i7e",
+  "traits": Object {
+    "industry": "Technology",
+    "name": "Example Corp",
+  },
+  "userId": "test-user-ufi5bgkko5",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/snapshot.test.ts.snap
new file mode 100644
index 00000000..e518bad7
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -0,0 +1,21 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Testing snapshot for SegmentProfiles's sendGroup destination action: all fields 1`] = `
+Object {
+  "anonymousId": "tKaa(2A",
+  "groupId": "tKaa(2A",
+  "traits": Object {
+    "testType": "tKaa(2A",
+  },
+  "userId": "tKaa(2A",
+}
+`;
+
+exports[`Testing snapshot for SegmentProfiles's sendGroup destination action: required fields 1`] = `
+Object {
+  "anonymousId": "tKaa(2A",
+  "groupId": "tKaa(2A",
+  "traits": Object {},
+  "userId": "tKaa(2A",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/index.test.ts b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/index.test.ts
new file mode 100644
index 00000000..2a7d97fd
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/index.test.ts
@@ -0,0 +1,102 @@
+import nock from 'nock'
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import Destination from '../../index'
+import { MissingUserOrAnonymousIdThrowableError, InvalidEndpointSelectedThrowableError } from '../../errors'
+import { SEGMENT_ENDPOINTS, DEFAULT_SEGMENT_ENDPOINT } from '../../properties'
+
+const testDestination = createTestIntegration(Destination)
+
+beforeEach(() => nock.cleanAll())
+
+// Default Group Mapping
+const defaultGroupMapping = {
+  user_id: {
+    '@path': '$.userId'
+  },
+  anonymous_id: {
+    '@path': '$.anonymousId'
+  },
+  group_id: {
+    '@path': '$.groupId'
+  },
+  traits: {
+    '@path': '$.traits'
+  },
+  engage_space: 'engage-space-writekey'
+}
+
+describe('SegmentProfiles.sendGroup', () => {
+  test('Should throw an error if `userId or` `anonymousId` is not defined', async () => {
+    const event = createTestEvent({
+      traits: {
+        name: 'Example Corp',
+        industry: 'Technology'
+      },
+      groupId: 'test-group-ks2i7e'
+    })
+
+    await expect(
+      testDestination.testAction('sendGroup', {
+        event,
+        mapping: {
+          group_id: {
+            '@path': '$.groupId'
+          },
+          engage_space: 'engage-space-writekey'
+        }
+      })
+    ).rejects.toThrowError(MissingUserOrAnonymousIdThrowableError)
+  })
+  test('Should throw an error if Segment Endpoint is incorrectly defined', async () => {
+    const event = createTestEvent({
+      traits: {
+        name: 'Example Corp',
+        industry: 'Technology'
+      },
+      userId: 'test-user-ufi5bgkko5',
+      anonymousId: 'arky4h2sh7k',
+      groupId: 'test-group-ks2i7e'
+    })
+
+    await expect(
+      testDestination.testAction('sendGroup', {
+        event,
+        mapping: defaultGroupMapping,
+        settings: {
+          segment_papi_token: 'segment-papi-token',
+          endpoint: 'incorrect-endpoint'
+        }
+      })
+    ).rejects.toThrowError(InvalidEndpointSelectedThrowableError)
+  })
+
+  test('Should send an group event to Segment', async () => {
+    // Mock: Segment Group Call
+    const segmentEndpoint = SEGMENT_ENDPOINTS[DEFAULT_SEGMENT_ENDPOINT].url
+    nock(segmentEndpoint).post('/group').reply(200, { success: true })
+
+    const event = createTestEvent({
+      traits: {
+        name: 'Example Corp',
+        industry: 'Technology'
+      },
+      userId: 'test-user-ufi5bgkko5',
+      anonymousId: 'arky4h2sh7k',
+      groupId: 'test-group-ks2i7e'
+    })
+
+    const responses = await testDestination.testAction('sendGroup', {
+      event,
+      mapping: defaultGroupMapping,
+      settings: {
+        segment_papi_token: 'segment-papi-token',
+        endpoint: DEFAULT_SEGMENT_ENDPOINT
+      }
+    })
+
+    expect(responses.length).toBe(1)
+    expect(responses[0].status).toEqual(200)
+    expect(responses[0].options.headers).toMatchSnapshot()
+    expect(responses[0].options.json).toMatchSnapshot()
+  })
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/snapshot.test.ts b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/snapshot.test.ts
new file mode 100644
index 00000000..95f1fcc6
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/__tests__/snapshot.test.ts
@@ -0,0 +1,76 @@
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { generateTestData } from '../../../../lib/test-data'
+import destination from '../../index'
+import { DEFAULT_SEGMENT_ENDPOINT } from '../../properties'
+import nock from 'nock'
+
+const testDestination = createTestIntegration(destination)
+const actionSlug = 'sendGroup'
+const destinationSlug = 'SegmentProfiles'
+const seedName = `${destinationSlug}#${actionSlug}`
+
+describe(`Testing snapshot for ${destinationSlug}'s ${actionSlug} destination action:`, () => {
+  it('required fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, true)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+      auth: undefined
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+
+    expect(request.headers).toMatchSnapshot()
+  })
+
+  it('all fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, false)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+      auth: undefined
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+  })
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/generated-types.ts b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/generated-types.ts
new file mode 100644
index 00000000..3a26bf22
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/generated-types.ts
@@ -0,0 +1,26 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Payload {
+  /**
+   * The engage space to use for creating a record.
+   */
+  engage_space: string
+  /**
+   * Unique identifier for the user in your database. A userId or an anonymousId is required.
+   */
+  user_id?: string
+  /**
+   * A pseudo-unique substitute for a User ID, for cases when you don’t have an absolutely unique identifier. A userId or an anonymousId is required.
+   */
+  anonymous_id?: string
+  /**
+   * The group or account ID a user is associated with.
+   */
+  group_id: string
+  /**
+   * Free-form dictionary of traits that describe the user or group of users.
+   */
+  traits?: {
+    [k: string]: unknown
+  }
+}
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendGroup/index.ts b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/index.ts
new file mode 100644
index 00000000..8160b0ed
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendGroup/index.ts
@@ -0,0 +1,57 @@
+import type { ActionDefinition } from '@segment/actions-core'
+import type { Settings } from '../generated-types'
+import type { Payload } from './generated-types'
+import { user_id, anonymous_id, group_id, traits, engage_space } from '../segment-properties'
+import { getEngageSpaces, generateSegmentAPIAuthHeaders } from '../helperFunctions'
+import { SEGMENT_ENDPOINTS } from '../properties'
+import { MissingUserOrAnonymousIdThrowableError, InvalidEndpointSelectedThrowableError } from '../errors'
+
+const action: ActionDefinition<Settings, Payload> = {
+  title: 'Send Group',
+  description: 'Send a group call to Segment’s tracking API. This is used to associate an individual user with a group',
+  defaultSubscription: 'type = "group"',
+  fields: {
+    engage_space,
+    user_id,
+    anonymous_id,
+    group_id: { ...group_id, required: true },
+    traits
+  },
+  dynamicFields: {
+    engage_space: async (request, { settings }) => {
+      return getEngageSpaces(request, {
+        endpoint: settings.endpoint,
+        bearerToken: settings.segment_papi_token
+      })
+    }
+  },
+  perform: (request, { payload, settings }) => {
+    if (!payload.anonymous_id && !payload.user_id) {
+      throw MissingUserOrAnonymousIdThrowableError
+    }
+    const groupPayload: Object = {
+      userId: payload?.user_id,
+      anonymousId: payload?.anonymous_id,
+      groupId: payload?.group_id,
+      traits: {
+        ...payload?.traits
+      }
+    }
+
+    // Throw an error if endpoint is not defined or invalid
+    if (!settings.endpoint || !(settings.endpoint in SEGMENT_ENDPOINTS)) {
+      throw InvalidEndpointSelectedThrowableError
+    }
+
+    const selectedSegmentEndpoint = SEGMENT_ENDPOINTS[settings.endpoint].url
+    return request(`${selectedSegmentEndpoint}/group`, {
+      method: 'POST',
+      json: groupPayload,
+      headers: {
+        authorization: generateSegmentAPIAuthHeaders(payload.engage_space)
+      }
+    })
+  }
+}
+
+export default action
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/index.test.ts.snap b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/index.test.ts.snap
new file mode 100644
index 00000000..44110df3
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/index.test.ts.snap
@@ -0,0 +1,26 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Segment.sendIdentify Should send an identify event to Segment 1`] = `
+Headers {
+  Symbol(map): Object {
+    "authorization": Array [
+      "Basic ZW5nYWdlLXNwYWNlLXdyaXRla2V5Og==",
+    ],
+    "user-agent": Array [
+      "Segment (Actions)",
+    ],
+  },
+}
+`;
+
+exports[`Segment.sendIdentify Should send an identify event to Segment 2`] = `
+Object {
+  "anonymousId": "arky4h2sh7k",
+  "groupId": undefined,
+  "traits": Object {
+    "email": "test-user@test-company.com",
+    "name": "Test User",
+  },
+  "userId": "test-user-ufi5bgkko5",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/snapshot.test.ts.snap b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/snapshot.test.ts.snap
new file mode 100644
index 00000000..1cdda7d3
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/__snapshots__/snapshot.test.ts.snap
@@ -0,0 +1,21 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Testing snapshot for SegmentProfiles's sendIdentify destination action: all fields 1`] = `
+Object {
+  "anonymousId": "mV[ZQcEVgZO$MX",
+  "groupId": "mV[ZQcEVgZO$MX",
+  "traits": Object {
+    "testType": "mV[ZQcEVgZO$MX",
+  },
+  "userId": "mV[ZQcEVgZO$MX",
+}
+`;
+
+exports[`Testing snapshot for SegmentProfiles's sendIdentify destination action: required fields 1`] = `
+Object {
+  "anonymousId": "mV[ZQcEVgZO$MX",
+  "groupId": "mV[ZQcEVgZO$MX",
+  "traits": Object {},
+  "userId": "mV[ZQcEVgZO$MX",
+}
+`;
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/index.test.ts b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/index.test.ts
new file mode 100644
index 00000000..59b0949f
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/index.test.ts
@@ -0,0 +1,97 @@
+import nock from 'nock'
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import Destination from '../../index'
+import { SEGMENT_ENDPOINTS, DEFAULT_SEGMENT_ENDPOINT } from '../../properties'
+import { MissingUserOrAnonymousIdThrowableError, InvalidEndpointSelectedThrowableError } from '../../errors'
+
+const testDestination = createTestIntegration(Destination)
+
+beforeEach(() => nock.cleanAll())
+
+// Default Identify Mapping
+const defaultIdentifyMapping = {
+  user_id: {
+    '@path': '$.userId'
+  },
+  anonymous_id: {
+    '@path': '$.anonymousId'
+  },
+  traits: {
+    '@path': '$.traits'
+  },
+  engage_space: 'engage-space-writekey'
+}
+
+describe('Segment.sendIdentify', () => {
+  test('Should throw an error if `userId or` `anonymousId` is not defined', async () => {
+    const event = createTestEvent({
+      type: 'identify',
+      traits: {
+        name: 'Test User',
+        email: 'test-user@test-company.com'
+      }
+    })
+
+    await expect(
+      testDestination.testAction('sendIdentify', {
+        event,
+        mapping: {
+          engage_space: 'engage-space-writekey'
+        }
+      })
+    ).rejects.toThrowError(MissingUserOrAnonymousIdThrowableError)
+  })
+
+  test('Should throw an error if Segment Endpoint is incorrectly defined', async () => {
+    const event = createTestEvent({
+      type: 'identify',
+      traits: {
+        name: 'Test User',
+        email: 'test-user@test-company.com'
+      },
+      userId: 'test-user-ufi5bgkko5',
+      anonymousId: 'arky4h2sh7k'
+    })
+
+    await expect(
+      testDestination.testAction('sendIdentify', {
+        event,
+        mapping: defaultIdentifyMapping,
+        settings: {
+          segment_papi_token: 'segment-papi-token',
+          endpoint: 'incorrect-endpoint'
+        }
+      })
+    ).rejects.toThrowError(InvalidEndpointSelectedThrowableError)
+  })
+
+  test('Should send an identify event to Segment', async () => {
+    // Mock: Segment Identify Call
+    const segmentEndpoint = SEGMENT_ENDPOINTS[DEFAULT_SEGMENT_ENDPOINT].url
+    nock(segmentEndpoint).post('/identify').reply(200, { success: true })
+
+    const event = createTestEvent({
+      type: 'identify',
+      traits: {
+        name: 'Test User',
+        email: 'test-user@test-company.com'
+      },
+      userId: 'test-user-ufi5bgkko5',
+      anonymousId: 'arky4h2sh7k'
+    })
+
+    const responses = await testDestination.testAction('sendIdentify', {
+      event,
+      mapping: defaultIdentifyMapping,
+      settings: {
+        segment_papi_token: 'segment-papi-token',
+        endpoint: DEFAULT_SEGMENT_ENDPOINT
+      }
+    })
+
+    expect(responses.length).toBe(1)
+    expect(responses[0].status).toEqual(200)
+    expect(responses[0].options.headers).toMatchSnapshot()
+    expect(responses[0].options.json).toMatchSnapshot()
+  })
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/snapshot.test.ts b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/snapshot.test.ts
new file mode 100644
index 00000000..655e9bc7
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/__tests__/snapshot.test.ts
@@ -0,0 +1,76 @@
+import { createTestEvent, createTestIntegration } from '@segment/actions-core'
+import { generateTestData } from '../../../../lib/test-data'
+import destination from '../../index'
+import { DEFAULT_SEGMENT_ENDPOINT } from '../../properties'
+import nock from 'nock'
+
+const testDestination = createTestIntegration(destination)
+const actionSlug = 'sendIdentify'
+const destinationSlug = 'SegmentProfiles'
+const seedName = `${destinationSlug}#${actionSlug}`
+
+describe(`Testing snapshot for ${destinationSlug}'s ${actionSlug} destination action:`, () => {
+  it('required fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, true)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+      auth: undefined
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+
+    expect(request.headers).toMatchSnapshot()
+  })
+
+  it('all fields', async () => {
+    const action = destination.actions[actionSlug]
+    const [eventData, settingsData] = generateTestData(seedName, destination, action, false)
+
+    nock(/.*/).persist().get(/.*/).reply(200)
+    nock(/.*/).persist().post(/.*/).reply(200)
+    nock(/.*/).persist().put(/.*/).reply(200)
+
+    const event = createTestEvent({
+      properties: eventData
+    })
+
+    const responses = await testDestination.testAction(actionSlug, {
+      event: event,
+      mapping: event.properties,
+      settings: { ...settingsData, endpoint: DEFAULT_SEGMENT_ENDPOINT },
+      auth: undefined
+    })
+
+    const request = responses[0].request
+    const rawBody = await request.text()
+
+    try {
+      const json = JSON.parse(rawBody)
+      expect(json).toMatchSnapshot()
+      return
+    } catch (err) {
+      expect(rawBody).toMatchSnapshot()
+    }
+  })
+})
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/generated-types.ts b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/generated-types.ts
new file mode 100644
index 00000000..8f5f40ea
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/generated-types.ts
@@ -0,0 +1,26 @@
+// Generated file. DO NOT MODIFY IT BY HAND.
+
+export interface Payload {
+  /**
+   * The engage space to use for creating a record.
+   */
+  engage_space: string
+  /**
+   * Unique identifier for the user in your database. A userId or an anonymousId is required.
+   */
+  user_id?: string
+  /**
+   * A pseudo-unique substitute for a User ID, for cases when you don’t have an absolutely unique identifier. A userId or an anonymousId is required.
+   */
+  anonymous_id?: string
+  /**
+   * The group or account ID a user is associated with.
+   */
+  group_id?: string
+  /**
+   * Free-form dictionary of traits that describe the user or group of users.
+   */
+  traits?: {
+    [k: string]: unknown
+  }
+}
diff --git a/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/index.ts b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/index.ts
new file mode 100644
index 00000000..5b9c763a
--- /dev/null
+++ b/packages/destination-actions/src/destinations/segment-profiles/sendIdentify/index.ts
@@ -0,0 +1,58 @@
+import type { ActionDefinition } from '@segment/actions-core'
+import type { Settings } from '../generated-types'
+import type { Payload } from './generated-types'
+import { user_id, anonymous_id, group_id, traits, engage_space } from '../segment-properties'
+import { getEngageSpaces, generateSegmentAPIAuthHeaders } from '../helperFunctions'
+import { SEGMENT_ENDPOINTS } from '../properties'
+import { MissingUserOrAnonymousIdThrowableError, InvalidEndpointSelectedThrowableError } from '../errors'
+
+const action: ActionDefinition<Settings, Payload> = {
+  title: 'Send Identify',
+  description:
+    'Send an identify call to Segment’s tracking API. This is used to tie your users to their actions and record traits about them.',
+  defaultSubscription: 'type = "identify"',
+  fields: {
+    engage_space,
+    user_id,
+    anonymous_id,
+    group_id,
+    traits
+  },
+  dynamicFields: {
+    engage_space: async (request, { settings }) => {
+      return getEngageSpaces(request, {
+        endpoint: settings.endpoint,
+        bearerToken: settings.segment_papi_token
+      })
+    }
+  },
+  perform: (request, { payload, settings }) => {
+    if (!payload.anonymous_id && !payload.user_id) {
+      throw MissingUserOrAnonymousIdThrowableError
+    }
+    const groupPayload: Object = {
+      userId: payload?.user_id,
+      anonymousId: payload?.anonymous_id,
+      groupId: payload?.group_id,
+      traits: {
+        ...payload?.traits
+      }
+    }
+
+    // Throw an error if endpoint is not defined or invalid
+    if (!settings.endpoint || !(settings.endpoint in SEGMENT_ENDPOINTS)) {
+      throw InvalidEndpointSelectedThrowableError
+    }
+
+    const selectedSegmentEndpoint = SEGMENT_ENDPOINTS[settings.endpoint].url
+    return request(`${selectedSegmentEndpoint}/identify`, {
+      method: 'POST',
+      json: groupPayload,
+      headers: {
+        authorization: generateSegmentAPIAuthHeaders(payload.engage_space)
+      }
+    })
+  }
+}
+
+export default action
diff --git a/packages/destination-actions/src/destinations/snap-conversions-api/_tests_/index.test.ts b/packages/destination-actions/src/destinations/snap-conversions-api/_tests_/index.test.ts
index 08e29862..06c5f8f0 100644
--- a/packages/destination-actions/src/destinations/snap-conversions-api/_tests_/index.test.ts
+++ b/packages/destination-actions/src/destinations/snap-conversions-api/_tests_/index.test.ts
@@ -367,7 +367,7 @@ describe('Snap Conversions API ', () => {
       expect(responses[0].status).toBe(200)
 
       expect(responses[0].options.body).toMatchInlineSnapshot(
-        `"{\\"integration\\":\\"segment\\",\\"event_type\\":\\"PURCHASE\\",\\"event_conversion_type\\":\\"WEB\\",\\"timestamp\\":1652368875449,\\"mobile_ad_id\\":\\"5af103f270fdc673b5e121ea929d1e47b2cee679e2059226a23c4cba37f8c9a9\\",\\"pixel_id\\":\\"test123\\"}"`
+        `"{\\"integration\\":\\"segment\\",\\"event_type\\":\\"PURCHASE\\",\\"event_conversion_type\\":\\"WEB\\",\\"timestamp\\":1652368875449,\\"hashed_mobile_ad_id\\":\\"5af103f270fdc673b5e121ea929d1e47b2cee679e2059226a23c4cba37f8c9a9\\",\\"pixel_id\\":\\"test123\\"}"`
       )
     })
 
diff --git a/packages/destination-actions/src/destinations/snap-conversions-api/snap-capi-properties.ts b/packages/destination-actions/src/destinations/snap-conversions-api/snap-capi-properties.ts
index 527a0b40..2c219d09 100644
--- a/packages/destination-actions/src/destinations/snap-conversions-api/snap-capi-properties.ts
+++ b/packages/destination-actions/src/destinations/snap-conversions-api/snap-capi-properties.ts
@@ -352,7 +352,7 @@ export const formatPayload = (payload: Payload): Object => {
     event_tag: payload?.event_tag,
     timestamp: Date.parse(payload?.timestamp),
     hashed_email: hash(payload?.email),
-    mobile_ad_id: hash(payload?.mobile_ad_id),
+    hashed_mobile_ad_id: hash(payload?.mobile_ad_id),
     uuid_c1: payload?.uuid_c1,
     hashed_idfv: hash(payload?.idfv),
     hashed_phone_number: hash(payload?.phone_number),
diff --git a/packages/destination-subscriptions/package.json b/packages/destination-subscriptions/package.json
index 88f02809..90ee323d 100644
--- a/packages/destination-subscriptions/package.json
+++ b/packages/destination-subscriptions/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@segment/destination-subscriptions",
-  "version": "3.12.0",
+  "version": "3.13.0",
   "description": "Validate event payload using subscription AST",
   "license": "MIT",
   "repository": {
diff --git a/packages/destination-subscriptions/src/__tests__/validate.test.ts b/packages/destination-subscriptions/src/__tests__/validate.test.ts
index ec2600d5..5277a7b5 100644
--- a/packages/destination-subscriptions/src/__tests__/validate.test.ts
+++ b/packages/destination-subscriptions/src/__tests__/validate.test.ts
@@ -197,7 +197,7 @@ test('operators - less than', () => {
     }
 
     expect(validate(ast, { properties: { value: 5 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '5' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '5' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 10 } })).toEqual(false)
     expect(validate(ast, { properties: { value: '10' } })).toEqual(false)
   }
@@ -219,9 +219,9 @@ test('operators - less than or equal', () => {
     }
 
     expect(validate(ast, { properties: { value: 5 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '5' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '5' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 10 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '10' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '10' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 11 } })).toEqual(false)
     expect(validate(ast, { properties: { value: '11' } })).toEqual(false)
   }
@@ -243,7 +243,7 @@ test('operators - greater than', () => {
     }
 
     expect(validate(ast, { properties: { value: 11 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '11' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '11' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 10 } })).toEqual(false)
     expect(validate(ast, { properties: { value: '10' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 5 } })).toEqual(false)
@@ -267,9 +267,9 @@ test('operators - greater than or equal', () => {
     }
 
     expect(validate(ast, { properties: { value: 11 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '11' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '11' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 10 } })).toEqual(true)
-    expect(validate(ast, { properties: { value: '10' } })).toEqual(true)
+    expect(validate(ast, { properties: { value: '10' } })).toEqual(false)
     expect(validate(ast, { properties: { value: 5 } })).toEqual(false)
     expect(validate(ast, { properties: { value: '5' } })).toEqual(false)
   }
diff --git a/packages/destination-subscriptions/src/validate.ts b/packages/destination-subscriptions/src/validate.ts
index 1a613e6c..5abc5a2c 100644
--- a/packages/destination-subscriptions/src/validate.ts
+++ b/packages/destination-subscriptions/src/validate.ts
@@ -76,13 +76,13 @@ const validateValue = (actual: unknown, operator: Operator, expected?: string |
     case '!=':
       return actual !== String(expected)
     case '<':
-      return Number(actual) < Number(expected)
+      return typeof actual === 'number' && Number(actual) < Number(expected)
     case '<=':
-      return Number(actual) <= Number(expected)
+      return typeof actual === 'number' && Number(actual) <= Number(expected)
     case '>':
-      return Number(actual) > Number(expected)
+      return typeof actual === 'number' && Number(actual) > Number(expected)
     case '>=':
-      return Number(actual) >= Number(expected)
+      return typeof actual === 'number' && Number(actual) >= Number(expected)
     case 'contains':
       return typeof actual === 'string' && actual.includes(String(expected))
     case 'not_contains':
diff --git a/yarn.lock b/yarn.lock
index 78bcbe98..b74a546b 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -2439,21 +2439,6 @@
   resolved "https://registry.yarnpkg.com/@segment/a1-notation/-/a1-notation-2.1.4.tgz#35a48a0688019c3ffff23b1ba890e864c891a11f"
   integrity sha512-SId7GOdDFmm/B9ajIQpXELHW4OTbVvmJbOsoJkQOcUEtoZIiX2UWfk1v4BpKql8wJW9oAhzhIIru2Pv2Yxcg+w==
 
-"@segment/action-destinations@^3.116.0":
-  version "3.116.0"
-  resolved "https://registry.yarnpkg.com/@segment/action-destinations/-/action-destinations-3.116.0.tgz#63b2d1646c3ab8192d80800f298a4c9ef7158bd4"
-  integrity sha512-jg9+GrDct6ISl5PByuYEsacTXF767nG//5+cZOnjTUXW29DLVeC60FGRedwmHuEbR01Fh2g0yWt7ci5l7N+K2A==
-  dependencies:
-    "@amplitude/ua-parser-js" "^0.7.25"
-    "@segment/a1-notation" "^2.1.4"
-    "@segment/actions-core" "^3.43.0"
-    "@segment/actions-shared" "^1.26.0"
-    cheerio "^1.0.0-rc.10"
-    dayjs "^1.10.7"
-    escape-goat "^3"
-    liquidjs "^9.37.0"
-    lodash "^4.17.21"
-
 "@segment/analytics-next@^1.29.3":
   version "1.29.3"
   resolved "https://registry.yarnpkg.com/@segment/analytics-next/-/analytics-next-1.29.3.tgz#51ea4d7e487e95c2862ec5d52fd34a113c20161e"
